---
title: "排序——直接插入排序"
date: 2020-08-20T17:04:38+08:00
draft: true
---

# 直接插入排序

## 一、前言

### 1、基本介绍

想必我们大家都玩过或者了解过斗地主，最基本的扑克玩法都是一边摸牌，一边理牌的。我们可以思考一下，理牌的顺序，是不是把大的牌直接插入在小的牌后面的呢？？例如有以下几张牌（不考虑花色）：6、4、5、3 。将4和5移动到6的左侧，再将3移动到最左侧，顺序就算是整理好了。这里我们所使用到的理牌方法就是**直接插入排序**。

>    直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。

插入排序的**基本思想**：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中含有 n - 1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序吗进行比较，将它插入到有序表中的适当的位置，使之成为新的有序表。

### 2、举栗子

下面以数列{101,34,119,1}为例，

排序流程：

第1轮：i=0。交换34和101的位置， 34,101,119,1；

第2轮：i=1。因为119比101数值大，所以该趟不做任何处理；

第3轮：i=3。1依次与有序表中的数进行比较，直到找到合适的位置为止，也就是最终的顺序，1,34,101,119；

---

## 二、算法实现

因为我们使用一个有序表和一个无序表进行排序，所以默认数组的第一个元素为有序表，也就是**for循环** 的其实位置，`for(int i = 1; i < arr.length; i++)` 所有的排序过程都需要在当前这个for循环中完成。此外，我们还需要定义`int insertVal = arr[i];` 表示为待插入的数；`int insertIndex = i - 1;` 即待插入数的前面的这个数值的下标。

接下来，我们使用**while循环** 给insertVal找到插入的位置。在执行循环的过程中，既要保证给insertVal找插入位置时，**不越界** ；`insertVal > 0`又要确保找到**合适的插入位置** `insertVal < arr[insertIndex]` 。然后将**arr[insertVal] 后移**，因为已将待插入的数arr[i] 保存到临时变量insertVal中，所以后移过程中不会覆盖，比如将举栗子的数列进行第一轮后移变成：{101,101,119,1}。然后再将`insertIndex--;` 如此可以保证有效地执行while循环。

当退出while循环时，说明插入的位置找到，即 **insertIndex + 1**。然后需要做出判断是否需要赋值，即这个位置是否等于待插入数的下标，使用if选择语句即可完成。

**代码实现如下：**

```java
    // 直接插入排序
    public static void insertSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int insertVal = arr[i];// 定义待插入的数
            int insertIndex = i - 1;// 即arr[i]的前面的这个数的下标

            /*
            给insertVal找到插入的位置
            说明：
                1、insertIndex >= 0 保证在给insertVal找插入位置，不越界
                2、insertVal < arr[insertIndex] 待插入的数，还没有找到插入位置
                3、需要将arr[insertIndex] 后移
             */
            while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            //当退出while循环时，说明插入的位置找到，insertIndex + 1
            //判断是否需要赋值
            if (insertIndex + 1 != i) {
                arr[insertIndex + 1] = insertVal;
            }
        }
    }
```

---

## 三、结束语

**直接插入排序时间复杂度**：直接插入排序的时间复杂度是**O(n^2)**。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(n)，需要遍历多少次呢？N-1！因此，直接插入排序的时间复杂度是O(n^2)。

**直接插入排序稳定性**:直接插入排序是稳定的算法，它满足稳定算法的定义。算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！

源码 ——> [直接插入排序](https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/sort/SelectSort.java)