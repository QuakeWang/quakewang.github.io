---
title: "数据结构--稀疏数组"
date: 2020-05-15T14:45:36+08:00
draft: true
---

# 稀疏数组

---

## 一、基本介绍

### 1、实际需求

假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：

```              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 2 0 0 0 0 0 0 0
              0 0 0 1 2 0 0 0 0 0 0
              0 0 0 1 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
```

那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用**稀疏数组**来保存该数组。

### 2、相关概念

基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：

|  行  |  列  |  值  |
| :--: | :--: | :--: |
|  A   |  B   |  C   |
|  E   |  F   |  G   |

- A：表示总行数
- B：表示总列数
- C：表示真正有效数值的个数（除0外的数值）
- E：表示该元素所在的行
- F：表示该元素所在的列
- G：表示该元素的数值

所以上述原始的二维数组转化成稀疏数组，应该如下：

| row  | col  | value |
| ---- | ---- | :---: |
| 10   | 10   |   4   |
| 0    | 3    |   2   |
| 1    | 3    |   1   |
| 1    | 4    |   2   |
| 2    | 2    |   1   |

​          

---

## 二、算法实现

### 1、创建并输出原始二维数组

#### *①创建原始的二维数组：*

**代码实现如下：**

```java
	      // 0表示没有棋子，1表示黑子，2表示白子
        int chessArr1[][] = new int[10][10];// 创建一个原始的二维数组 10*10
        chessArr1[1][3] = 1;
        chessArr1[1][4] = 2;
        chessArr1[2][3] = 1;
        chessArr1[0][3] = 2;				
```

#### *②打印输出原始的二维数组：*

**代码实现如下：**

```java
        for (int[] row : chessArr1) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
```

### 2、将二维数组转换成稀疏数组

#### *①先遍历二维数组，记录非0数值的个数*

​		遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。

**代码实现如下：**

```java
        int sum = 0;// 用于记录非0数值的个数
        for (int i = 0; i < chessArr1.length; i++) {
            for (int j = 0; j < chessArr1.length; j++) {
                if (chessArr1[i][j] != 0) {
                    sum++;
                }
            }
        }
```

#### *②创建对应的二维数组*

​		在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。

**代码实现如下：**

```java
        int sparseArr[][] = new int[sum + 1][3];
        // 给稀疏数组赋值
        sparseArr[0][0] = 10;
        sparseArr[0][1] = 10;
        sparseArr[0][2] = sum;
```

#### *③遍历二维数组，将非0的值存放到 sparseArr 中*

​		在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。

**代码实现如下：**

```java
        int count = 0;// count用于记录是第几个非0数据
        for (int i = 0; i < sparseArr.length; i++) {
            for (int j = 0; j < sparseArr.length; j++) {
                if (chessArr1[i][j] != 0) {
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }
```

#### *④打印输出稀疏数组*

**代码实现如下：**

```java
				for (int i = 0; i < sparseArr.length; i++) {
           System.out.printf("%d\t%d\t%d\t\n",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);
        }
```

### 3、将稀疏数组恢复成原始的二维数组

#### *①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组*

​		将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小

**代码实现如下：**

```java
			int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
```

#### *②再读取稀疏数组后后几行的数据*  **（从第二行开始！！！）**

​		因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i  = 1; 读取所有非0数据即可，其余的位置，默认值为0。

**代码实现如下：**

```java
			for (int i = 1; i < sparseArr.length; i++) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
```

#### *③输出恢复后的二维数组*

**代码实现如下：**

```java
			for (int[] row : chessArr2) {
            for (int data : row) {
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
```

---

## 三、结束语：

​		第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！

​		源码我已push到我的Github仓库，[数据结构](https://github.com/QuakeWang/DataStructes)，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！

