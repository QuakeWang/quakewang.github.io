---
title: "数据结构——数组模拟栈"
date: 2020-06-21T21:59:55+08:00
draft: true
---



# 数组模拟栈

## 一、基本介绍

### 1、相关定义

-    栈是一个先入后出的有序列表；
-    栈是限制线性表中元素的插入和删除只能在线性表的同一段进行的一种特殊线性表。允许插入和删除的一端，为**变化的一端**，称为栈顶（Top）,另一端为**固定的一端**，称为栈底（Bottom）；
-    根据栈的定义可知，最先*放入*栈中的元素在栈底，最后放入的元素在栈顶，而*删除*元素刚好相反，最后放入的元素最先删除，最先删除的元素最后删除。

### 2、应用场景

-    子程序的调用：在跳往子程序前，会先将下个指令的地址存放到堆中，直到子程序执行完后再将地址取出，以回到原来的程序中。
-    处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数、区域变量等数据存入到堆栈中。
-    表达式的转换[*中缀表达式转后缀表达式*]与求值（实际解决）。
-    二叉树的遍历。
-    图形的深度优先（**depth - first**）搜索法。

---

## 二、算法实现

需要构建一个**ArrayStack**类，用于表示栈。

### 1、定义相关变量以及赋值

需要定义的相关变量有：定义一个数组模拟栈**int[] stack**、栈的大小**maxSize**以及栈顶元素**top**。（*在这里我们把栈顶元素top的初始值为-1，有利于后期存入和删除数据*）。

定义完相关变量之后，我们可以利用构造器对**maxSize**和**stack数组**进行赋值。

**代码实现如下：**

```java
    private int maxSize;// 栈的大小
    private int[] stack;// 数组，数组模拟栈，数据就在该数组
    private int top = -1;// top表示栈顶，初始化为-1

    // 构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }
```

### 2、判断栈是否为满

因为数组的下标是从0开始的，所以当栈满时，栈顶元素的下标为**stack[top] = maxSize - 1**;所以当 top == maxSize - 1时，**栈满**。

**代码实现如下：**

```java
    // 栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }
```

### 3、判断栈是否为空

之前在定义相关变量的时候，我们提到**top**的初始值为-1，即当 top == -1时，栈中没有存入任何数据，为空。

**代码实现如下：**

```java
    // 栈空
    public boolean isEmpty() {
        return top == -1;
    }
```

### 4、入栈——push 方法

在入栈之前，我们首先需要判断栈是否已满，如果栈满则给出提示，并结束程序。否则执行以下操作：由于**top**的初始值为-1，即数组第一个元素的前一个位置，因此需要先移动**top**到指定位置，然后给其赋值即可。（*先后移再赋值*）

**代码实现如下：**

```java
    // 入栈——push
    public void push(int value) {
        // 先判断栈是否未满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }
```

### 5、出栈——pop 方法

在进行出栈操作之前，我们首先需要判断栈是否为空，如果为空，则给出相关提示（*这里我们是用抛出异常的方式来进行处理*）；否则，执行以下操作：先定义一个临时变量**value**来存储栈顶元素，然后栈顶元素**top--**，往前移动，最后返回临时变量即可。

**代码实现如下：**

```java
    // 出栈——pop
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空，没有数据~~~");
        }
        int value = stack[top];
        top--;
        return value;
    }
```

### 6、打印输出栈的信息

如果栈为空，则没有任何数据可以显示，所以在输出栈的信息之前，我们需要先判断栈是否为空。在遍历的时候，我们需要从**栈顶**开始显示数据。可以通过*for循环*l来实现。

因为是从栈顶开始显示数据，所以循环的起始位置应该为**栈顶top**，循环结束的条件应该为**i < 0**，每执行一次循环，则需要**i--**。

**代码实现如下：**

```java
    // 遍历栈，遍历时，需要从栈顶开始显示数据
    public void show() {
        if (isEmpty()) {
            System.out.println("栈空，没事有数据~~~");
            return;
        }
        // 需要从栈顶开始显示数据
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }
```

---

## 三、结束语

这里我们使用的是*数组模拟栈*的操作，所以说对应的也可以利用链表来模拟栈，小伙伴们可以自己先尝试一下噢。

在写代码的时候，因为是利用数组模拟栈的相关操作，不由的想起之前写过的[数组模拟单向队列](https://quakewang.github.io/tech/arrayqueue/)，两者可以进行比较的学习，可以思考一下，同样是没有取模的操作，为什么单向队列不能够进行复用，而栈却可以呢？？

源码地址——> [数据结构](https://github.com/QuakeWang/DataStructes)