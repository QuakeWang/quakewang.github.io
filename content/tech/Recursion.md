---
title: "数据结构——递归"
date: 2020-07-26T10:59:35+08:00
---

# 关于递归

## 一、前言

说起**递归**，可能有些同学会问，什么是递归啊？？ 我们举个简单的栗子：如果你站在镜子前面，这时你会在镜子中看见自己的像，称这个镜子为A；那么有没有试一下在手里也拿一面镜子，把手里的镜子称为镜子B，然后将A、B两面镜子互相面对面放着，你再往中间那么一站，神奇的情况发生了，将会发现两面镜子中都有你的“化身”。为什么会出现这种现象呢？？原来，A镜子里有B镜子的像，B镜子里也有A镜子的像，这样反反复复，就会产生一连串的“像中像”。这其实就是一种**递归**现象。

说简单点，就是*递归就是方法自己调用自己*，每次调用时*传入不同的变量*。（递归有助于开发者解决复杂的问题，同时可以让代码变得更简洁）

---

## 二、递归规则

递归需要遵守的重要规则：

1）执行一个方法时，就创建一个新的受保护的独立空间（栈空间）；

2）方法的局部变量是独立的，不会相互影响，比如n变量；

3）如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据；

4）递归**必须向退出递归的条件逼近**，否则就是无限递归，出现StackOverflowError，*死龟了* : ) ；

5）当一个方法执行完毕，或者遇到return，就会返回，**遵守谁调用，就将结果返回给谁**，同时方法执行完毕或者返回时，该方法也就执行完毕了。

---

## 三、斐波那契数列

### 1、概要

**斐波那契数列（Fibonacci）**是一个典型的递归例子，说如果兔子在出生两个月之后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有的兔子都不死。那么，一年以后可以繁殖多少对兔子？？

我们拿新出生的一对小兔子来分析一下：第一个月的小兔子是没有繁殖能力的，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月后，老兔子又生下一对，因为上个月出生的小兔子还没有繁殖能力，所以还是一共还是三对……依次类推，可以列出下表：

| 所经过的月数 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 兔子对数     | 1    | 1    | 2    | 3    | 5    | 8    | 13   | 21   | 34   | 55   | 89   | 144  |

表中数字1,1,2,3,5,8,13……构成一个序列。这个数列有个明显的特点就是：**前面相邻两项之和，构成了后一项**。

### 2、常规解法

先思考一下，如果我们要实现斐波那契数列用常规的*迭代*方法应该如何实现？

**代码实现如下：**

```java
        int[] a = new int[13];
        a[0] = 0;
        a[1] = 1;
        System.out.println("未使用递归计算：");
        System.out.println("a[0] = " + a[0]);
        System.out.println("a[1] = " + a[1]);
        for (int i = 2; i < a.length; i++) {
            a[i] = a[i - 1] + a[i - 2];
            System.out.printf("第%d个月兔子总数为：%d", i, a[i]);
            System.out.println();
        }
```

我们来简单看一遍这段代码，**数组a[]**表示从*第0月到第12月*，其中第0个月没有任何兔子，第一个月有一对兔子，然后我们利用for循环，从**第2个月**开始计算，即下一个月的兔子数为前两个月兔子数相加。

代码很简单，几乎不用怎么解释，都可以理解，但其实，我们如果使用递归来实现，代码将会更加整洁。

### 3、递归解法

**代码实现如下：**

```java
        // 使用递归计算
        System.out.println("使用递归计算如下：");
        for (int i = 0; i < a.length; i++) {
            System.out.printf("第%d个月兔子总数为：%d", i, Fbi(i));
            System.out.println();
        }

    // 使用递归的方法处理
    public static int Fbi(int i) {
        if (i < 2) {
            return i == 0 ? 0 : 1;
        } else {
            return Fbi(i - 1) + Fbi(i - 2);
        }
    }
```

虽然代码整体而言要简洁许多，但却并不是那么好理解。函数怎么可以自己调用自己？？听起来确实有些难以理解，不过我们可以不把一个递归函数中调用自己的函数看作是在调用自己，而就当它是在调用另一个函数。只不过，这个函数和自己长得一样而已。

我们来模拟代码中的Fbi(i)函数当i = 5的执行过程。Fbi(5) = Fbi(4) + Fbi(3) = Fbi(3) + Fbi(2) + Fbi(2) + Fbi(1) = Fbi(2) + Fbi(1) + 1 + 1 + 1 = 1 + 1 + 1 + 1 + 1 = 5

## 三、结束语

我们来对比一下这两种实现斐波那契的代码。迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归可以使程序的结构更清晰、更简洁、更容易让人理解。从而有效地减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同的情况选择不同的代码实现方式。

斐波那契数列源码地址 ——> [Fibonacci](https://github.com/QuakeWang/DataStructes/blob/master/src/com/quake/recursion/Fibonacci.java)

>    《大话数据结构》 ——程杰



