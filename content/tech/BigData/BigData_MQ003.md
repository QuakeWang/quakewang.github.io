---
title: "MQ003—通信协议"
date: 2023-07-18T11:52:35+08:00
draft: true

---

# 如何为消息引擎系统设计一个好的通信协议？

## 前言

经过上面两篇博客的梳理，已经了解了 MQ 的基本概念。从功能上看，一个最基础的消息引擎系统应该具备生产、存储和消费的能力。也就是能够完成“生产者把数据发送到 Broker，Broker 收到数据后，持久化存储数据，最后消费者从 Broker 消费数据”的整个流程。

从整个流程来拆解技术架构，最基础的消息引擎系统应该具备五个模块：

- 通信协议：用来完成客户端（生产者和消费者）和 Broker 之间的通信，比如生产和消费；
- 网络模块：客户端用来发送数据，服务端用来接收数据；
- 存储模块：服务端用来完成持久化数据存储；
- 生产者：完成生产相关的功能；
- 消费者：完成消费相关的功能。

其实消息引擎系统，本质上讲就是个 CS 模型，即通过客户端和服务端之间的交互完成生产、消费等行为。那么客户端和服务端之间的通信流程是如何实现的呢？？

这就是今天的重点——**通信协议**。为了完成交互，我们第一步就需要确定服务端和客户端是如何通信的。而通信的第一步就是确定使用哪种通信协议进行通信。

## 通信协议基础

所有协议的选择和设计都是根据需求来的，我们知道 MQ 的核心特性是**高吞吐、低延时、高可靠**，所以在协议上至少需要满足：

- 协议可靠性要高，不能丢数据；
- 协议的性能要高，通信的延时要低；
- 协议的内容要精简，带宽的利用率要高；
- 协议需要具备可扩展能力，方便功能的增减。

那没有没现成的满足这四个要求的协议呢？

目前业界的通信协议可以分为**公有协议**和**私有协议**两种。公有协议指公开的受到认可的具有规范的协议，比如 JMS、HTTP、STOMP 等。私有协议是指根据自身的功能和需求设计的协议，一般不具备通用性，比如 Kafka、RocketMQ、Puslar 的协议都是私有协议。

其实 MQ 领域是存在公有的、可直接使用的标准协议的，比如 AMQP、MQTT、OpenMessaging，它们设计的初衷就是为了解决因各个消息队列的协议不一样导致的组件互通、用户使用成本高、重复设计、重复开发成本等问题。但是，公有的标准协议讨论制定需要较长时间，往往无法及时赶上需求的变化，灵活性不足。

因此大多数消息队列为了自身的功能支持、迭代速度、灵活性考虑，在核心通信协议的选择上不会选择公有协议，都会选择自定义私有协议。那私有协议要怎么设计实现呢？从技术上来看，私有协议设计一般需要包含三个步骤。

- **网络通信协议选型**，指计算机七层网络模型中的协议选择。比如传输层的 TCP/UDP、应用层的 HTTP/WebSocket 等；
- **应用通信协议设计**，指如何约定客户端和服务端之间的通信规则。比如如何识别请求内容、如何确定请求字段信息等；
- **编解码（序列化 / 反序列化）实现**，用于将二进制的信息的内容解析为程序可识别的数据格式。

