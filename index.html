<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" AKA二夕" />
  	<meta property="og:site_name" content="AKA二夕" />
  	<meta property="og:url" content="https://quakewang.github.io/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     AKA二夕
  </title>

    <meta name="description" content="This is my blog based on the boilerplate of Hugo. I want to share some  notes about study here,and some interesting things about my life." />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://quakewang.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://quakewang.github.io/images/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://quakewang.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
      
        <link href="https://quakewang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="AKA二夕" />
      
    
    <meta name="generator" content="Hugo 0.71.1" />

    <link rel="canonical" href="https://quakewang.github.io/" />

     
</head>
<body class="nav-closed">
<div id="particles-js"></div>
  


 <div class="site-wrapper">



<header class="main-header " style="background-image: url(https://quakewang.github.io/images/user.jpg)">


    

    <nav class="main-nav overlay clearfix">
        
            <a class="blog-logo" href="https://quakewang.github.io/"><img src="https://quakewang.github.io/images/user.png" alt="Blog Logo" /></a>
        
        
    </nav>
<div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">
              <a class="btn-bootstrap-2 title-scroll" href="#content">AKA二夕</a>
          </h1>
          <h2 class="page-description">This is my blog based on the boilerplate of Hugo. I want to share some  notes about study here,and some interesting things about my life.</h2>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    
    
    
    
    
    

    <div class="extra-pagination inner">
        <nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 2</span>
	
	    <a class="older-posts" href="https://quakewang.github.io/page/2/">Older Posts &rarr;</a>
	
</nav>

    </div>

    
    
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/06/06/doublelinkedlist/">DoubleLinkedList</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="双向链表">双向链表</h1>
<hr>
<h2 id="一基本介绍">一、基本介绍</h2>
<p>在上一篇博客中，我们提到了单链表，它只有一个next指针，指向下一个结点，所以我们要查找下一个结点是很容易做到的，但是要想查找上一个结点就复杂的多了。因此有了<strong>双向链表</strong>。</p>
<p><strong>双向链表</strong>有两个指针域，除了有next域指向下一个结点之外，还有pre域指向上一个结点。这样使得双链表可以双向遍历。节省了时间成本，但相比于单链表插入数据和删除数据就相对复杂一些。下面我们对双链表进行简单学习一下吧。</p>
<hr>
<h2 id="二算法实现">二、算法实现</h2>
<p>双链表和单链表一样，需要创建一个类用于存放结点信息，再创建一个类用于管理结点，对双链表进行相关的操作。</p>
<h3 id="1定义节点类">1、定义节点类</h3>
<p>我们需要在HeroNode2类中实现相关变量的定义、赋值以及显示信息的方法。</p>
<h4 id="相关变量">①相关变量</h4>
<p>这里我们使用双链表存储水浒英雄，和单链表相同，还得增加一个pre指针，指向前一个结点。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> no<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> String name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> String nickname<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> HeroNode2 pre<span style="color:#f92672">;</span><span style="color:#75715e">// 指向下一个结点，默认为null
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> HeroNode2 next<span style="color:#f92672">;</span><span style="color:#75715e">// 指向前一个结点，默认为null
</span></code></pre></div><h4 id="构造器">②构造器</h4>
<p>利用构造器，对相关变量进行赋值。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HeroNode2</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> no<span style="color:#f92672">,</span> String name<span style="color:#f92672">,</span> String nickname<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">=</span> no<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">nickname</span> <span style="color:#f92672">=</span> nickname<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="显示链表信息">③显示链表信息</h4>
<p>这里利用toString方法，返回链表的信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 为了显示方法，重写toString
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;HeroNode2{&#34;</span> <span style="color:#f92672">+</span>
                <span style="color:#e6db74">&#34;no=&#39;&#34;</span> <span style="color:#f92672">+</span> no <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;\&#39;&#39;</span> <span style="color:#f92672">+</span>
                <span style="color:#e6db74">&#34;, name=&#39;&#34;</span> <span style="color:#f92672">+</span> name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;\&#39;&#39;</span> <span style="color:#f92672">+</span>
                <span style="color:#e6db74">&#34;, nickname=&#34;</span> <span style="color:#f92672">+</span> nickname <span style="color:#f92672">+</span>
                <span style="color:#e6db74">&#39;}&#39;</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h3 id="2定义一个doublelinkedlist类管理结点">2、定义一个DoubleLinkedList类管理结点</h3>
<p>我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，同样需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 先初始化一个结点，头结点不要动，不存放具体的数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> HeroNode2 head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HeroNode2<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
</code></pre></div><h4 id="添加数据到队列尾">①添加数据到队列尾</h4>
<p>与单链表相同，需要先定义一个辅助变量temp，利用while循环遍历到链表的最后。当退出while循环时，即temp指向了链表的最后。这时我们需要将temp的next域指向需要添加的结点，然后再将需要添加的结点的pre域指向temp，完成添加。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 添加一个结点到双向链表的最后
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>HeroNode2 heroNode2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 因为head结点不能动，因此我们需要添加一个辅助变量temp
</span><span style="color:#75715e"></span>        HeroNode2 temp <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 遍历链表，知=找到链表的最后
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">// 遍历到链表的最后
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 如果没有找到将temp后移
</span><span style="color:#75715e"></span>            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">// 后移
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 当退出while循环时，temp就指向了链表的最后
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 形成了一个双向链表
</span><span style="color:#75715e"></span>        temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> heroNode2<span style="color:#f92672">;</span>
        heroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="根据编号顺序添加结点">②根据编号顺序添加结点</h4>
<p>与单链表相同，需要先找到需要添加结点(heroNode2)的前一个结点（temp），这里不做过多赘述。当找到需要添加的结点的前一个结点之后，需要进行如下操作：</p>
<p>需要先将heroNode2完成拼接，即先将heroNode2的next域指向temp.next;（新插入节点的前一个结点指向它的下一个结点），再将heroNode的pre域指向temp（将新插入的结点指向它的前一个结点），这时heroNode的pre域和next域已经分别指向了heroNode的前驱结点和后继结点；剩余需要做的就是让heroNode的前驱结点的next域和后继结点的pre域指向heroNode，但需要注意的是：如果添加的位置刚好是最后一个结点，则heroNode没有后继结点，也就是不用执行<strong>temp.next.pre = heroNode2</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 根据编号顺序添加结点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addByOrder</span><span style="color:#f92672">(</span>HeroNode2 heroNode2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        HeroNode2 temp <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">&gt;</span> heroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">==</span> heroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flag<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;需要插入的英雄编号%d已存在，添加失败\n&#34;</span><span style="color:#f92672">,</span> heroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            heroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">// 将新插入的结点指向它的下一个结点
</span><span style="color:#75715e"></span>            heroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span><span style="color:#75715e">// 将新插入的结点指向它的前一个结点
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 注：如果不是最后一个结点，则不需要执行下面这块代码，否则会出现空指针
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> heroNode2<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> heroNode2<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="修改结点信息">③修改结点信息</h4>
<p>修改结点信息的方法和单链表如出一辙，通过遍历找到需要修改结点所在的位置即可。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 修改结点信息（可以看待双向链表的结点内容修改和单向链表一样）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span><span style="color:#f92672">(</span>HeroNode2 newHeroNode2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 判断链表是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;链表为空~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 找到需要修改的结点，根据no编号
</span><span style="color:#75715e"></span>        HeroNode2 temp <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">// 定义一个辅助变量
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">==</span> newHeroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">// 找到
</span><span style="color:#75715e"></span>                flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//根据flag判断是否找到需要修改的节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flag<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> newHeroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">;</span>
            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">nickname</span> <span style="color:#f92672">=</span> newHeroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">nickname</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span><span style="color:#75715e">//没有找到
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;没有找到 编号%d的节点，不能修改&#34;</span><span style="color:#f92672">,</span> newHeroNode2<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="删除结点">④删除结点</h4>
<p>从双向链表中删除一个结点，我们只需直接找到需要删除的结点，找到后，双链表可以实现**自我删除*。</p>
<p>具体操作如下：定义一个辅助变量temp = head.next;这里我们直接找到该结点所在的位置，所以temp直接等于head.next;还需要一个flag标记是否找到待删除结点。通过遍历找到链表的最后，然后让temp的前驱结点的next域直接指向temp的下一个结点，即<strong>temp.pre.next = temp.next</strong>;如果待删除结点不是最后的结点，则还需要执行下列操作：让temp的下一个结点的pre指向temp的前一个结点，即<strong>temp.next.pre = temp.pre</strong>;完成上述操作之后，待删除结点的前后指针都指向null，也就完成了删除。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">del</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> no<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 判断当前链表是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">// 空链表
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;链表为空，无法删除~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        HeroNode2 temp <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 辅助变量(指针)
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 标志是否找到待删除节点的
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 已经到链表的最后
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">==</span> no<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 找到的待删除节点的前一个节点temp
</span><span style="color:#75715e"></span>                flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span> <span style="color:#75715e">// temp后移，遍历
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 判断flag
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flag<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 找到
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 可以删除
</span><span style="color:#75715e"></span>            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span><span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;要删除的 %d 节点不存在\n&#34;</span><span style="color:#f92672">,</span> no<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="输出链表信息">⑤输出链表信息</h4>
<p>和单链表操作相同。。。。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 遍历打印输出链表信息
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">show</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 先判断链表是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;链表为空~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 因为头结点不能动，定义一个辅助变量用于遍历
</span><span style="color:#75715e"></span>        HeroNode2 temp <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 判断是否到链表最后
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 输出结点信息
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>temp<span style="color:#f92672">);</span>
            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">// 将temp后移！！！
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h2 id="三结束语">三、结束语</h2>
<p>到这里，我们完成了对于双链表的相关操作。双向链表相对于单链表来说，要更复杂一些，毕竟它多了pre指针，进行删除和操作的时候需要格外小心。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点操作带来了方便，可以有效提高算法的时间性能。说白了，就是用空间换时间。</p>
<p>源代码——&gt;<a href="https://github.com/QuakeWang/DataStructes">数据结构</a></p>
<blockquote>
<p>《大话数据结构》 ——程杰</p>
<p>图解数据结构与算法——韩顺平</p>
</blockquote>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-06-06T14:48:57&#43;08:00">
            6 Jun 2020
        </time>
    </footer>
</article>

  
    
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/06/01/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/">单链表的使用</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="单链表的应用举例">单链表的应用举例</h1>
<h2 id="一前言">一、前言</h2>
<p>在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操作：</p>
<ol>
<li>获取单链表的有效结点</li>
<li>查找单链表中的倒数第k个结点</li>
<li>逆序打印单链表（从尾到头打印）</li>
<li>反转单链表</li>
</ol>
<hr>
<h2 id="二算法介绍">二、算法介绍</h2>
<h3 id="1获取单链表的有效结点">1、获取单链表的有效结点</h3>
<p>作为使用的第一个方法难度不是很大。因为需要求出单链表中有效结点的个数，所以我们可分为<strong>带头结点</strong>和<strong>不带头结点</strong>两种情况。</p>
<p>我们这边考虑的是不带头结点的单链表，（如果是带头结点的链表需要再加上头结点即可）。需要的变量有<strong>length(统计链表的长度)<strong>和</strong>cur(辅助变量，用于遍历)</strong>，可以通过传入一个头结点，然后依次遍历该链表，当链表遍历到最后的时候，即<strong>cur.next == null</strong>，每一次遍历链表的长度加一，即<strong>length++</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#75715e">// head链表的头结点，返回的就是有效结点的个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getLength</span><span style="color:#f92672">(</span>HeroNode head<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">// 链表为空
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        HeroNode cur <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">// 定义一个辅助变量
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            length<span style="color:#f92672">++;</span>
            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> length<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="2查找单链表中的倒数第k个结点">2、查找单链表中的倒数第k个结点</h3>
<p>因为单链表是单向的，只能从头到尾开始遍历，而无法从后往前遍历，所以我们需要传入一个头结点<strong>head（遍历的起始位置）<strong>和</strong>index(倒数第k个结点)</strong>。</p>
<p>定义一个<strong>size</strong>表示链表的长度，也就是链表有效结点的个数，可以通过方法一来获取。即<strong>size = getLength(head)</strong>，然后需要定义一个辅助变量用于遍历。然后通过for循环定位到倒数的index，即<strong>size - index</strong>的位置，也就是需要查找的倒数第k个结点。最后返回当前的辅助变量，完成查找。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> HeroNode <span style="color:#a6e22e">findLastIndexNode</span><span style="color:#f92672">(</span>HeroNode head<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 判断链表是否为空，如果是则返回null
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span><span style="color:#75715e">// 没有找到
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 第一次遍历得到链表对的长度（结点个数）
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> getLength<span style="color:#f92672">(</span>head<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 先做一个index校验
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>index <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> index <span style="color:#f92672">&gt;</span> size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 定义一个辅助变量，for循环定位到倒数的index
</span><span style="color:#75715e"></span>        HeroNode cur <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 第二次遍历 size - index位置，就是倒数的第k个结点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">-</span> index<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> cur<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="3逆序打印单链表">3、逆序打印单链表</h3>
<p>在不改变链表结构的情况下，进行逆序打印，我们可以利用栈这个数据结构来实现。栈的特点就是<strong>先进后出</strong>。先把链表push压入栈中，再pop出栈即可。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reversePrint</span><span style="color:#f92672">(</span>HeroNode head<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span><span style="color:#75715e">// 空链表，不能打印
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 创建一个栈，将各个结点压入栈
</span><span style="color:#75715e"></span>        Stack<span style="color:#f92672">&lt;</span>HeroNode<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        HeroNode cur <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 将链表的所有结点压入到栈
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>cur<span style="color:#f92672">);</span>
            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 将栈中的结点进行打印，pop出栈
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">());</span><span style="color:#75715e">// stack的特点就是先进后出
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="4反转单链表有点难度">4、反转单链表（有点难度）</h3>
<p>对单链表进行反转，表示的意思是：将最后的结点变成最前端的结点，以此类推。所以我们需要分为两种情况：</p>
<ol>
<li>当前链表为空，或者当前链表只有一个结点，无需反转，直接返回即可。</li>
<li>有多个结点时：</li>
</ol>
<p>需要的变量有：<strong>cur(用于遍历原来的链表)</strong>，<strong>nextNode(指向当前结点[cur]的下一个结点)</strong>，<strong>reverseHead(结点，新链表的最前端)</strong>。</p>
<p>具体操作过程如下：先将nexNodet指向cur的下一个结点，<em>用于保存当前结点的下一个结点</em>，然后将cur的下一个结点指向新链表的最前端，即<strong>cur.next = reverseHead.next</strong>,然后再<em>将cur连接到新的链表上</em>，这样才能形成一个完成的链表（一个回路）。然后后移，遍历下一个结点，即<strong>cur = nextNode</strong>;在进行上述操作之后，我们已经将链表的所有结点取出，并存放在新的链表下，这时我们需要将head.next 指向 reverseHead.next，实现单链表的反转，即**head.next = reverseHead,next;**完成单链表的反转。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverseList</span><span style="color:#f92672">(</span>HeroNode head<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果当前链表为空，或者只有一个结点，无需反转，直接返回
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        HeroNode cur <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">// 定义一个辅助变量，帮助遍历原来的链表
</span><span style="color:#75715e"></span>        HeroNode nextNode <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span><span style="color:#75715e">// 指向当前结点[cur]的下一个结点
</span><span style="color:#75715e"></span>        HeroNode reverseHead <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HeroNode<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">// 遍历原来的链表，每遍历一个结点，将其取出，并放在新的链表reverseHead的最前端
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            nextNode <span style="color:#f92672">=</span> cur<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">// 先暂时保存当前结点的下一个结点，
</span><span style="color:#75715e"></span>            cur<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> reverseHead<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;;</span><span style="color:#75715e">// 将cur的下一个结点指向新的链表的最前端
</span><span style="color:#75715e"></span>            reverseHead<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> cur<span style="color:#f92672">;</span><span style="color:#75715e">// 将cur连接到新的链表上
</span><span style="color:#75715e"></span>            cur <span style="color:#f92672">=</span> nextNode<span style="color:#f92672">;</span><span style="color:#75715e">// 让cur后移
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 将 head.next 指向 reverseHead.next，实现单链表的反转
</span><span style="color:#75715e"></span>        head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> reverseHead<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h2 id="三结束语">三、结束语</h2>
<p>其实我们不难发现，数组也好，链表也罢，都只是存储信息的不同方式，最重要的还是对其的理解和使用，只有这样才能更好的掌握。对于一个刚接触数据结构的小白来说，学到这里的时候，信息量已经远远超过之前所学的知识，但并不应该气馁，数据结构多而且难，所以更需要我们耐下性子，去慢慢琢磨、回顾，愿成长路上，与君共勉！</p>
<p>源码地址——&gt;<a href="https://github.com/QuakeWang/DataStructes">数据结构</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-06-01T21:22:48&#43;08:00">
            1 Jun 2020
        </time>
    </footer>
</article>

  
    
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/">数据结构--单向链表</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="单向链表">单向链表</h1>
<h2 id="一基本介绍">一、基本介绍</h2>
<h3 id="1相关定义">1、相关定义</h3>
<p>链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的，且链表的长度不是固定的。链表的每个元素称为一个结点，每个结点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑关系，以便构成“一个结点链着一个结点”的链式存储结构，为了保持每个结点之间的链接，所以链表除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个结点都包含两个部分，第一部分用于存储元素本身的数据信息，称为<strong>数据域</strong>，它不局限于一个成员数据，也可是多个成员数据；第二部分是一个结构体指针，称为链表的<strong>指针域</strong>，用于存储其直接后继的节点信息，这里用next表，next的值实际上就是<strong>下一个结点的地址</strong>，当前结点为末结点时，next的值设为空指针，即为null。链表在使用过程中，可以根据实际需求来判断是否需要添加头结点。</p>
<h3 id="2链表与数组比较">2、链表与数组比较</h3>
<p>数组（包括结构体数组）的实质是一种线性表的顺序表示方式，它的优点是使用直观，便于快速、随机地存取线性表中的任一元素，但缺点是对其进行插入和删除操作时需要移动大量的数组元素，同时由于数组属于静态内存分配，定义数组时必须指定数组的长度，程序一旦运行，其长度就不能再改变，实际使用个数不能超过数组元素最大长度的限制，否则就会发生下标越界的错误，低于最大长度时又会造成系统资源的浪费，因此空间效率差。</p>
<hr>
<h2 id="二算法实现">二、算法实现</h2>
<p>我们需要定义一个类用来存放结点信息，同时也还需要定义一个类用于管理结点，实现单链表的增删改查。</p>
<h3 id="1定义一个heronode类表示结点">1、定义一个HeroNode类表示结点</h3>
<p>我们需要在HeroNode类中实现相关变量的定义、赋值以及显示信息的方法。</p>
<h4 id="-相关变量">① 相关变量</h4>
<p>这里我们使用单链表来存储水浒英雄，需要存储的信息有：编号、姓名和昵称。还需要定义一个next域用于指向下一个结点。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> no<span style="color:#f92672">;</span><span style="color:#75715e">// 编号
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> String name<span style="color:#f92672">;</span><span style="color:#75715e">// 姓名
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> String nickname<span style="color:#f92672">;</span><span style="color:#75715e">// 昵称
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> HeroNode next<span style="color:#f92672">;</span><span style="color:#75715e">// next域，指向下一个节点
</span></code></pre></div><h4 id="构造器">②构造器</h4>
<p>可以利用构造器对相关变量进行赋值。</p>
<p><strong>代买实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HeroNode</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> no<span style="color:#f92672">,</span> String name<span style="color:#f92672">,</span> String nickname<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">=</span> no<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">nickname</span> <span style="color:#f92672">=</span> nickname<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="显示链表信息">③显示链表信息</h4>
<p>我们可以使用toString方法来显示链表的信息。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 利用toString显示信息
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;HeroNode{&#34;</span> <span style="color:#f92672">+</span>
                <span style="color:#e6db74">&#34;no=&#39;&#34;</span> <span style="color:#f92672">+</span> no <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;\&#39;&#39;</span> <span style="color:#f92672">+</span>
                <span style="color:#e6db74">&#34;, name=&#39;&#34;</span> <span style="color:#f92672">+</span> name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;\&#39;&#39;</span> <span style="color:#f92672">+</span>
                <span style="color:#e6db74">&#34;, nickname=&#34;</span> <span style="color:#f92672">+</span> nickname <span style="color:#f92672">+</span>
                <span style="color:#e6db74">&#39;}&#39;</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="2定义一个singlelinkedlist类管理结点">2、定义一个SingleLinkedList类管理结点</h3>
<p>我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">//先初始化一个头节点，头节点不要动，不存放具体的数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> HeroNode head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HeroNode<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
</code></pre></div><h4 id="直接添加数据到单链表">①直接添加数据到单链表</h4>
<p>直接添加数据到队列尾，即不考虑编号按照添加顺序，入链表。因为头结点不能动，所以需要定义一个临时变量temp用于遍历。通过后移temp实现遍历，<strong>temp = temp.next</strong> 。遍历的目的在于，找到当前链表最后的结点，然后将最后这个结点的next指向新的结点，便完成了添加的操作。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>HeroNode heroNode<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//因为head节点不能动，因此我们需要一个辅助变量temp
</span><span style="color:#75715e"></span>        HeroNode temp <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#75715e">//遍历链表，找到最后
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//找到链表的最后
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">//如果没有找到最后，将temp后移
</span><span style="color:#75715e"></span>            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//当退出while循环时，temp指向了链表的最后
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//将最后这个节点的next指向新的节点
</span><span style="color:#75715e"></span>        temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> heroNode<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="根据编号添加结点">②根据编号添加结点</h4>
<p>这次我们使用按照编号顺序添加结点，如果该编号已经存在，则添加失败，并给出提示。按照编号添加结点，使用的方法是通过 <strong>后移temp</strong> 遍历，找到该编号的前一个结点，然后让需要的添加结点先指向前一个结点的下一个结点，然后再让前一个结点指向需要添加的结点。所以需要一个flag变量来标记是否找到当前结点。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addByOrder</span><span style="color:#f92672">(</span>HeroNode heroNode<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//因为头节点不能动，因此仍然需要通过一个辅助指针（变量）来帮助找到添加的位置
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//因此我们找的temp是位于添加位置的前一个节点，否则插入不了
</span><span style="color:#75715e"></span>        HeroNode temp <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span><span style="color:#75715e">//标志添加的编号是否存在，默认为false
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//说明temp已经在链表的最后
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">&gt;=</span> heroNode<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//位置找到，就在temp的后面插入
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">==</span> heroNode<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//说明希望添加的heroNode编号已经存在
</span><span style="color:#75715e"></span>                flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span><span style="color:#75715e">//说明编号存在
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">//后移，遍历当前链表
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//判断flag的值
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flag<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//不能添加，说明编号已经存在
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;准备插入的英雄编号%d已经存在，添加失败\n&#34;</span><span style="color:#f92672">,</span> heroNode<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//插入到链表中，temp的后面
</span><span style="color:#75715e"></span>            heroNode<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> heroNode<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="修改结点信息">③修改结点信息</h4>
<p>这里我们通过根据编号来修改结点信息，即编号不能改。同时需要传入一个新的结点 <strong>newHeroNode</strong> ，用于存储修改结点的信息。在进行修改之前，需要先判断单链表是否为空，<strong>head.next == null</strong> 链表为空。然后定义一个辅助变量temp和flag分别用于遍历和标记是否找到当前结点。如果 <strong>temp.no == newHeroNode.no</strong> 表示找到当前需要修改的结点。赋予新的name和nickname完成修改结点的操作。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">//1、根据newHeroNode的no来修改即可
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span><span style="color:#f92672">(</span>HeroNode newHeroNode<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//判断是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;链表为空&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//2、找到需要修改的节点，根据num编号修改
</span><span style="color:#75715e"></span>        HeroNode temp <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">//定义一个辅助变量
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span><span style="color:#75715e">//表示是否找到该节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span><span style="color:#75715e">//已经遍历结束
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">==</span> newHeroNode<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//找到
</span><span style="color:#75715e"></span>                flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//3、根据flag，判断是否找到需要修改的节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flag<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> newHeroNode<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">;</span>
            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">nickname</span> <span style="color:#f92672">=</span> newHeroNode<span style="color:#f92672">.</span><span style="color:#a6e22e">nickname</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span><span style="color:#75715e">//没有找到
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;没有找到编号%d的节点，不能修改\n&#34;</span><span style="color:#f92672">,</span> newHeroNode<span style="color:#f92672">.</span><span style="color:#a6e22e">no</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="删除结点">④删除结点</h4>
<p>在进行删除结点的操作的时候，我们仍然根据编号来进行寻找需要删除的结点。找到需要删除结点的前一个结点，让前一个结点的next跨过需要删除的结点，直接指向下一个结点，即 <strong>temp.netx = temp.next.next</strong> ，完成删除。在进行删除之前仍然需要定义temp和flag用于遍历和标记是否找到需要删除结点的前一个结点。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">del</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> no<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        HeroNode temp <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span><span style="color:#75715e">//标志是否找到待删除节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span><span style="color:#75715e">//已经到链表的最后
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">no</span> <span style="color:#f92672">==</span> no<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//找到待删除节点的前一个节点temp
</span><span style="color:#75715e"></span>                flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span><span style="color:#75715e">//temp后移，遍历
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//判断flag
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flag<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//找到
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//可以删除
</span><span style="color:#75715e"></span>            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;需要删除的%d节点不存在\n&#34;</span><span style="color:#f92672">,</span> no<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="显示链表信息-1">⑤显示链表信息</h4>
<p>在显示链表信息之前，需要先判断链表是否为空，并给出相关信息。通过后移临时变量temp完成遍历。先输出结点信息，每当输出一个结点信息，就需要后移一次。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">//显示链表，遍历
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">show</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//判断链表是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;链表为空&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//因为头节点不能动，因此我们需要一个辅助变量来遍历
</span><span style="color:#75715e"></span>        HeroNode temp <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>temp <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">// 判断是否到链表最后
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//输出节点的信息
</span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>temp<span style="color:#f92672">);</span>
            <span style="color:#75715e">//将temp后移
</span><span style="color:#75715e"></span>            temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h2 id="三结束语">三、结束语</h2>
<p>到此，我们了解了有关单链表的相关操作。在算法实现过程中，可能不少小朋友会发现一些问题，比如为什么有时候临时变量 <strong>temp = head.next</strong> ， 而有时却变成了<strong>temp = head</strong> 了呢？？其实仔细阅读一遍代码，我们不难发现，当进行增删操作的时候，<strong>temp = head</strong> ，那是因为需要增删的结点刚好是直接添加到头结点之后的，如果变成了 <strong>head.next</strong> ， 则会造成覆盖结点的情况；而在进行修改和遍历的时候，临时变量 <strong>temp = head.next</strong> ，那是因为我们这里定义头结点为空，不存放任何数据，所以修改和遍历的时候，需要从真正的有效结点开始。</p>
<p>源码已经push到 ——&gt;<a href="https://github.com/QuakeWang/DataStructes">数据结构</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-05-30T16:23:52&#43;08:00">
            30 May 2020
        </time>
    </footer>
</article>

  
    
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/">数据结构--数组模拟环形队列</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="数组模拟环形队列">数组模拟环形队列</h1>
<hr>
<h2 id="一前言">一、前言</h2>
<p>在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。</p>
<hr>
<h2 id="二算法实现">二、算法实现</h2>
<h3 id="1初始化相关变量">1、初始化相关变量</h3>
<p>需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对<strong>front</strong>和<strong>rear</strong>做以下调整：<strong>front</strong>由原来指向队列的前一个位置，改变为队列的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；<strong>rear</strong>从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为<strong>maxSize - 1</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">;</span><span style="color:#75715e">// 表示数组的最大容量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> front<span style="color:#f92672">;</span><span style="color:#75715e">// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> rear<span style="color:#f92672">;</span><span style="color:#75715e">// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">;</span><span style="color:#75715e">// 该数组用于存放数据，模拟队列
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 构造器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CircleArray</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maxSize</span> <span style="color:#f92672">=</span> maxSize<span style="color:#f92672">;</span>
        arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>maxSize<span style="color:#f92672">];</span>
        front <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        rear <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="2判断队列是否为满">2、判断队列是否为满</h3>
<p>我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针<strong>下一个位置</strong>是头指针的时候，表示队列满。（<em>在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满</em>）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 <strong>(rear + 1) % maxSize == front</strong> 。( <em>这里取模的目的就是为了整合rear和front大小为一个问题</em> )</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 判断队列是否为满
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isFull</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>rear <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxSize <span style="color:#f92672">==</span> front<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="3判断队列是否为空">3、判断队列是否为空</h3>
<p>因为front和rear的初始值相同，所以判断队列空的方法与之前一样。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 判断队列是否为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> rear <span style="color:#f92672">==</span> front<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="4求出当前队列的有效数据个数">4、求出当前队列的有效数据个数</h3>
<p>这个方法与之前相比是新添加的，其目的是为了判断遍历队列的长度。队列的有效数据的个数 = 尾队列 - 头队列，但有时front比rear大，有时front比rear小，所以可以通过取模的方式来实现。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 求出当前队列的有效数据的个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>rear <span style="color:#f92672">+</span> maxSize <span style="color:#f92672">-</span> front<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="5入队列">5、入队列</h3>
<p>添加数据入队的操作和之前相类似，只不过该队列front指向队列的第一个元素的位置，所以需要进行先赋值，然后再后移。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 添加数据入队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addQueue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isFull<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列已满，，无法添加任何数据~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        arr<span style="color:#f92672">[</span>rear<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span><span style="color:#75715e">// 直接将数据加入
</span><span style="color:#75715e"></span>        rear <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>rear <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">;</span><span style="color:#75715e">// 将rear后移，这里必须考虑取模
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="6出队列">6、出队列</h3>
<p><del>之前由于头指针指向队列的前一个位置，所以先后移，到达需要取出数据的位置，从而返回即可</del> 。但此时头指针所在的位置就是需要取出的位置，如果直接返回则无法进行后移，如果先后移，则取出的数据就是下一个位置的数据。我们可以做一下处理，从而达到想要的效果：</p>
<ol>
<li>先把front对应的值保留到一个临时变量；</li>
<li>将front后移，考虑取模</li>
<li>将临时保存的变量返回</li>
</ol>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 从队列中取出数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无任何数据可以取出~&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>front<span style="color:#f92672">];</span>
        front <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>front <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> val<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="7显示队列的所有数据">7、显示队列的所有数据</h3>
<p>在遍历的时候，我们需要注意到因为是环形队列，需要从front开始遍历，遍历到什么位置结束呢？？ 在之前我们已经求出了有效数据的个数，所以遍历元素为 <strong>front + size()</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 显示队列的所有数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">show</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无任何数据可以显示~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 遍历时，从front开始遍历，遍历元素为 front+有效数据的个数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> front<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> front <span style="color:#f92672">+</span> size<span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;arr[%d]=%d\n&#34;</span><span style="color:#f92672">,</span> i <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">,</span> arr<span style="color:#f92672">[</span>i <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="8显示队列的头数据">8、显示队列的头数据</h3>
<p>因为front指向的队列的一个元素的位置，所以直接返回即可。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 显示队列的头数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">headQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无头数据可显示~&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>front<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

</code></pre></div><hr>
<h2 id="三结束语">三、结束语</h2>
<p>到此，我们了解了关于数组模拟循环队列的相关操作，在判断队列是为满的时候，可以尝试画图理解，（记住要队列要空出一个位置，留作约定哦！）还有一个难点，求出有效数据个数。其余方法，根据数组模拟队列做出相应的调整即可（由于front和rear指向的位置不同而做出的改变）。</p>
<p>源码地址 ——&gt; <a href="https://github.com/QuakeWang/DataStructes">数据结构</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-05-27T13:49:32&#43;08:00">
            27 May 2020
        </time>
    </footer>
</article>

  
    
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/">数据结构--数组模拟队列</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="数组模拟队列">数组模拟队列</h1>
<hr>
<h2 id="一基本介绍">一、基本介绍</h2>
<h3 id="1队列介绍">1、队列介绍：</h3>
<ol>
<li>
<p>队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用<strong>数组</strong>或是<strong>链表</strong>来实现。</p>
</li>
<li>
<p>遵循<strong>先入先出</strong>的原则，允许插入的一端称为队尾，允许删除的一端称队头。</p>
</li>
</ol>
<h3 id="2举例说明">2、举例说明：</h3>
<p>队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是<strong>先入先出</strong>的原则。</p>
<h2 id="二算法实现">二、算法实现</h2>
<h3 id="1所需元素及其方法">1、所需元素及其方法</h3>
<p>在实现数组模拟队列的时候，我们需要先定义一个<strong>ArrayQueue</strong>类来存放所需的元素以及相关方法，所需元素有：数组<strong>arr[]</strong>：用于存放数据，模拟队列；数组的最大容量<strong>maxSize</strong>；队列头<strong>front</strong>；以及队列尾<strong>rear</strong>。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">;</span><span style="color:#75715e">// 表示数组的最大容量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> front<span style="color:#f92672">;</span><span style="color:#75715e">// 队列头
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> rear<span style="color:#f92672">;</span><span style="color:#75715e">// 队列尾
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">;</span><span style="color:#75715e">// 该数组用于存放数据，模拟队列
</span></code></pre></div><h3 id="2初始化相关变量">2、初始化相关变量</h3>
<p>在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量<strong>maxSize</strong>，这时数组可以存放maxSize的数据，但数组下标的范围为<strong>arr[0]&ndash;arr[maxSize - 1]</strong>。为front和rear赋值为-1，即队列的前一个位置。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 创建队列的构造器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ArrayQueue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maxSize</span> <span style="color:#f92672">=</span> maxSize<span style="color:#f92672">;</span>
        arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>maxSize<span style="color:#f92672">];</span>
        front <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span><span style="color:#75715e">// 指向队列头部，front是指向队列头的前一个位置
</span><span style="color:#75715e"></span>        rear <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span><span style="color:#75715e">// 指向队列的尾部，rear是队列最后一个数据
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="3判断队列是否为满">3、判断队列是否为满</h3>
<p>​		在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在<em>不断变大</em>。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即<strong>rear == arr[maxSize - 1]</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 判断队列是否为满
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isFull</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> rear <span style="color:#f92672">==</span> maxSize <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="4判断队列是否为空">4、判断队列是否为空</h3>
<p>​		在初始状态下，front和rear均指向下标为-1的<strong>同一个位置</strong>，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向<strong>同一个下标</strong>的时候，表示所有数据已经全部出队列。所以当<strong>rear == front</strong>时，队列空。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 判断队列是否为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> front <span style="color:#f92672">==</span> rear<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="5添加数据到队列">5、添加数据到队列</h3>
<p>在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（<em>注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置</em>）</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 添加数据到队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addQueue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 首先判断队列是否为满
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isFull<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列已满，无法添加任何数据~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        rear<span style="color:#f92672">++;</span><span style="color:#75715e">// 让rear后移
</span><span style="color:#75715e"></span>        arr<span style="color:#f92672">[</span>rear<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="6取出队列的数据">6、取出队列的数据</h3>
<p>在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 获取队列的数据，出队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 首先判断队列是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span><span style="color:#75715e">// 这里可以通过抛出异常处理
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无法取出任何数据&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        front<span style="color:#f92672">++;</span><span style="color:#75715e">// 让front后移
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>front<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="7显示队列所有数据">7、显示队列所有数据</h3>
<p>我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。注意在执行出队列的操作之后，front的值也随之后移，而且front指向的位置为队列的前一个位置，所以遍历的起始位置应该为<strong>front + 1</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 显示队列所有数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">showQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 先判断是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无数据可显示~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 遍历
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> front <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;arr[%d]=%d\n&#34;</span><span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="8显示队列头的信息">8、显示队列头的信息</h3>
<p>需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要<strong>front + 1</strong>。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 显示头队列的信息，注意不是取出数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">headQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 先判断是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;队列为空，无数据可显示&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>front <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="三结束语">三、结束语</h2>
<p>至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——&gt; <a href="https://github.com/QuakeWang/DataStructes">数据结构</a>。</p>
<blockquote>
<p>《大话数据结构》——程杰</p>
<p>图解数据结构与算法——韩顺平</p>
</blockquote>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-05-21T21:26:33&#43;08:00">
            21 May 2020
        </time>
    </footer>
</article>

  

    <nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 2</span>
	
	    <a class="older-posts" href="https://quakewang.github.io/page/2/">Older Posts &rarr;</a>
	
</nav>


</main>

    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">AKA二夕</a> All rights reserved - 2020</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://quakewang.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://quakewang.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://quakewang.github.io/js/index.js"></script>
    <script src="https://quakewang.github.io/js/particles.min.js"></script>
    <script src="https://quakewang.github.io/js/particles.js"></script>  

</body>
</html>

