<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><title type="text">AKA二夕</title><subtitle type="html">MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</subtitle><updated>2021-01-23T11:17:43+00:00</updated><id>https://quakewang.github.io/</id><link rel="alternate" type="text/html" href="https://quakewang.github.io/"/><link rel="self" type="application/atom+xml" href="https://quakewang.github.io/atom.xml"/><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><generator uri="https://gohugo.io/" version="0.69.1">Hugo</generator><entry><title type="text">数据结构——赫夫曼树</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/huffmantree/"/><id>https://quakewang.github.io/tech/huffmantree/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2021-01-19T17:36:47+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">赫夫曼树 一、前言 1、基本介绍 给定 n 个权值作为 n 个叶子结点，构造一颗二叉树，若该树的带……</summary><content type="html">&lt;h1 id="赫夫曼树">赫夫曼树&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1基本介绍">1、基本介绍&lt;/h3>
&lt;ul>
&lt;li>给定 n 个权值作为 n 个叶子结点，构造一颗二叉树，&lt;strong>若该树的带权路径（wpl）达到最小&lt;/strong> ，称这样的二叉树为最优二叉树，也称为赫夫曼树（Huffman Tree）；&lt;/li>
&lt;li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。&lt;/li>
&lt;/ul>
&lt;h3 id="2重要概念">2、重要概念&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>路径和路径长度：&lt;/strong> 在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径；通路中分支的数目称为路径的长度；若规定根结点的层数为1，则从根结点到第L层结点的路径长度为 L - 1；&lt;/li>
&lt;li>&lt;strong>结点的权以及带权路径的长度：&lt;/strong> 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权；结点的带权路径的长度为：从根结点到该结点之间的路径长度与该结点的权的乘积；&lt;/li>
&lt;li>&lt;strong>树的带权路径长度：&lt;/strong> 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL（weighted path length），权值越大的结点离根结点越近的二叉树才是最优二叉树；&lt;/li>
&lt;li>&lt;strong>WPL最小的就是赫夫曼树&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="二案例分析">二、案例分析&lt;/h2>
&lt;p>&lt;strong>要求：&lt;/strong> 给一个数列{13, 7, 8, 3, 29, 6, 1}，转成一颗赫夫曼树。&lt;/p>
&lt;h3 id="1思路分析">1、思路分析&lt;/h3>
&lt;p>1）从小到大进行排序，将每一个数据（每个数据就是一个结点），每个结点都可以看成是一颗最简单的二叉树；&lt;/p>
&lt;p>2）取出根结点权值最小的两颗二叉树；&lt;/p>
&lt;p>3）组成一颗新的二叉树，该新的二叉树的根结点的权值是前面两颗二叉树根结点权值的和；&lt;/p>
&lt;p>4）再将这颗新的二叉树，以根结点的权值大小，依次排序，不断重复 1-2-3-4步骤，直到所有数据都被处理，就得到一颗赫夫曼树。&lt;/p>
&lt;h3 id="2图解">2、图解&lt;/h3>
&lt;p>&lt;em>其中蓝色的结点表示数列中需要调整的结点，绿色表示新生成的结点&lt;/em>&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/Figure-bed/blob/master/DataStructures/HuffmanTree01.png?raw=true" alt="HuffmanTree">&lt;/p>
&lt;hr>
&lt;h2 id="三代码实现">三、代码实现&lt;/h2>
&lt;h3 id="1结点类node">1、结点类Node&lt;/h3>
&lt;h4 id="定义基础变量及说明">①定义基础变量及说明&lt;/h4>
&lt;p>该类用于定义结点属性，以及相关实现方法。由于需要对Node结点进行排序，这里引入 &lt;strong>Collections&lt;/strong> 集合排序，实现 &lt;strong>Comparable&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">// 创建类结点
&lt;/span>&lt;span class="c1">// 为了让Node对象持续排序 Collections 集合排序，实现 Comparable 接口
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Node&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Comparable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 结点权值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向左子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向右子结点
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 构造器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Node{&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;value=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="前序遍历方法">②前序遍历方法&lt;/h4>
&lt;p>这里我们使用前序遍历输出赫夫曼树。&lt;/p>
&lt;p>根据前序遍历的框架，首先输出当前结点，然后判断左子结点是否为空，如果不为空则递归输出；最后判断右子结点是否为空，如果不为空，递归输出即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 前序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preOrder&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">preOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">preOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="compareto函数">③compareTo函数&lt;/h4>
&lt;p>利用 &lt;strong>compareTo函数&lt;/strong> 对结点进行排序，按照从小到大进行排序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">compareTo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Node&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 表示从小到大排序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2huffmantree类主类">2、HuffmanTree类（主类）&lt;/h3>
&lt;h4 id="重载前序遍历方法">①重载前序遍历方法&lt;/h4>
&lt;p>重载&lt;strong>Node结点类&lt;/strong>的 &lt;strong>preOrder()方法&lt;/strong> ，加上判断条件，如果为空，则输出相关信息即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 编写一个前序遍历的方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Node&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">preOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;是空树，无法完成遍历~~~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="创建赫夫曼树方法">②创建赫夫曼树方法&lt;/h4>
&lt;p>该方法也是本次内容的重点了，接下来，我们细细分析。先说明：需要一个创建赫夫曼树的数组，创建好赫夫曼树之后，以root结点进行返回。&lt;/p>
&lt;p>拿到数组之后，我们需要做的第一件事就是，遍历arr数组，将arr的每个元素构成一个Node，最后将Node放入到ArrayList中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nodes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>经过上述处理之后，我们就得到了一个nodes，紧接着对此进行展开操作。前面提到，我们需要对数组进行从小到大的排序，所以&lt;code>Collections.sort(nodes);&lt;/code>&lt;/p>
&lt;p>&lt;strong>形成赫夫曼树的操作：&lt;/strong>&lt;/p>
&lt;p>1）取出权值最小的结点（二叉树），&lt;em>因为经过排序，所以下标为0的结点就是最小的；&lt;/em>&lt;/p>
&lt;p>2）取出权值第二小的结点（二叉树）；&lt;/p>
&lt;p>3）构建一棵新的二叉树，&lt;em>新二叉树的权值为左子结点和右子结点的权值之和&lt;/em>；&lt;/p>
&lt;p>4）从ArrayList删除处理过的二叉树，&lt;em>直接使用remove方法即可&lt;/em>；&lt;/p>
&lt;p>5）将parent结点加入到nodes中。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 创建哈夫曼树的方法
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param arr 需要创建哈夫曼树的数组
&lt;/span>&lt;span class="cm"> * @return 创建好后的哈夫曼树的root结点
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="nf">createHuffmanTree&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 1、遍历arr数组；
&lt;/span>&lt;span class="cm"> * 2、将arr的每个元素构成一个Node
&lt;/span>&lt;span class="cm"> * 3、将Node放入到ArrayList中
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nodes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 进行循环处理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 排序 从小到大
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Collections&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;nodes = &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 取出根结点权值最小的两棵二叉树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 1、取出权值最小的结点（二叉树）
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">leftNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 2、取出权值第二小的结点（二叉树）
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">rightNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 3、构建一颗新的二叉树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">leftNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">rightNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">leftNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rightNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 4、从ArrayList删除处理过的二叉树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">leftNode&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">rightNode&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 5、将parent结点加入到nodes中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 返回哈夫曼树的root结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="四结束语">四、结束语&lt;/h2>
&lt;p>经过以上的操作，我们就完成了一棵赫夫曼树，根据赫夫曼的特点，有一种编码叫做赫夫曼编码，这个因为牵涉到的代码量较大，我们就有时间再说。&lt;/p>
&lt;p>此外，对于赫夫曼树的测试主方法，并没有说明，小朋友们可以自行完善。&lt;/p>
&lt;p>源码地址 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/huffmantree/HuffmanTree.java">HuffmanTree&lt;/a>&lt;/p></content></entry><entry><title type="text">TypeScript学习笔记02</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/typescript02/"/><id>https://quakewang.github.io/tech/typescript02/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-12-22T00:00:00+00:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">第二章：面向对象 面向对象是学习编程过程中一个非常重要的思想，但是它却被很多人理解成了……</summary><content type="html">&lt;h1 id="第二章面向对象">第二章：面向对象&lt;/h1>
&lt;p>面向对象是学习编程过程中一个非常重要的思想，但是它却被很多人理解成了一个比较难，比较深奥的问题，其实不然。其实面向对象在理解之后还是很简单的，简而言之就是程序之中所有的操作都需要通过对象来完成。&lt;/p>
&lt;ul>
&lt;li>举例来说：
&lt;ul>
&lt;li>操作浏览器要使用window对象&lt;/li>
&lt;li>操作网页要使用document对象&lt;/li>
&lt;li>操作控制台要使用console对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。&lt;/p>
&lt;p>在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。&lt;/p>
&lt;h2 id="1类class">1、类（class）&lt;/h2>
&lt;p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义类：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="err">类名&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">属性名&lt;/span>: &lt;span class="kt">类型&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">参数&lt;/span>: &lt;span class="kt">类型&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">属性名&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">参数&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="err">方法名&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="p">....&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">sayHello&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`大家好，我是&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>使用类：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;孙悟空&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">18&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sayHello&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2面向对象的特点">2、面向对象的特点&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>封装&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装&lt;/p>
&lt;/li>
&lt;li>
&lt;p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只读属性（readonly）：&lt;/p>
&lt;ul>
&lt;li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>TS中属性具有三种修饰符：&lt;/p>
&lt;ul>
&lt;li>public（默认值），可以在类、子类和对象中修改&lt;/li>
&lt;li>protected ，可以在类、子类中修改&lt;/li>
&lt;li>private ，可以在类中修改&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>public&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">public&lt;/span> &lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 写或什么都不写都是public
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kr">public&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 可以在类中修改
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">sayHello&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`大家好，我是&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">class&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="kr">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//子类中可以修改
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;孙悟空&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">18&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;猪八戒&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">// 可以通过对象修改
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>protected&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">protected&lt;/span> &lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">protected&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 可以修改
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">sayHello&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`大家好，我是&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">class&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="kr">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//子类中可以修改
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;孙悟空&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">18&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;猪八戒&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">// 不能修改
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>private&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">private&lt;/span> &lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">private&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 可以修改
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">sayHello&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`大家好，我是&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">class&lt;/span> &lt;span class="nx">Employee&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="kr">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//子类中不能修改
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;孙悟空&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">18&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;猪八戒&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">// 不能修改
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>属性存取器&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于一些不希望被任意修改的属性，可以将其设置为private&lt;/p>
&lt;/li>
&lt;li>
&lt;p>直接将其设置为private将导致无法再通过对象修改其中的属性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">private&lt;/span> &lt;span class="nx">_name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">get&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">_name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">set&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">p1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;孙悟空&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 通过getter读取name属性
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">p1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;猪八戒&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 通过setter修改name属性
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>静态属性&lt;/p>
&lt;ul>
&lt;li>
&lt;p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>静态属性（方法）使用static开头&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Tools&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">static&lt;/span> &lt;span class="nx">PI&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">3.1415926&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">static&lt;/span> &lt;span class="nx">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">num1&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">num2&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">num1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">num2&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Tools&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PI&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Tools&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">123&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">456&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>this&lt;/p>
&lt;ul>
&lt;li>在类中，使用this表示当前对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>继承&lt;/p>
&lt;ul>
&lt;li>
&lt;p>继承时面向对象中的又一个特性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过继承可以将其他类中的属性和方法引入到当前类中&lt;/p>
&lt;ul>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Animal&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">class&lt;/span> &lt;span class="nx">Dog&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">Animal&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">bark&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">在汪汪叫！`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">dog&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Dog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;旺财&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">dog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">bark&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>通过继承可以在不修改类的情况下完成对类的扩展&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重写&lt;/p>
&lt;ul>
&lt;li>
&lt;p>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Animal&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">age&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">run&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`父类中的run方法！`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">class&lt;/span> &lt;span class="nx">Dog&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">Animal&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">bark&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">在汪汪叫！`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">run&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`子类中的run方法，会重写父类中的run方法！`&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">dog&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Dog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;旺财&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">dog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">bark&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在子类中可以使用super来完成对父类的引用&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>抽象类（abstract class）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例&lt;/p>
&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">abstract&lt;/span> &lt;span class="kr">class&lt;/span> &lt;span class="nx">Animal&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">abstract&lt;/span> &lt;span class="nx">run&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">void&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">bark&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;动物在叫~&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">class&lt;/span> &lt;span class="nx">Dog&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">Animals&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">run&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;狗在跑~&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3接口interface">3、接口（Interface）&lt;/h2>
&lt;p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>示例（检查对象类型）：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">interface&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">sayHello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="k">void&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">function&lt;/span> &lt;span class="nx">fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">per&lt;/span>: &lt;span class="kt">Person&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="nx">per&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sayHello&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fn&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="s1">&amp;#39;孙悟空&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">sayHello() {console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`Hello, 我是 &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">)}});&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>示例（实现）&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">interface&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">sayHello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="k">void&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kr">class&lt;/span> &lt;span class="nx">Student&lt;/span> &lt;span class="kr">implements&lt;/span> &lt;span class="nx">Person&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kr">public&lt;/span> &lt;span class="nx">name&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">sayHello() {&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;大家好，我是&amp;#39;&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4泛型generic">4、泛型（Generic）&lt;/h2>
&lt;p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>举个例子：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">arg&lt;/span>: &lt;span class="kt">any&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">any&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">arg&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用泛型：&lt;/p>
&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">test&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">arg&lt;/span>: &lt;span class="kt">T&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">T&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">arg&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>这里的&lt;code>&amp;lt;T&amp;gt;&lt;/code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>那么如何使用上边的函数呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>方式一（直接使用）：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="nx">test&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>方式二（指定类型）：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="nx">test&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">number&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>也可以在函数后手动指定泛型&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>可以同时指定多个泛型，泛型间使用逗号隔开：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">test&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">T&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">K&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span>: &lt;span class="kt">T&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>: &lt;span class="kt">K&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">K&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">test&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用泛型时，完全可以将泛型当成是一个普通的类去使用&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>类中同样可以使用泛型：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">class&lt;/span> &lt;span class="nx">MyClass&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">prop&lt;/span>: &lt;span class="kt">T&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">constructor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">prop&lt;/span>: &lt;span class="kt">T&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">prop&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">prop&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>除此之外，也可以对泛型的范围进行约束&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">interface&lt;/span> &lt;span class="nx">MyInter&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">length&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">function&lt;/span> &lt;span class="nx">test&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">T&lt;/span> &lt;span class="kr">extends&lt;/span> &lt;span class="nx">MyInter&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">arg&lt;/span>: &lt;span class="kt">T&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kt">number&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">arg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content></entry><entry><title type="text">Typescript 学习笔记01</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/typescript01/"/><id>https://quakewang.github.io/tech/typescript01/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-12-17T19:18:52+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">第一章 快速入门 0、TypeScript简介 TypeScript是JavaScript……</summary><content type="html">&lt;h1 id="第一章-快速入门">第一章 快速入门&lt;/h1>
&lt;h2 id="0typescript简介">0、TypeScript简介&lt;/h2>
&lt;ol>
&lt;li>TypeScript是JavaScript的超集。&lt;/li>
&lt;li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。&lt;/li>
&lt;li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。&lt;/li>
&lt;li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。&lt;/li>
&lt;li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。&lt;/li>
&lt;/ol>
&lt;h2 id="1typescript-开发环境搭建">1、TypeScript 开发环境搭建&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>下载Node.js&lt;/p>
&lt;ul>
&lt;li>64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi&lt;/li>
&lt;li>32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>安装Node.js&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用npm全局安装typescript&lt;/p>
&lt;ul>
&lt;li>进入命令行&lt;/li>
&lt;li>输入：npm i -g typescript&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>创建一个ts文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用tsc对ts文件进行编译&lt;/p>
&lt;ul>
&lt;li>
&lt;p>进入命令行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进入ts文件所在目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行命令：tsc xxx.ts&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="2基本类型">2、基本类型&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>类型声明&lt;/p>
&lt;ul>
&lt;li>
&lt;p>类型声明是TS非常重要的一个特点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过类型声明可以指定TS中变量（参数、形参）的类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错&lt;/p>
&lt;/li>
&lt;li>
&lt;p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>语法：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">变量&lt;/span>: &lt;span class="kt">类型&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">变量&lt;/span>: &lt;span class="kt">类型&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">值&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">function&lt;/span> &lt;span class="nx">fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">参数&lt;/span>: &lt;span class="kt">类型&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">参数&lt;/span>: &lt;span class="kt">类型&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="err">类型&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>自动类型判断&lt;/p>
&lt;ul>
&lt;li>TS拥有自动的类型判断机制&lt;/li>
&lt;li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型&lt;/li>
&lt;li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>类型：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="center">类型&lt;/th>
&lt;th align="center">例子&lt;/th>
&lt;th align="center">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="center">number&lt;/td>
&lt;td align="center">1, -33, 2.5&lt;/td>
&lt;td align="center">任意数字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">string&lt;/td>
&lt;td align="center">'hi', &amp;quot;hi&amp;quot;, &lt;code>hi&lt;/code>&lt;/td>
&lt;td align="center">任意字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">boolean&lt;/td>
&lt;td align="center">true、false&lt;/td>
&lt;td align="center">布尔值true或false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">字面量&lt;/td>
&lt;td align="center">其本身&lt;/td>
&lt;td align="center">限制变量的值就是该字面量的值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">any&lt;/td>
&lt;td align="center">*&lt;/td>
&lt;td align="center">任意类型&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">unknown&lt;/td>
&lt;td align="center">*&lt;/td>
&lt;td align="center">类型安全的any&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">void&lt;/td>
&lt;td align="center">空值（undefined）&lt;/td>
&lt;td align="center">没有值（或undefined）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">never&lt;/td>
&lt;td align="center">没有值&lt;/td>
&lt;td align="center">不能是任何值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">object&lt;/td>
&lt;td align="center">{name:'孙悟空'}&lt;/td>
&lt;td align="center">任意的JS对象&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">array&lt;/td>
&lt;td align="center">[1,2,3]&lt;/td>
&lt;td align="center">任意JS数组&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">tuple&lt;/td>
&lt;td align="center">[4,5]&lt;/td>
&lt;td align="center">元素，TS新增类型，固定长度数组&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">enum&lt;/td>
&lt;td align="center">enum{A, B}&lt;/td>
&lt;td align="center">枚举，TS中新增类型&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>number&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">decimal&lt;/span>: &lt;span class="kt">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">hex&lt;/span>: &lt;span class="kt">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mh">0xf00d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">binary&lt;/span>: &lt;span class="kt">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="nx">b1010&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">octal&lt;/span>: &lt;span class="kt">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="nx">o744&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">big&lt;/span>: &lt;span class="kt">bigint&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>boolean&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">isDone&lt;/span>: &lt;span class="kt">boolean&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>string&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">color&lt;/span>: &lt;span class="kt">string&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;blue&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;red&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">fullName&lt;/span>: &lt;span class="kt">string&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sb">`Bob Bobbington`&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">age&lt;/span>: &lt;span class="kt">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">37&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">sentence&lt;/span>: &lt;span class="kt">string&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sb">`Hello, my name is &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">fullName&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">.
&lt;/span>&lt;span class="sb">
&lt;/span>&lt;span class="sb"> I&amp;#39;ll be &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">age&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb"> years old next month.`&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>字面量&lt;/p>
&lt;ul>
&lt;li>
&lt;p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围&lt;/p>
&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">color&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;red&amp;#39;&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="s1">&amp;#39;blue&amp;#39;&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="s1">&amp;#39;black&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">num&lt;/span>: &lt;span class="kt">1&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>any&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">d&lt;/span>: &lt;span class="kt">any&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;hello&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>unknown&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">notSure&lt;/span>: &lt;span class="kt">unknown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">notSure&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;hello&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>void&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">unusable&lt;/span>: &lt;span class="kt">void&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">undefined&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>never&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">function&lt;/span> &lt;span class="nx">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">message&lt;/span>: &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">never&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">message&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>object（没啥用）&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">obj&lt;/span>: &lt;span class="kt">object&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{};&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>array&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">list&lt;/span>: &lt;span class="kt">number&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">list&lt;/span>: &lt;span class="kt">Array&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">number&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>tuple&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">number&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="nx">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>enum&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kr">enum&lt;/span> &lt;span class="nx">Color&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Red&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Green&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Blue&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">c&lt;/span>: &lt;span class="kt">Color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">Color&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Green&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">enum&lt;/span> &lt;span class="nx">Color&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Red&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Green&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Blue&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">c&lt;/span>: &lt;span class="kt">Color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">Color&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Green&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">enum&lt;/span> &lt;span class="nx">Color&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Red&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Green&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Blue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">c&lt;/span>: &lt;span class="kt">Color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">Color&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Green&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>类型断言&lt;/p>
&lt;ul>
&lt;li>
&lt;p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一种&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">someValue&lt;/span>: &lt;span class="kt">unknown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;this is a string&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">strLength&lt;/span>: &lt;span class="kt">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">someValue&lt;/span> &lt;span class="kr">as&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>第二种&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="kd">let&lt;/span> &lt;span class="nx">someValue&lt;/span>: &lt;span class="kt">unknown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;this is a string&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">strLength&lt;/span>: &lt;span class="kt">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="nx">someValue&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3编译选项">3、编译选项&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>自动编译文件&lt;/p>
&lt;ul>
&lt;li>
&lt;p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-powershell" data-lang="powershell"> &lt;span class="n">tsc&lt;/span> &lt;span class="n">xxx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ts&lt;/span> &lt;span class="n">-w&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>自动编译整个项目&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置选项：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>include&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义希望被编译文件所在的目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>默认值：[&amp;quot;**/*&amp;quot;]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;include&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;src/**/*&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;tests/**/*&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>上述示例中，所有src目录和tests目录下的文件都会被编译&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>exclude&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义需要排除在外的目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>默认值：[&amp;quot;node_modules&amp;quot;, &amp;quot;bower_components&amp;quot;, &amp;quot;jspm_packages&amp;quot;]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;exclude&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;./src/hello/**/*&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>上述示例中，src下hello目录下的文件都不会被编译&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>extends&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义被继承的配置文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;extends&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="s2">&amp;#34;./configs/base&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>files&lt;/p>
&lt;ul>
&lt;li>
&lt;p>指定被编译文件的列表，只有需要编译的文件少时才会用到&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;files&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;core.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;sys.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;types.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;scanner.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;parser.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;utilities.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;binder.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;checker.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;tsc.ts&amp;#34;&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>列表中的文件都会被TS编译器所编译&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>compilerOptions&lt;/p>
&lt;ul>
&lt;li>
&lt;p>编译选项是配置文件中非常重要也比较复杂的配置选项&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在compilerOptions中包含多个子选项，用来完成对编译的配置&lt;/p>
&lt;ul>
&lt;li>
&lt;p>项目选项&lt;/p>
&lt;ul>
&lt;li>
&lt;p>target&lt;/p>
&lt;ul>
&lt;li>
&lt;p>设置ts代码编译的目标版本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可选值：&lt;/p>
&lt;ul>
&lt;li>ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;target&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;ES6&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>lib&lt;/p>
&lt;ul>
&lt;li>
&lt;p>指定代码运行时所包含的库（宿主环境）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可选值：&lt;/p>
&lt;ul>
&lt;li>ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;target&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;ES6&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;lib&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;ES6&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;DOM&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;outDir&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;dist&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;outFile&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;dist/aa.js&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>module&lt;/p>
&lt;ul>
&lt;li>
&lt;p>设置编译后代码使用的模块化系统&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可选值：&lt;/p>
&lt;ul>
&lt;li>CommonJS、UMD、AMD、System、ES2020、ESNext、None&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-typescript" data-lang="typescript"> &lt;span class="s2">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="s2">&amp;#34;module&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;CommonJS&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>outDir&lt;/p>
&lt;ul>
&lt;li>
&lt;p>编译后文件的所在目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;outDir&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;dist&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>设置后编译后的js文件将会生成到dist目录&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>outFile&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将所有的文件编译为一个js文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;outFile&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;dist/app.js&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>rootDir&lt;/p>
&lt;ul>
&lt;li>
&lt;p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;rootDir&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;./src&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>allowJs&lt;/p>
&lt;ul>
&lt;li>是否对js文件编译&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>checkJs&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是否对js文件进行检查&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例：&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="s2">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;allowJs&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;checkJs&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>removeComments&lt;/p>
&lt;ul>
&lt;li>是否删除注释&lt;/li>
&lt;li>默认值：false&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>noEmit&lt;/p>
&lt;ul>
&lt;li>不对代码进行编译&lt;/li>
&lt;li>默认值：false&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>sourceMap&lt;/p>
&lt;ul>
&lt;li>是否生成sourceMap&lt;/li>
&lt;li>默认值：false&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>严格检查&lt;/p>
&lt;ul>
&lt;li>strict
&lt;ul>
&lt;li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>alwaysStrict
&lt;ul>
&lt;li>总是以严格模式对代码进行编译&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>noImplicitAny
&lt;ul>
&lt;li>禁止隐式的any类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>noImplicitThis
&lt;ul>
&lt;li>禁止类型不明确的this&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>strictBindCallApply
&lt;ul>
&lt;li>严格检查bind、call和apply的参数列表&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>strictFunctionTypes
&lt;ul>
&lt;li>严格检查函数的类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>strictNullChecks
&lt;ul>
&lt;li>严格的空值检查&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>strictPropertyInitialization
&lt;ul>
&lt;li>严格检查属性是否初始化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>额外检查&lt;/p>
&lt;ul>
&lt;li>noFallthroughCasesInSwitch
&lt;ul>
&lt;li>检查switch语句包含正确的break&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>noImplicitReturns
&lt;ul>
&lt;li>检查函数没有隐式的返回值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>noUnusedLocals
&lt;ul>
&lt;li>检查未使用的局部变量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>noUnusedParameters
&lt;ul>
&lt;li>检查未使用的参数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>高级&lt;/p>
&lt;ul>
&lt;li>allowUnreachableCode
&lt;ul>
&lt;li>检查不可达代码&lt;/li>
&lt;li>可选值：
&lt;ul>
&lt;li>true，忽略不可达代码&lt;/li>
&lt;li>false，不可达代码将引起错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>noEmitOnError
&lt;ul>
&lt;li>有错误的情况下不进行编译&lt;/li>
&lt;li>默认值：false&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4webpack">4、webpack&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>初始化项目&lt;/p>
&lt;ul>
&lt;li>进入项目根目录，执行命令 &lt;code> npm init -y&lt;/code>
&lt;ul>
&lt;li>主要作用：创建package.json文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>下载构建工具&lt;/p>
&lt;ul>
&lt;li>&lt;code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin&lt;/code>
&lt;ul>
&lt;li>共安装了7个包
&lt;ul>
&lt;li>webpack
&lt;ul>
&lt;li>构建工具webpack&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>webpack-cli
&lt;ul>
&lt;li>webpack的命令行工具&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>webpack-dev-server
&lt;ul>
&lt;li>webpack的开发服务器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>typescript
&lt;ul>
&lt;li>ts编译器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ts-loader
&lt;ul>
&lt;li>ts加载器，用于在webpack中编译ts文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>html-webpack-plugin
&lt;ul>
&lt;li>webpack中html插件，用来自动创建html文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>clean-webpack-plugin
&lt;ul>
&lt;li>webpack中的清除插件，每次构建都会先清除目录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>根目录下创建webpack的配置文件webpack.config.js&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript"> &lt;span class="kr">const&lt;/span> &lt;span class="nx">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;path&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">HtmlWebpackPlugin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;html-webpack-plugin&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">CleanWebpackPlugin&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;clean-webpack-plugin&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">module&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exports&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">optimization&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">minimize&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kc">false&lt;/span> &lt;span class="c1">// 关闭代码压缩，可选
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">},&lt;/span>
&lt;span class="nx">entry&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;./src/index.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">devtool&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;inline-source-map&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">devServer&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">contentBase&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;./dist&amp;#39;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">output&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">path&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">path&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">resolve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">__dirname&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;dist&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="nx">filename&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;bundle.js&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">environment&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">arrowFunction&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kc">false&lt;/span> &lt;span class="c1">// 关闭webpack的箭头函数，可选
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">resolve&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">extensions&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;.ts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;.js&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">module&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">rules&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nx">test&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="sr">/\.ts$/&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">use&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">loader&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;ts-loader&amp;#34;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">exclude&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="sr">/node_modules/&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nx">plugins&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="nx">CleanWebpackPlugin&lt;/span>&lt;span class="p">(),&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="nx">HtmlWebpackPlugin&lt;/span>&lt;span class="p">({&lt;/span>
&lt;span class="nx">title&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="s1">&amp;#39;TS测试&amp;#39;&lt;/span>
&lt;span class="p">}),&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>根目录下创建tsconfig.json，配置可以根据自己需要&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;compilerOptions&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;target&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;ES2015&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;module&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;ES2015&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;strict&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>修改package.json添加如下配置&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="p">{&lt;/span>
&lt;span class="err">...略...&lt;/span>
&lt;span class="nt">&amp;#34;scripts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;test&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;build&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;webpack&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;start&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;webpack serve --open chrome.exe&amp;#34;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="err">...略...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>在src下创建ts文件，并在并命令行执行&lt;code>npm run build&lt;/code>对代码进行编译，或者执行&lt;code>npm start&lt;/code>来启动开发服务器&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="5babel">5、Babel&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>安装依赖包：&lt;/p>
&lt;ul>
&lt;li>&lt;code>npm i -D @babel/core @babel/preset-env babel-loader core-js&lt;/code>&lt;/li>
&lt;li>共安装了4个包，分别是：
&lt;ul>
&lt;li>@babel/core
&lt;ul>
&lt;li>babel的核心工具&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>@babel/preset-env
&lt;ul>
&lt;li>babel的预定义环境&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>@babel-loader
&lt;ul>
&lt;li>babel在webpack中的加载器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>core-js
&lt;ul>
&lt;li>core-js用来使老版本的浏览器支持新版ES语法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>修改webpack.config.js配置文件&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript"> &lt;span class="p">...&lt;/span>&lt;span class="nx">略&lt;/span>&lt;span class="p">...&lt;/span>
&lt;span class="nx">module&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">rules&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nx">test&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="sr">/\.ts$/&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">use&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nx">loader&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;babel-loader&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">options&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">presets&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;@babel/preset-env&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="s2">&amp;#34;targets&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="s2">&amp;#34;chrome&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;58&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;ie&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;11&amp;#34;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="s2">&amp;#34;corejs&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;useBuiltIns&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;usage&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nx">loader&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;ts-loader&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nx">exclude&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="sr">/node_modules/&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">...&lt;/span>&lt;span class="nx">略&lt;/span>&lt;span class="p">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul></content></entry><entry><title type="text">AVLTree</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/avltree/"/><id>https://quakewang.github.io/tech/avltree/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-12-06T23:03:53+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">二叉平衡树 一、前言 1、案例分析 现在有一个数列 {1, 2, 3, 4, 5, 6}，要求创建一颗二叉排序树，……</summary><content type="html">&lt;h1 id="二叉平衡树">二叉平衡树&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1案例分析">1、案例分析&lt;/h3>
&lt;p>现在有一个数列 &lt;code>{1, 2, 3, 4, 5, 6}&lt;/code>，要求创建一颗二叉排序树，并分析问题所在。&lt;/p>
&lt;p>&lt;strong>左边BST存在的问题分析：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>左子树全部为空，从形式上看，更像是一个单链表；&lt;/li>
&lt;li>插入速度没影响；&lt;/li>
&lt;li>查询速度明显降低（因为需要依次比较），不能发挥BST的优势，因为每次还需要比较左子树，导致其查询速度比单链表还慢。&lt;/li>
&lt;/ul>
&lt;p>如下图：&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/Figure-bed/blob/master/DataStructures/AVLTree01.png?raw=true" alt="AVLTree01">&lt;/p>
&lt;p>所以根据以上出现的问题，也就有了我们今天的主角：&lt;strong>平衡二叉树&lt;/strong>。&lt;/p>
&lt;h3 id="2基本介绍">2、基本介绍&lt;/h3>
&lt;p>平衡二叉树，也叫平衡二叉搜索树，又被称为 &lt;strong>AVL树&lt;/strong>，可以保证有较高的查询效率。同时具有以下特点：它是&lt;strong>一棵空树&lt;/strong> 或 &lt;strong>它的左右两个子树的高度差的绝对值不超过1&lt;/strong>，并且 &lt;strong>左右两个子树都是一棵平衡二叉树&lt;/strong>。&lt;/p>
&lt;p>平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。&lt;/p>
&lt;p>下面我们将结合具体的实例，来一探平衡二叉树的究竟！！！&lt;/p>
&lt;h2 id="二案例分析">二、案例分析&lt;/h2>
&lt;h3 id="1应用案例左旋转">1、应用案例——左旋转&lt;/h3>
&lt;p>1）要求：给你一个数列，创建出对应的平衡二叉树，数列{4, 3, 6, 5, 7, 8}&lt;/p>
&lt;p>2）思路分析：&lt;/p>
&lt;p>问题：当插入 8 时， &lt;code>rightHeight() - leftHeigth() &amp;gt; 1 &lt;/code> 成立，此时，不再是一颗AVL树了，因此我们需要怎么处理才能达到想要的效果呢？ ——&amp;gt; &lt;strong>左旋转&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>创建一个新的结点 &lt;code>newNode&lt;/code> （&lt;em>以4这个值创建&lt;/em>），值等于当前根结点的值；&lt;/li>
&lt;li>把新结点的左子树设置成当前结点的左子树，&lt;code>newNode.left = left;&lt;/code>&lt;/li>
&lt;li>把新结点的右子树设置为当前结点的右子树的左子树，&lt;code>newNode.right = right.left;&lt;/code>&lt;/li>
&lt;li>把当前结点的值换为右子结点的值，&lt;code>value = right.value;&lt;/code>&lt;/li>
&lt;li>把当前结点的右子树设置成右子树的右子树，&lt;code>right = right.right;&lt;/code>&lt;/li>
&lt;li>把当前结点的左子树设置为新结点，&lt;code>left = newNode;&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>好了，完成了以上的操作，这时就已经成为了一颗AVL树，但是相信很多小伙伴读到这里，肯定很迷，不急不急请看下图：&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/Figure-bed/blob/master/DataStructures/LeftRotate.png?raw=true" alt="LeftROtate">&lt;/p>
&lt;h3 id="2应用案例右旋转">2、应用案例——右旋转&lt;/h3>
&lt;p>相信结合左旋转的代码和图片，大家已经可以完成了该操作。接下来我们来看看右旋转，其实说白了就是把左旋转 &amp;quot;反过来&amp;quot; 。&lt;/p>
&lt;p>1）要求：给你一个数列，创建出对应的平衡二叉树，数列{10, 12, 8, 9, 7, 6}&lt;/p>
&lt;p>2）思路分析：&lt;/p>
&lt;p>问题：当插入 6 时， &lt;code>leftHeight() - rightHeigth() &amp;gt; 1 &lt;/code> 成立，此时，不再是一颗AVL树了，因此我们需要怎么处理才能达到想要的效果呢？ ——&amp;gt; &lt;strong>右旋转&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>创建一个新的结点 &lt;code>newNode&lt;/code> （&lt;em>以4这个值创建&lt;/em>），值等于当前根结点的值；&lt;/li>
&lt;li>把新结点的右子树设置成当前结点的右子树，&lt;code>newNode.right = right;&lt;/code>&lt;/li>
&lt;li>把新结点的左子树设置为当前结点的左子树的右子树，&lt;code>newNode.left = left.right;&lt;/code>&lt;/li>
&lt;li>把当前结点的值换为左子结点的值，&lt;code>value = left.value;&lt;/code>&lt;/li>
&lt;li>把当前结点的左子树设置成左子树的左子树，&lt;code>left = left.left;&lt;/code>&lt;/li>
&lt;li>把当前结点的右子树设置为新结点，&lt;code>right = newNode;&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://github.com/QuakeWang/Figure-bed/blob/master/DataStructures/RightRotate.png?raw=true" alt="RightRotate">&lt;/p>
&lt;h3 id="3应用案例双旋转">3、应用案例——双旋转&lt;/h3>
&lt;p>你以为到这就结束了，想的太简单点了吧，还有一种情况就是只使用一次左旋转或者右旋转是达不到效果的，那就得进行双旋转咯。比如数列：&lt;code>int[] arr = {10, 11, 7, 6, 8, 9};&lt;/code> 运行原来的代码可以看见，并没有转成AVL树。这时我们就需要对问题进行剖析了：&lt;/p>
&lt;p>&lt;strong>解决思路：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当符合右旋转的条件时&lt;/li>
&lt;li>如果它的左子树的右子树高度大于它的左子树的高度&lt;/li>
&lt;li>先对当前这个结点的左结点进行左旋转&lt;/li>
&lt;li>再对当前结点进行右旋转的操作即可。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://github.com/QuakeWang/Figure-bed/blob/master/DataStructures/AVLTree.png?raw=true" alt="AVL">&lt;/p>
&lt;hr>
&lt;h2 id="三代码实现">三、代码实现&lt;/h2>
&lt;h3 id="1返回以该结点为根结点树的高度">1、返回以该结点为根结点树的高度&lt;/h3>
&lt;p>在比较两个结点的左右子树的差值的时候，我们首先需要获取当前根结点的高度。&lt;/p>
&lt;p>使用Java内置的Math类库的max方法，从而返回较大的数值。这里我们对于左子树进行说明，（&lt;em>右子树也是同理&lt;/em>），&lt;code>left == null ? 0 : left.height()&lt;/code> 使用三目运算符，先判断left是否为空，如果为空，直接返回null，否则递归的遍历左子树。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 返回以该结点为根结点树的高度
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">height&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2返回左子树的高度">2、返回左子树的高度&lt;/h3>
&lt;p>先判断左子树是否为空 &lt;code>if(left == null)&lt;/code>，如果为空直接返回为0，否则调用&lt;code>height()&lt;/code> 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 返回左子树的高度
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">leftHeight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3返回右子树的高度">3、返回右子树的高度&lt;/h3>
&lt;p>和左子树同理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 返回右子树的高度
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">rightHeight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">height&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4左右旋转方法">4、左右旋转方法&lt;/h3>
&lt;p>在案例分析中，已经阐述了该方法的原理，这里就不做过多的赘述，直接上代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 左旋转方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">leftRotate&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 创建新的结点，以当前根结点的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">newNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 把新的结点的左子树设置成当前结点的左子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">newNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 把新的结点的右子树设置成当前结点的右子树的左子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">newNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 把当前结点的值替换成右子结点的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 把当前面结点的右子树设置成当前结点右子树的右子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 把当前结点的左子树（左子结点）设置成新的结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 右旋转方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">rightRotate&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 创建新的结点，以当前根结点的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">newNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 把新的结点的右子树设置成当前结点的右子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">newNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 把新的结点的左子树设置成当前结点的左子树的右子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">newNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 把当前结点的值替换成左子结点的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 把当前结点的左子树设置成当前结点的左子树的左子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 把当前结点的右子树（右子结点）设置成新结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="5添加结点">5、添加结点&lt;/h3>
&lt;p>我们关于旋转方法的使用，是在添加结点的方法中实现。添加结点方法是基于&lt;a href="https://quakewang.github.io/tech/bst/">二叉排序树&lt;/a>的基础上完善的，如果还不了解的小伙伴可以去看上一篇博客。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 添加结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Node&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 判断传入结点的值和当前子树根结点值的关系
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果当前结点的左子结点为null
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 递归的向左子树添加
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 传入结点的值大于当前结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 递归的向右子树添加
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 当添加一个结点后，如果：（右子树的高度 - 左子树的高度）&amp;gt; 1，左旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">rightHeight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">leftHeight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果它的右子树的左子树的高度大于它右子树的右子树高度
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">leftHeight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rightHeight&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先对右子树进行旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rightRotate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">// 然后再对当前结点进行左旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">leftRotate&lt;/span>&lt;span class="o">();&lt;/span>&lt;span class="c1">// 左旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 直接进行左旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">leftRotate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 必须要！！！
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">// 当添加完一个结点后，如果（左子树的高度 - 右子树的高度）&amp;gt; 1，右旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">leftHeight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">rightHeight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果它的左子树的右子树的高度大于它的左子树的左子树的高度
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rightHeight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">leftHeight&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先对左子结点进行右旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">leftRotate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">// 然后再对当前结点进行右旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">rightRotate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 直接进行右旋转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">rightRotate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="四结束语">四、结束语&lt;/h2>
&lt;p>到此，关于AVL树的相关操作我们已经完成，但对于遍历、输出等函数这里并没有进行相关说明，因为这些方法在前面已经说过很多类似的了，所以就把内容更侧重于关于具体问题算法的实现。&lt;/p>
&lt;p>&lt;em>说实话，有的时候不push自己，可能永远不会继续写下去&lt;/em>&lt;/p>
&lt;p>源码地址 ——&amp;gt;&lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/avl/AVLTreeDemo.java">AVLTree&lt;/a>&lt;/p></content></entry><entry><title type="text">二叉排序树</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/bst/"/><id>https://quakewang.github.io/tech/bst/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-11-22T20:18:41+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">二叉排序树 一、前言 1、引子 假设现在有一个数组{7, 3, 10, 12, 5, 1, 9} ，现在要求能够高效的完……</summary><content type="html">&lt;h1 id="二叉排序树">二叉排序树&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1引子">1、引子&lt;/h3>
&lt;p>假设现在有一个数组&lt;code>{7, 3, 10, 12, 5, 1, 9}&lt;/code> ，现在要求能够高效的完成对数据的添加、删除以及查询操作。&lt;/p>
&lt;p>根据我们之前所学过得内容，假设查找的数据集是普通的顺序存储，那么插入操作就是将记录放在表的末端，给表记录数加一即可，删除操作可以是删除后，后面的记录向前移，也可以是要删除的元素与最后一个元素互换，表记录数减一，反正整个数据集也没有固定的顺序，进行这样的操作的话，效率也还说得过去。准确来说，应该是，插入和删除对于顺序存储结构来说，效率还是可以接受的，但这样的表由于无序会造成查找的效率很低。&lt;/p>
&lt;p>如果需要查找的是一个有序线性表，并且是顺序是线性存储的，查找的话就可以使用&lt;a href="https://quakewang.github.io/tech/binarysearch/">折半&lt;/a>、&lt;a href="https://quakewang.github.io/tech/insertvaluesearch/">插值&lt;/a>、&lt;a href="https://quakewang.github.io/tech/fibonaccisearch/">斐波那契&lt;/a> 等等查找算法来实现，可惜的是，因为是有序，在插入和删除操作上就不太方便，可能需要一移动大量的数据，耗费大量的时间。&lt;/p>
&lt;p>那么，有没有一种既可以使得插入和删除效率不错，又可以比较高效率地实现茶轴的算法呢？？这也就是我们今天所要说的&lt;strong>二叉排序树(BinarySortTree)&lt;/strong> 。&lt;/p>
&lt;h3 id="2二叉排序树介绍">2、二叉排序树介绍&lt;/h3>
&lt;p>&lt;strong>二叉排序树(Binary Sort Tree)&lt;/strong> ： 又称为二叉查找树。它或者是一棵空树，或者具有下列性质的二叉树：&lt;/p>
&lt;ul>
&lt;li>若它的左子树不空，则左子树上所有的结点的值均小于它的根结点的值；&lt;/li>
&lt;li>若它的右子树不空，则右子树上所有的结点的值均小于它的根结点的值；&lt;/li>
&lt;li>它的左、右子树也分别为二叉排序树。&lt;/li>
&lt;/ul>
&lt;p>&lt;em>特别说明：如果有相同的值，可以将该结点放在左结点或者右结点&lt;/em>&lt;/p>
&lt;p>比如针对前面的数据&lt;code>{7, 3, 10, 12, 5, 1, 9}&lt;/code> ，我们再另外插入一个结点 2，对应的二叉树如下：&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/Figure-bed/blob/master/DataStructures/bst.png?raw=true" alt="bst01">&lt;/p>
&lt;p>从二叉排序树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方法，另外，它的结点之间满足一定的次序关系，左子树结点一定比其双亲结点小，右子结点一定比其双亲结点大。&lt;/p>
&lt;p>构造一棵二叉树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。&lt;/p>
&lt;h3 id="二算法实现">二、算法实现&lt;/h3>
&lt;p>由于考虑到BST算法的复杂性，所以使用两个类来完成操作，&lt;code>class Node&lt;/code> 用于表示结点以及完成一些有关的基本方法，比如：添加结点、遍历等方法；&lt;code>class BinarySortTree&lt;/code> 用于封装 &lt;strong>Node&lt;/strong> 类中的方法，以及更具体的完成相关方法体的操作。&lt;/p>
&lt;h4 id="1声明基本变量">1、声明基本变量&lt;/h4>
&lt;p>在 &lt;strong>Node&lt;/strong> 类中，我们需要声明所需的基本变量 &lt;code>int value;&lt;/code> 表示结点中所存储的值、&lt;code>Node left;&lt;/code> 、 &lt;code>Node right;&lt;/code> 二叉排序树的左子结点和右子结点，以及 &lt;strong>toString&lt;/strong> 方法用于打印输出相关结点的信息。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">// 创建Node结点
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Node&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">Node&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">Node&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">Node&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Node{&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;value=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 &lt;strong>BinarySortTree&lt;/strong> 这个类中，定义一个 &lt;code>Node root&lt;/code> 用于完成后续各种方法体中的使用， &lt;em>可以理解成根结点&lt;/em> 。以及返回root结点的方法。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">
&lt;span class="kd">class&lt;/span> &lt;span class="nc">BinarySortTree&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="nf">getRoot&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="2添加结点方法">2、添加结点方法&lt;/h4>
&lt;p>&lt;em>在Node类中，完成对于添加结点方法的编写。&lt;/em>&lt;/p>
&lt;p>在这里以递归的形式添加结点。首先我们通过方法体传入一个需要添加的结点 &lt;strong>node&lt;/strong> 。然后判断该结点是否为空，如果为空，则无法添加直接返回即可。&lt;/p>
&lt;p>根据二叉排序树的性质，可知，如果传入的结点的值小于当前子树的根结点的值&lt;code>node.value &amp;lt; this.value&lt;/code> ，放到左子树，否则放到右子树。但是如何放置呢？这里以左子树举例，（右子同理）如果当前子树的左子结点为空&lt;code>this.left == null&lt;/code>，直接把当前结点添加到左子树就好&lt;code>this.keft = node;&lt;/code>；否则的话，递归的向左子树添加结点 &lt;code>this.left.add(node);&lt;/code>&lt;/p>
&lt;p>&lt;strong>Node类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">
&lt;span class="c1">// 添加结点的方法，以递归的形式添加结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Node&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 判断传入结点的值，和当前子树的根结点的值的关系
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果当前结点的左子结点为null
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 递归的向左子树添加
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 添加的结点的值大于当前结点的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 递归的向右子树添加结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好了，到此为止，在Node类中完成了对于添加结点的方法操作，现在直接在BinarySortTree中封装一下，就可以使用了。&lt;/p>
&lt;p>还是一样，先传入一个结点node，然后判断需要添加子树的根结点是否是为空&lt;code>root == null&lt;/code>，如果为空，直接让root指向node即可，&lt;code>root = node;&lt;/code> 若不为空，直接调用Node类中的添加结点的方法即可。&lt;code>root.add(node);&lt;/code>&lt;/p>
&lt;p>&lt;strong>BinarySortTree类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 添加结点的方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Node&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 如果root为空，则直接让root指向node
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="3中序遍历">3、中序遍历&lt;/h4>
&lt;p>在完成添加结点的方法之后，也就是创建二叉排序树，下面我们来使用中序遍历，完成对其的输出。&lt;/p>
&lt;p>说到中序遍历，想必大家已经都非常熟悉，所以也就没什么好说的了，输出顺序为：&lt;strong>左子结点、根结点、右子结点&lt;/strong> 。所以我们按照这个顺序使用递归的方式完成即可，输出结点信息之前，需要先确认当前结点是否为空，如果不为空则开始递归遍历。&lt;/p>
&lt;p>&lt;strong>Node类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 中序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">infixOrder&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">infixOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">infixOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 &lt;strong>BinarySortTree&lt;/strong> 类中，封装一下中序遍历方法。如果根结点不为空 &lt;code>root != null&lt;/code> ，则开始遍历 &lt;code>root.infixOrder();&lt;/code> ，如果为空，则给出相对应的信息即可。&lt;/p>
&lt;p>&lt;strong>BinarySortTree类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 中序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">infixOrder&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">infixOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;二叉排序树为空，不能遍历~~~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="4查找要删除结点的结点及其父结点">4、查找要删除结点的结点及其父结点&lt;/h4>
&lt;p>在这里，我们要根据所给的需要删除结点的值 &lt;code>value&lt;/code>，分别完成找到需要删除的结点以及其父结点的操作。&lt;/p>
&lt;h5 id="查找需要删除的结点">①查找需要删除的结点&lt;/h5>
&lt;p>如果 &lt;code>value == this.value&lt;/code> ，巧了，刚好找到，就是当前结点，执行 &lt;code>return this;&lt;/code> 如果查找的值小于当前结点的值 &lt;code>value &amp;lt; this.value&lt;/code> ，向左子树递归查找，如果左子树为空 &lt;code>this.left == null&lt;/code> ，&lt;code>return null;&lt;/code> 否则，递归的向左子树查找 &lt;code>return this.left.search(value);&lt;/code> 如果查找的值不小于当前结点的值，向右子树递归查找，具体操作与左子树相同，这里不做过多的赘述，直接上代码。&lt;/p>
&lt;p>&lt;strong>Node类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 查找需要删除的结点
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param value 需要删除的结点的值
&lt;/span>&lt;span class="cm"> * @return 如果找到就返回该结点，否则返回null
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 找到，就是当前结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 如果查找的值小于当前结点的值，向左子树递归查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 如果左子树为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 如果查找的值不小于当前结点的值，向右子树递归查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 如果右子树为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在Node类中完成了对于查找要删除结点的方法操作，现在直接在BinarySortTree中封装一下，就可以使用了。&lt;/p>
&lt;p>先传入一个结点的值value，然后判断根结点是否是为空&lt;code>root == null&lt;/code>，如果为空，直接返回null，&lt;code>return null;&lt;/code> 若不为空，直接调用Node类中的查找删除结点的方法即可。&lt;code>return root.search(value);&lt;/code>&lt;/p>
&lt;h5 id="查找要删除结点的父结点">②查找要删除结点的父结点&lt;/h5>
&lt;p>接下来，我们完成一下对于 查找要删除结点的父结点的操作。还是和上面一样，先传入一个需要查找结点的值&lt;code>value&lt;/code> ，返回的是需要删除结点的父结点，如果没有就返回null。&lt;/p>
&lt;p>如果当前结点就是需要删除结点的父结点&lt;code>(this.left != null &amp;amp;&amp;amp; this.left.value == value) || (this.right != null &amp;amp;&amp;amp; this.right.value == value)&lt;/code>，直接返回即可 &lt;code>return this;&lt;/code> 否则的话，根据二叉排序树的特点，完成以下操作：如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空 &lt;code>value &amp;lt; this.value &amp;amp;&amp;amp; this.left != null&lt;/code>，开始递归向左子树进行查找 &lt;code>return this.left.searchParent(value);&lt;/code> 如果要查找的值大于等于当前的值，并且当前结点的右子结点不为空 &lt;code>value &amp;gt;= this.value &amp;amp;&amp;amp; this.right != null&lt;/code>，开始递归的向右子树查找 &lt;code>eturn this.right.searchParent(value);&lt;/code> 如果进行上述两种操作之后，还是没找到的话，那么直接 &lt;code>return null;&lt;/code>&lt;/p>
&lt;p>&lt;strong>Node类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 查找要删除结点的父结点
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param value 需要查找结点的值
&lt;/span>&lt;span class="cm"> * @return 返回的是需要删除结点的父结点，如果没有就返回null
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="nf">searchParent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果当前结点就是需要删除的结点的父结点，直接返回即可
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">searchParent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">searchParent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 没有找到父结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在Node类中完成了对于查找要删除结点的父结点方法的操作，现在直接在BinarySortTree中封装一下，就可以使用了。&lt;/p>
&lt;p>老规矩，先传入一个结点的值value，然后判断根结点是否是为空&lt;code>root == null&lt;/code>，如果为空，直接返回null，&lt;code>return null;&lt;/code> 若不为空，直接调用Node类中的查找删除结点的方法即可。&lt;code>return root.searchParent(value);&lt;/code>&lt;/p>
&lt;p>&lt;strong>BinarySortTree类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 查找父结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="nf">searchParent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">searchParent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="5删除结点">5、删除结点&lt;/h4>
&lt;p>俗话说 “请神容易送神难“ ，这不，正应了这句话。对于二叉排序树的删除，就不是那么容易了，我们不能因为删除了某个结点，就让这棵树变得不满足二叉排序树的特性，所以删除需要考虑多种情况。&lt;/p>
&lt;p>主要有以下三种情况：&lt;/p>
&lt;ul>
&lt;li>删除 &lt;strong>叶子节点&lt;/strong> （比如：2,5,9,12）&lt;/li>
&lt;li>删除 &lt;strong>只有一颗子树的结点&lt;/strong> （比如：1）&lt;/li>
&lt;li>删除 &lt;strong>有两棵子树的结点&lt;/strong> （比如：7,3,10）&lt;/li>
&lt;/ul>
&lt;p>下面我们就对于以上的情况，进行具体的操作分析：&lt;/p>
&lt;h5 id="准备工作">①准备工作&lt;/h5>
&lt;p>在删除一个结点之前，我们需要保证删除的结点是有效的，然后再执行具体的删除方法。&lt;/p>
&lt;p>如果 &lt;code>root == null&lt;/code> 也就是说，root为空，则直接 return即可。如果不为空，开始执行以下的操作：&lt;/p>
&lt;ul>
&lt;li>1.需要先找到要删除的结点 targetNode &lt;code>Node targetNode = search(value);&lt;/code>
&lt;ul>
&lt;li>如果没有找到要删除的结点 &lt;code>targetNode == null&lt;/code> ,则直接return&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2.如果当前的这棵二叉排序树只有一个结点，直接置空；&lt;/li>
&lt;li>3.去找到TargetNode的父结点 &lt;code>Node parent = searchParent(value);&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BinarySortTree类中代码实现如下：&lt;/strong>&lt;/p>
&lt;p>（这里我们直接把删除方法放在BinarySortTree类中完成）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 1、需要先找到要删除的结点 targetNode
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">targetNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 如果没有找到要删除的结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">targetNode&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 2、如果当前这颗二叉排序树只有一个结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 3 、去找到targetNode的父结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Node&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">searchParent&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h5 id="删除叶子结点">②删除叶子结点&lt;/h5>
&lt;p>对于要删除结点是叶子结点的情况，相对而言是比较容易的。因为是叶子结点，所以它没有左右子树，所以直接把它抹了即可。但是呢，它本身是无法完成删除操作的，需要先去找到要删除的结点 &lt;code>targetNode&lt;/code> ,然后再去找到 &lt;code>targetNode&lt;/code> 的父结点 &lt;code>parent&lt;/code> ，接下就是需要确定 targetNode 是 parent的左子结点，还是右子结点，根据对应的情况进行删除即可。&lt;/p>
&lt;ul>
&lt;li>如果是左子结点，将父结点的左子树置空，即 &lt;code>parent.left == null&lt;/code>&lt;/li>
&lt;li>如果是右子结点，将父结点的右子树置空，即 &lt;code>parent.right == null&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BinarySortTree类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 4、如果要删除的节点是叶子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 判断targetNode是父结点的左子结点还是右子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 是左子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 是右子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h5 id="删除两棵子树的结点">③删除两棵子树的结点&lt;/h5>
&lt;p>为什么我们先说删除有两棵子树的结点呢？？那么因为语言描述只有一棵子树的结点，相比而言是要难一点的，所以直接把这种情况放在最后，用一个 &lt;strong>else&lt;/strong> 来概括即可。&lt;/p>
&lt;p>删除是有两棵子树的结点 &lt;code>targetNode.left != null &amp;amp;&amp;amp; targetNode.right != null&lt;/code> ,因为它有两棵子树，那么它一旦被删除了，是谁来接班呢？？就好比如何选取一个合适的人选来继承家产呢，并且还满足二叉排序的特点。这样一来，问题也就随之而来了，该如何选出这个合适的继承人呢？？&lt;/p>
&lt;p>假设现在需要删除的结点是7，也就是该二叉排序树的根结点，现在仔细观察一下里面的元素，是否可以从其左右子树中找到适合的结点呢？？果然，5或9都可以代替7，此时删除7后，整个二叉排序树的结构并没有发生本质的改变。&lt;/p>
&lt;p>思考一下，为什么选择5或9这两个结点呢？？对的，它们刚好是二叉排序树中比它小或比它大的最接近7的两个数。也就是说，我们对当前这棵而排序树进行中序遍历，&lt;code>1, 2, 3, 5, 7, 9, 10, 12&lt;/code>，它们刚好是7的前驱和后继。所以说现在的问题转化为如何知道需要删除结点的前驱结点或者后继结点。根据二叉排序树的特点，以需要删除的结点为根结点，那么它的右子树中最小的结点或者左子树中最大的结点，就是可以删除它后，从而代替它的结点。&lt;/p>
&lt;p>这里以右子树最小的结点为例，编写一个具体的方法来进行讲解。某颗子树最小的结点一定是左子树的最后一个结点，所以直接循环地查找左子结点，就会找到最小的值。找到最小的这个结点之后，先别激动，需要把它给删除，因为它即将代替需要删除的结点，再找个临时变量来保存它，这里我们先直接返回它，在具体的删除方法中再取出即可。&lt;/p>
&lt;p>&lt;strong>BinarySortTree类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 编写方法：
&lt;/span>&lt;span class="cm"> * 1、返回的是以node为根结点的二叉排序树的最小结点的值
&lt;/span>&lt;span class="cm"> * 2、删除node为根结点的二叉排序树的最小结点
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param node 传入的结点（当做二叉排序树的根结点）
&lt;/span>&lt;span class="cm"> * @return 返回的 以node为根结点的二叉排序树的最小结点的值
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">delRightTreeMin&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Node&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Node&lt;/span> &lt;span class="n">target&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 循环的查找左子结点，就会找到最小的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">target&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 这时target就指向了最小结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 删除最小结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">delNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>哈哈哈哈，找到了继承人，接下来的工作，相对而言就要简单的多了，先找一个临时变量&lt;code>minVal&lt;/code> 来保存从&lt;code>delRightTreeMin(targetNode.right)&lt;/code> 返回的值，然后再把这个值重新赋值给需要删除的结点即可。&lt;/p>
&lt;p>&lt;strong>BinarySortTree类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 删除的是有两棵子树的结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">minVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">delRightTreeMin&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">minVal&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h5 id="删除只有一颗子树的结点">④删除只有一颗子树的结点&lt;/h5>
&lt;p>对于要删除的结点只有左子树或只有右子树的情况，相对也是比较容易解决的。那就是结点删除后，将它的左子树或右子树整个移动到删除结点的位置即可，说直白点，可以理解为独自继承父业呗，哈哈哈哈。下面我们来看下具体的实现方法：&lt;/p>
&lt;p>既然是要删除它，那么毫无疑问，得先找到要删除的结点 &lt;code>targetNode&lt;/code>，再接着找到其父结点 &lt;code>parent&lt;/code>，然后 &lt;em>接下来的内容可能会有点绕，会有点傻傻的左右分不清，可以自己画图来尝试理解&lt;/em> ，确定targetNode的子结点是左子结点还是右子结点，以及 需要删除对的结点 targetNode 是其父结点 parent的左子结点还是右子结点。分成如下操作：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果需要删除结点的左子树不为空 &lt;code>targetNode.left != null&lt;/code> （并且 &lt;code>parent != null&lt;/code>）&lt;/p>
&lt;ul>
&lt;li>如果targetNode是parent的左子结点 &lt;code>parent.left.value == targetNode.value&lt;/code>
- 将其父结点的左索引指向其左子结点 &lt;code>parent.left = targetNode.left;&lt;/code>&lt;/li>
&lt;li>否则targetNode是parent的右子结点
&lt;ul>
&lt;li>将其父结点的右索引指向其左子结点 &lt;code>parent.right = targetNode.left;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>否则（如果parent为空），直接 &lt;code>root == targetNode.left;&lt;/code>即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果需要删除结点的右子树不为空（并且 &lt;code>parent != null&lt;/code>）&lt;/p>
&lt;ul>
&lt;li>如果targetNode是parent的左子结点 &lt;code>parent.left.value == targetNode.value&lt;/code>
&lt;ul>
&lt;li>将其父结点的左索引指向其右子结点 &lt;code>parent.left = targetNode.right;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>否则targetNode是parent的右子结点
&lt;ul>
&lt;li>将其父结点的右索引指向其右子结点 &lt;code>parent.right = targetNode.right;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>否则（如果parent为空），直接 &lt;code>root == targetNode.right;&lt;/code>即可。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BinarySortTree类中代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 删除只有一颗子树的结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 如果要删除的节点有左子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果targetNode是parent的左子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//targetNode是parent的右子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 如果需要删除的结点有右子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果targetNode是parent的左子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 如果targetNode是parent的右子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">targetNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>到此为止，我们完成了对于一个结点的删除工作，由此可见是相当的麻烦啊！！！&lt;/p>
&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>该死的二叉排序树终于写完了，十一月份只写了一半，忙（懒）成狗。。。。&lt;/p>
&lt;p>二叉排序树是链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点。只要找到合适的插入和删除位置后，仅需修改链接指针即可。对于查找而言，走的就是从根结点到要查找结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。因为篇幅优先，查找算法可以结合之前所更新的博客自行完成即可。&lt;/p>
&lt;p>源码地址 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/binarysorttree/BinarySortTreeDemo.java">二叉排序树&lt;/a>&lt;/p></content></entry><entry><title type="text">排序——堆排序</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/heapsort/"/><id>https://quakewang.github.io/tech/heapsort/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-10-29T11:26:47+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">堆排序 一、前言 0、牢骚话 说实话，有点惭愧，十月份真的咕咕了好久。。。可能是因为真的比……</summary><content type="html">&lt;h1 id="堆排序">堆排序&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="0牢骚话">0、牢骚话&lt;/h3>
&lt;p>说实话，有点惭愧，十月份真的咕咕了好久。。。可能是因为真的比较忙，忙着参加比赛，忙着开源年会，其实这都是借口、要是想更，时间总是可挤得出来的。也许是越往后，牵涉到的内容也就越多，可能是知识点掌握的不太牢固，就一直懒得水文章（&lt;em>其实前面几篇文章已经暴露这个问题，只不过还是硬着头皮在做&lt;/em>）。针对以上出现的问题，我就毅然决然的选择先缓，静下心来，再好好琢磨琢磨。&lt;/p>
&lt;h3 id="1堆的基本介绍">1、堆的基本介绍&lt;/h3>
&lt;p>说到堆排序，大家可能会想到“堆”，为什么叫堆排序呢？其实不难不理解，我们都见过“堆”型的东西，比如金字塔。。那么这个和排序有什么关系呢？？下面我们来看一下关于堆的定义：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort00.png?raw=true" alt="HeapSort00">&lt;/p>
&lt;p>对吧，是不是堆形的。其实我们利用上一节说过&lt;a href="https://quakewang.github.io/tech/threadedbinarytree/">线索化二叉树&lt;/a>，将其存放在数组中进行操作，如下：&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort001.png?raw=true" alt="HeapSort001">&lt;/p>
&lt;p>这个数组从逻辑上说就是一个堆的结构，经过前人的总结，我们可以使用简单的公式描述一下堆：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>大顶堆：arr[i] &amp;gt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;gt;= arr[2i+2]&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>小顶堆：arr[i] &amp;lt;= arr[2i+1] &amp;amp;&amp;amp; arr[i] &amp;lt;= arr[2i+2]&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>说到这儿，想必大家对于堆这种结构已经有了简单的了解，接下来我们来一探究竟，看看如何来实现排序的。&lt;/p>
&lt;h3 id="3堆排序的基本思想">3、堆排序的基本思想&lt;/h3>
&lt;p>注：一般升序采用大顶堆，降序采用小顶堆。&lt;/p>
&lt;blockquote>
&lt;p>**堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列 **&lt;/p>
&lt;/blockquote>
&lt;h4 id="步骤一构造初始堆">①步骤一：构造初始堆&lt;/h4>
&lt;p>将给定无序序列构造成一个大顶堆&lt;/p>
&lt;h5 id="a假设给定无序序列结构如下">a.假设给定无序序列结构如下：&lt;/h5>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort01.png?raw=true" alt="Step01">&lt;/p>
&lt;h5 id="b此时我们从最后一个非叶子结点开始叶结点自然不用调整第一个非叶子结点-arrlength2-152-11也就是下面的6结点从左至右从下至上进行调整">b.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。&lt;/h5>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort02.png?raw=true" alt="Step02">&lt;/p>
&lt;h5 id="c找到第二个非叶节点4由于498中9元素最大4和9交换">c.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。&lt;/h5>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort03.png?raw=true" alt="Step03">&lt;/p>
&lt;h5 id="d这时交换导致了子根456结构混乱继续调整456中6最大交换4和6">d.这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。&lt;/h5>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort04.png?raw=true" alt="Step04">&lt;/p>
&lt;p>此时，如此反复通过上述步骤，我们就将一个无序序列构建成了一个大顶堆。&lt;/p>
&lt;h4 id="步骤二将堆顶元素与末尾元素进行交换使末尾元素最大然后继续调整堆再将堆顶元素与末尾元素交换得到第二大元素如此反复进行交换重建交换">②步骤二：将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。&lt;/h4>
&lt;h5 id="a将堆顶元素9和末尾元素4进行交换">a.将堆顶元素9和末尾元素4进行交换&lt;/h5>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort05.png?raw=true" alt="Step05">&lt;/p>
&lt;h5 id="b重新调整结构使其继续满足堆定义">b.重新调整结构，使其继续满足堆定义&lt;/h5>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort05.png?raw=true" alt="Step06">&lt;/p>
&lt;h5 id="c再将堆顶元素8与末尾元素5进行交换得到第二大元素8">c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.&lt;/h5>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort07.png?raw=true" alt="Step07">&lt;/p>
&lt;h5 id="d后续过程继续进行调整交换如此反复进行最终使得整个序列有序">d.后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序&lt;/h5>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/HeapSort08.png?raw=true" alt="Step08">&lt;/p>
&lt;h4 id="小结">③小结&lt;/h4>
&lt;p>再简单总结下堆排序的基本思路：&lt;/p>
&lt;p>　　&lt;strong>a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;&lt;/strong>&lt;/p>
&lt;p>　　&lt;strong>b.将堆顶元素与末尾元素交换，将最大元素&amp;quot;沉&amp;quot;到数组末端;&lt;/strong>&lt;/p>
&lt;p>　　&lt;strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。&lt;/strong>&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>经过上述的介绍，大致对于堆排序都有了一个简单的了解，但是具体一点，可能还是比较迷，最起码应该知道两个步骤：①构建一个大顶堆（或小顶堆）；②进行排序。下面我们上手代码，通过代码和图解效果可能会好点。&lt;/p>
&lt;h3 id="1构建大顶堆">1、构建大顶堆&lt;/h3>
&lt;p>将一个数组（二叉树），调整成一个大顶堆。（&lt;em>功能：完成将以i对应对的非叶子结点的树，调整成大顶堆&lt;/em>）这里我们对传入的数组进行升序操作，所以采用大顶堆，反之使用小顶堆即可。&lt;/p>
&lt;p>首先需要有传入的待排序数组&lt;code>int[] arr&lt;/code>、非叶子结点在数组中的索引&lt;code>int i&lt;/code> 、对应多少个元素进行调整&lt;code>int length&lt;/code>，我们需要注意的是随着构建的过程length是在逐渐减少的。好了，知道了应该传入哪些变量之后，我们开始动工！！！（可能比较难理解，我会尽量按照我理解的思路来阐述）&lt;/p>
&lt;p>我们知道i表示的是一个非叶子结点，所以先把这个结点的值取出临时保存在一个临时变量中（&lt;em>后期有用的&lt;/em>）&lt;code>int temp = arr[i];&lt;/code> 然后我们依次遍历该结点的左右子结点并比较其大小，选出较大的一个与当前i对应的结点进行比较，最后把最大的值放在顶部，注意哦这里是局部顶部，因为对应的是该非叶子结点的一颗树。&lt;/p>
&lt;p>这时，我们知道了无非就是比较一个非叶子结点的左右子树与该结点的大小，然后选出一个最大的放在顶部嘛，但是具体一点该怎么操作呢？？看下去咯。。&lt;/p>
&lt;p>这里使用for循环来遍历其该结点的左右子树，&lt;code>for(int k = i * 2 + 1; k &amp;lt; length; k = k * 2 + 1)&lt;/code> 。k通过执行 k = i * 2 + 1之后，这是的k指向的是i结点的左子结点。然后比较其与右子树的大小&lt;code>arr[k] &amp;lt; arr[k + 1]&lt;/code>，这时我们将k指向较大的一颗子树即可，通过&lt;code>k++&lt;/code>来实现，（&lt;em>因为右子树的下标比左子树大一&lt;/em>）。这是我们已经选取了左右子树中较大的一个，然后将其与i结点所在的元素比较。然后子结点大于父结点&lt;code>arr[k] &amp;gt; temp&lt;/code> ，把较大的值赋给当前结点&lt;code>arr[i] arr[k]&lt;/code>，别忘了还要将i指向k&lt;code>i = k&lt;/code> ，继续循环比较；如果父结点最大，我们直接break即可。因为是&lt;strong>从左至右，从下至上调整&lt;/strong>的，所以不会出现漏判的情况。当for循环结束后，已经将i为父结点的树的最大值，放在了最顶（局部）。这时我们还需要把temp临时保存的值放置到调整后的位置&lt;code>arr[i] = temp&lt;/code> 。如此反复就能成功构建出一个大顶堆。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 将一个数组（二叉树），调整成一个大顶堆
&lt;/span>&lt;span class="cm"> * 功能：完成将以i对应的非叶子结点的树，调整成大顶堆
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param arr 待调整的数组
&lt;/span>&lt;span class="cm"> * @param i 表示非叶子结点在数组中的索引
&lt;/span>&lt;span class="cm"> * @param length 表示对应多少个元素进行调整，length是在逐渐的减少
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">adjustHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">// 先取出当前元素的值，保存在临时变量
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 说明：k = i * 2 + 1 k是i结点的左子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">k&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">k&lt;/span>&lt;span class="o">++;&lt;/span>&lt;span class="c1">// k指向右子结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 如果子结点大于父结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">// 把较大的值赋给当前结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// i指向k，继续循环比较
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 当for循环结束后，已经将i为父结点的树的最大值，放在了最顶（局部）
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 将temp值放到调整后的位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2堆排序的方法">2、堆排序的方法&lt;/h3>
&lt;p>根据上文提到的堆排序的思想有：&lt;/p>
&lt;h4 id="将无序序列构建成一个堆">①将无序序列构建成一个堆&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">adjustHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据线索化二叉树可知，该树中非叶子结点的位置在&lt;code>arr.length / 2 - 1&lt;/code> 的位置，调用&lt;code>adjustHeap(arr, i, arr.length);&lt;/code> 即可。&lt;/p>
&lt;h4 id="将堆顶元素与末尾元素交换将最大元素沉到数组末端">②将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端&lt;/h4>
&lt;h4 id="重新调整结构使其满足堆定义然后继续交换堆顶元素与当前末尾元素反复执行调整直到整个序列有序">③重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整，直到整个序列有序&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 交换
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">adjustHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在完成上述操作之后，我们也就有了一个完成的有序序列。&lt;/p>
&lt;p>&lt;strong>完整代码如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 编写一个堆排序的方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">heapSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 1、将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">adjustHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 2、将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 3、重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整，直到整个序列有序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 交换
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">adjustHeap&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>堆排序确实有点难度，但其本质还是以二叉树的形式存储的数组，如果有不理解的地方可以debug然后结合画图来理解，文字描述确实太难了。。。。&lt;/p>
&lt;p>源码地址 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/tree/HeapSort.java">堆排序&lt;/a>&lt;/p></content></entry><entry><title type="text">树——线索化二叉树</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/threadedbinarytree/"/><id>https://quakewang.github.io/tech/threadedbinarytree/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-10-07T14:27:50+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">线索化二叉树 一、前言 1、问题引入 现如今我们在生活上都提倡节约环保，所以对于我们的所写……</summary><content type="html">&lt;h1 id="线索化二叉树">线索化二叉树&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1问题引入">1、问题引入&lt;/h3>
&lt;p>现如今我们在生活上都提倡节约环保，所以对于我们的所写的代码也不例外，能节省时间或空间，我们就应该去考虑节省。我们来思考一下二叉树的结构：&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/ThreadedBinaryTree01.png?raw=true" alt="ThreadedBinaryTree01">&lt;/p>
&lt;p>二叉树的中序遍历结果为HDIBJEAFCG，可以得知A的前驱结点为E，后继结点为F。但是，这种关系的获得是建立在完成遍历后得到的，那么可不可以在建立二叉树时就记录下前驱后继的关系呢，那么在后续寻找前驱结点和后继结点时将大大提升效率。&lt;/p>
&lt;p>还有就是我们可以观察到，EFGHIJ等结点都存在空的指针域，这样的话会造成空间上的浪费，所以该如何做，才能有效的处理这些问题呢？？&lt;/p>
&lt;p>那也就是我们今天的重点内容—— &lt;strong>线索化二叉树&lt;/strong> 。&lt;/p>
&lt;h3 id="2线索化二叉树基本介绍">2、线索化二叉树基本介绍&lt;/h3>
&lt;ul>
&lt;li>n个结点的二叉链表含有 &lt;strong>n + 1&lt;/strong> 个空指针域。利用二叉链表中的空指针域存放指向该结点在某种遍历次序下的前驱和后继结点的指针，这种附加的指针称为“线索”；&lt;/li>
&lt;li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索化二叉树，根据线索性质不同，可以分为：前序线索二叉树、中序线索二叉树（ &lt;em>我们这里使用中序进行讲解&lt;/em> ）以及后序线索二叉树三种；&lt;/li>
&lt;li>一个结点的前一个结点，称为 &lt;strong>前序结点&lt;/strong> ；&lt;/li>
&lt;li>一个结点的后一个结点，称为 &lt;strong>后继结点&lt;/strong> 。&lt;/li>
&lt;/ul>
&lt;h3 id="3线索化规则">3、线索化规则&lt;/h3>
&lt;p>现将某结点的空指针域指向该结点的前驱后继，定义规则如下：&lt;/p>
&lt;blockquote>
&lt;p>若结点的左子树为空，则该结点的做孩子指针指向其前驱结点；&lt;/p>
&lt;p>若结点的右子树为空，则该结点的右孩子指针指向其后继结点。&lt;/p>
&lt;/blockquote>
&lt;p>根据这个规则，我们将上图线索化之后，如下：&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/ThreadedBinaryTree02.png?raw=true" alt="ThreadedBinaryTree02">&lt;/p>
&lt;p>图中黑色虚线为指向后继的线索，紫色虚线为指向前序的线索。可以看出通过线索化，即解决了空间浪费问题，又解决了前驱后继的记录问题。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1创建结点">1、创建结点&lt;/h3>
&lt;p>既然我们需要实现线索化二叉树，所以需要先创建一个HeroNode类表示结点，包含的属性有：&lt;code>int no;// 表示编号&lt;/code> 、&lt;code>String name;// 表示姓名&lt;/code>、&lt;code>HeroNode left;// 表示左子结点，默认为null&lt;/code> 、&lt;code>HeroNode right;// 表示右子结点，默认为null&lt;/code> 。&lt;/p>
&lt;p>除了上述的基本变量之外，我们还要定义两个类型变量，用于判断指向的是左子树（右子树）还是前驱（后继）结点。&lt;em>我们在这里规定0表示指向树，1表示指向结点。&lt;/em>&lt;/p>
&lt;p>定义好上述变量之后，还有就是相关的get以及set方法，外加一个toString方法用于显示信息。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">// 创建HeroNode结点
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">HeroNode&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 默认为null
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 默认为null
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> 说明：
&lt;/span>&lt;span class="cm"> 1、如果leftType == 0 表示指向的是左子树，如果1则表示是前驱结点
&lt;/span>&lt;span class="cm"> 2、如果rightType == 0 表示指向的是右子树，如果1则表示指向后继结点
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">leftType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">rightType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 构造器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">HeroNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="nf">getLeft&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setLeft&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getLeftType&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">leftType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setLeftType&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">leftType&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">leftType&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">leftType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">getName&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getNo&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setNo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="nf">getRight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setRight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getRightType&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rightType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setRightType&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">rightType&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">rightType&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rightType&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;HeroNode{&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34; name=&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;, no=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2实现线索化">2、实现线索化&lt;/h3>
&lt;p>为了实现线索化，我们首先需要创建一个指向当前结点的前驱结点的指针pre（&lt;em>默认为null&lt;/em>），这样从而使得，在递归进行线索化的时候，pre总是保留前一个结点。以及定义一个根结点root。&lt;/p>
&lt;p>下面开始执行线索化方法体threadedNodes：先判断传入的结点是否为空，如果为空，则无法进行线索化；由于中序遍历的顺序为：左、中、右。所以我们按照这个顺序编写代码，使用递归的方式。&lt;/p>
&lt;p>①&lt;strong>线索化左子树&lt;/strong> ：&lt;code>threadedNodes(node.getLeft());&lt;/code>&lt;/p>
&lt;p>②&lt;strong>线索化当前结点&lt;/strong> ：这个是重中之重，也是难点所在。先处理当前结点的前驱结点（ &lt;em>先将当前结点的左指针设置为pre，然后再修改左指针的类型，指向前驱结点&lt;/em> ），接着处理后继结点（ &lt;em>先将当前结点的右指针指向当前结点，然后再修改右指针的类型&lt;/em> ），在完成以上步骤之后，也就处理完成一个结点，然后让当前结点指向下一个结点的前驱结点 &lt;code>pre = node&lt;/code>；&lt;/p>
&lt;p>③&lt;strong>线索化右子树&lt;/strong> ：&lt;code>threadedNodes(node.getRight());&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">// 定义ThreadedBinaryTree
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">ThreadedBinaryTree&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 为了实现线索化，需要创建要给指向当前结点的前驱结点的指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 在递归进行线索化时，pre总是保留前一个结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">pre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setRoot&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//重载threadNodes方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">threadedNodes&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">threadedNodes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">threadedNodes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果node == null 不能线索化
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// （一）先线索化左子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">threadedNodes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getLeft&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="c1">// （二）线索化当前结点【难点】
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 处理当前结点的前驱结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getLeft&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 当前结点的左指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setLeft&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">pre&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 修改当前结点的左指针的类型，指向前驱结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setLeftType&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 处理后继结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">pre&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">pre&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRight&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 让前驱结点的右指针指向当前结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">pre&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setRight&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 修改前驱结点的右指针类型
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setRightType&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// ！！！每处理一个结点后。让当前结点指向下一个结点的前驱结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">pre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// （三）再线索化右子树
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">threadedNodes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getRight&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>从上面的分析我们可以看出，由于它充分利用空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着省了时间）。所以在实际问题中，&lt;strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前序和后继，那么采用线索化二叉树就是一个非常不错的选择咯！&lt;/strong>&lt;/p>
&lt;p>源码 ——&amp;gt;&lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/tree/threadedbinarytree/ThreadedBinaryTreeDemo.java">线索化二叉树&lt;/a>&lt;/p></content></entry><entry><title type="text">树——顺序存储二叉树遍历</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/arraybinarytree/"/><id>https://quakewang.github.io/tech/arraybinarytree/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-28T13:47:41+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">顺序存储二叉树遍历 一、前言 1、顺序存储二叉树的概念 ①基本说明 从数据存储来看，数组存储……</summary><content type="html">&lt;h1 id="顺序存储二叉树遍历">顺序存储二叉树遍历&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1顺序存储二叉树的概念">1、顺序存储二叉树的概念&lt;/h3>
&lt;h4 id="基本说明">①基本说明&lt;/h4>
&lt;p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即 &lt;strong>数组可以转换成数。数也可以转换成数组&lt;/strong> ，如下图：&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/ArrayBinaryTree01.png?raw=true" alt="ArrayBinaryTree">&lt;/p>
&lt;h4 id="要求">②要求&lt;/h4>
&lt;ul>
&lt;li>上图的二叉树的结点，要求以数组的方式来存放，arr = [1,2,3,4,5,6,7]；&lt;/li>
&lt;li>要求在遍历数组arr时，仍然可以使用前序遍历、中序遍历和后序遍历的方式完成结点的遍历。&lt;/li>
&lt;/ul>
&lt;h3 id="2顺序存储二叉树的特点">2、顺序存储二叉树的特点&lt;/h3>
&lt;ul>
&lt;li>顺序二叉树通常只考虑完全二叉树；&lt;/li>
&lt;li>第n个元素的左子结点为 2*n + 1；&lt;/li>
&lt;li>第n个元素的右子结点为 2*n + 2；&lt;/li>
&lt;li>第n个元素的父结点为 (n - 1) / 2；&lt;/li>
&lt;li>n：表示二叉树中的第几个元素（按0开始编号如上图）。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1顺序存储二叉树的前序遍历">1、顺序存储二叉树的前序遍历&lt;/h3>
&lt;p>首先，我们需要判断所给的数组是否符合条件，如果 &lt;strong>数组为空&lt;/strong> 则，无法完成遍历，并给出相关提示；接下来，我们就按照前序遍历的法则，先输出当前这个元素，再向左递归遍历，最后向右递归遍历即可。&lt;/p>
&lt;p>需要注意的是：在向左和向右遍历的时候需要先判断索引所在的位置，是否在数组之内，如果是数组之外，就无法完成遍历；其次就是需要注意递归时候开始的索引。根据顺序存储二叉树的特点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 编写一个方法，实现顺序存储二叉树的前序遍历
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param index 数组的下标
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先判断数组是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;数组为空，无法完成相关遍历&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 输出当前这个元素
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="c1">// 向左递归遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">preOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 向右递归遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">preOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2顺序存储二叉树的中序遍历">2、顺序存储二叉树的中序遍历&lt;/h3>
&lt;p>和前序遍历相类似，只不过在进行输出和递归时候的位置发生交换。先进行左递归，然后输出当前结点，最后向右递归遍历。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 顺序存储二叉树的中序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">infixOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先判断数组是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;数组为空，无法完成相关遍历&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 向左递归遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">infixOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 输出当前这个元素
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="c1">// 向右递归遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">infixOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3顺序存储二叉树的中序遍历">3、顺序存储二叉树的中序遍历&lt;/h3>
&lt;p>和前序、中序遍历一样，顺序更改为：先向左递归遍历，然后向右递归遍历，最后输出当前结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 顺序存储二叉树的后序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">postOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先判断数组是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;数组为空，无法完成相关遍历&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 向左递归遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">postOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 向右递归遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">postOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 输出当前这个元素
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>利用数组的顺序存储来实现二叉树，其遍历方法和普通的二叉树来说，并无差别需要注意的就是索引的起始位置。，牢记顺序存储二叉树的特点即可。&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/tree/ArrBinaryTreeDemo.java">顺序存储二叉树&lt;/a>&lt;/p></content></entry><entry><title type="text">树——二叉树查找以及删除结点</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/binarytreesearch/"/><id>https://quakewang.github.io/tech/binarytreesearch/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-24T17:44:43+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">二叉树查找以及删除结点 一、前言 在上一篇blog中，我们了解了有关二叉树遍历的实现方法……</summary><content type="html">&lt;h1 id="二叉树查找以及删除结点">二叉树查找以及删除结点&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在上一篇blog中，我们了解了有关二叉树遍历的实现方法，其实，二叉树还可以用于查找关键字，和遍历一样，同样分成前中后三种方法查找。&lt;/p>
&lt;p>本次内容除了介绍二叉树的遍历查找算法之外，考虑到由于篇幅不是很多，所以又增加了在二叉树中删除结点的方法。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1前序查找">1、前序查找&lt;/h3>
&lt;p>思路：首先判断当前结点的关键字是否等于要查找的；如果是相等的，则返回当前结点，该结点，也就是我们所要查找的结点；如果不等， &lt;strong>则判断当前结点的左子结点是否为空&lt;/strong> ，如果不为空，则递归前序查找；如果左递归前序查找，找到结点，则返回，否则继续判断，当前结点的右子结点是否为空，如果不为空，则继续向右递归前序查找。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 前序遍历查找
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param no 查找no
&lt;/span>&lt;span class="cm"> * @return 如果找到就返回该Node，如果没有找到返回null
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="nf">preOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 比较当前结点是不是
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 1、判断当前结点的左子结点是否为空，如果不为空，则递归前序查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 2、如果做递归前序查找，找到结点，则返回
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">preOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">resNode&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 说明左子树找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">resNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 3、左递归前序查找，找到结点，则返回，否则继续判断
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 4、当前结点的右子结点是否为空，如果不空，则继续向右递归前序查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">preOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">resNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2中序查找">2、中序查找&lt;/h3>
&lt;p>思路：判断当前结点的左子结点是否为空，如果不为空，则递归中序查找；如果找到，则返回。如果没有找到。就和当前结点比较，如果是则返回当前结点，否则继续进行右递归的中序查找；如果右递归中序查找，找到返回该结点，否则返回null。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 中序遍历查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="nf">infixOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 判断当前结点的左子结点是否为空，如果不为空，则递归中序查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">infixOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">resNode&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">resNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 如果找到，则返回，如果没有找到就和当前结点比较，如果是则返回当前结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 否则继续进行右递归的中序查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">infixOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">resNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3后序查找">3、后序查找&lt;/h3>
&lt;p>思路：判读当前结点的左子结点是否为空，如果不为空，则递归后序查找；如果找到，就返回，如果没有找到，就判断当前结点的右子结点是否为空，如果不为空，则右递归进行后序查找，如果找到，就返回；否则 就和当前结点进行比较，如果是则返回该结点，否则返回null。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 后序遍历查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="nf">postOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 判断当前结点的左子结点是否为空，如果不为空，则递归后序查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">postOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">resNode&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 说明左子树找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">resNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 如果左子树没有找到，则向右子树递归进行后序遍历查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">resNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">preOrderSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">resNode&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">resNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 如果左右子树都没有找到，就比较当前结点是不是
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">resNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4删除结点">4、删除结点&lt;/h3>
&lt;p>分析：&lt;/p>
&lt;p>在删除之前，我们要思考一个问题，那就是所需要删除的结点时叶子结点还是非叶子结点，如果是叶子结点，则直接删除即可；对于非叶子结点我们在这里做如下处理：那就是删除连同该结点的一棵树。&lt;/p>
&lt;p>思路：&lt;/p>
&lt;p>①因为该二叉树是单向的，所以判断的是当前结点的子结点是否为需要删除的结点，而不是直接判断需要删除的当前结点（如果直接判断需要删除的当前结点，那么当指针指向该结点的时候，由于是单向的二叉树，则已经错过了删除的机会。）&lt;/p>
&lt;p>②如果当前结点的左子结点不为空，并且左子结点就是需要删除的结点，就将 &lt;code>this.left = null&lt;/code> 并且返回（结束递归删除）；&lt;/p>
&lt;p>③如果当前结点的右子结点不为空，并且右子结点就是需要删除的结点，就将 &lt;code>this.right = null&lt;/code> 并且返回（结束递归删除）；&lt;/p>
&lt;p>④如果第2和第3步没有删除结点，那么就需要向左子树进行递归删除；&lt;/p>
&lt;p>⑤如果第4步也没有删除结点，则应当向右子树进行递归删除。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">delNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">delNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">delNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>利用递归来实现二叉树查找关键字，总体上来说，还是比较便于理解的。在查找的基础上新加了删除结点的方法。&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/tree/BinaryTreeDemo.java">二叉树查找&lt;/a>&lt;/p></content></entry><entry><title type="text">树——二叉树遍历</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/binarytree01/"/><id>https://quakewang.github.io/tech/binarytree01/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-21T20:36:46+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">遍历二叉树 一、前言 在上一篇blog中，我们了解了有关树的基础知识，特别的是重点介绍了……</summary><content type="html">&lt;h1 id="遍历二叉树">遍历二叉树&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在上一篇blog中，我们了解了有关树的基础知识，特别的是重点介绍了一下二叉树。这里，我们就来探究一下关于二叉树的遍历方法。&lt;/p>
&lt;p>二叉树的遍历方法有三种，分别是：&lt;/p>
&lt;ul>
&lt;li>前序遍历：先输出父结点，在遍历左子树和右子树；&lt;/li>
&lt;li>中序遍历：先遍历左子树，再输出父结点，再遍历右子树；&lt;/li>
&lt;li>后序遍历：先遍历左子树，再遍历左子树 ，再输出父结点。&lt;/li>
&lt;/ul>
&lt;p>小结：看输出父结点的顺序，就确定是前序，中序还是后序。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1前序遍历">1、前序遍历&lt;/h3>
&lt;ol>
&lt;li>先输出当前结点（初始的时候是根节点）；&lt;/li>
&lt;li>如果左子结点不为空，则递归继续前序遍历；&lt;/li>
&lt;li>如果右子结点不为空，则递归继续前序遍历。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 编写前序遍历的方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">preOrder&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">);&lt;/span>&lt;span class="c1">// 先输出父结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 递归向左子树前序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">preOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 向右子树前序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">preOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2中序遍历">2、中序遍历&lt;/h3>
&lt;ol>
&lt;li>如果当前结点的左子结点不为空，则递归中序遍历；&lt;/li>
&lt;li>输出当前结点；&lt;/li>
&lt;li>如果当前结点的右子结点不为空，则递归中序遍历。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 中序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">infixOrder&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 递归向左子树中序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">infixOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 输出父结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 递归向右子树中序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">infixOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3后序遍历">3、后序遍历&lt;/h3>
&lt;ol>
&lt;li>如果当前结点的左子结点不为空，则递归后序遍历；&lt;/li>
&lt;li>如果当前节点的右子结点不为空，则递归中序遍历；&lt;/li>
&lt;li>输出当前结点。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 后序遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">postOrder&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">postOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">postOrder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>其实遍历二叉树，可以进行利用递归和非递归两种方式来处理，我们这里使用的是递归的方式，个人感觉，在明白递归机制之后，递归实现更容易理解点吧。&lt;/p>
&lt;p>源码 ——&amp;gt;&lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/tree/BinaryTreeDemo.java">二叉树&lt;/a>&lt;/p></content></entry><entry><title type="text">树及其相关概念</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/abouttree/"/><id>https://quakewang.github.io/tech/abouttree/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-20T21:41:20+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">树 一、树的相关概念 1、引入 之前我们所提到的数组也好、链表也罢，其实都是一对一的线性结……</summary><content type="html">&lt;h1 id="树">树&lt;/h1>
&lt;h2 id="一树的相关概念">一、树的相关概念&lt;/h2>
&lt;h3 id="1引入">1、引入&lt;/h3>
&lt;p>之前我们所提到的数组也好、链表也罢，其实都是一对一的线性结构，但是在日常生活当中还存在许多一对多的非线性结构 —— “树”。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>树（Tree）&lt;/strong> ：是n （n≥0）个结点的有限集。n=0时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根，root的结点；（2）当 n&amp;gt;1时，其余结点可分为m（m&amp;gt;0）个互相不相交的有限集T1、T2……Tm,其中每一个集合本身又是一棵树，并且称为根的子树。&lt;/p>
&lt;/blockquote>
&lt;p>如下图所示：&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/AboutTree01.png?raw=true" alt="Tree01">&lt;/p>
&lt;h3 id="2树的结点">2、树的结点&lt;/h3>
&lt;p>结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，上图中，数据元素 A 就是一个结点；&lt;/p>
&lt;p>父结点（双亲结点）、子结点和兄弟结点：对于上图中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。&lt;/p>
&lt;p>树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。上图中，结点A就是整棵树的根结点。&lt;/p>
&lt;p>树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。&lt;/p>
&lt;p>叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。例如上图中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。&lt;/p>
&lt;h3 id="3子树和空树">3、子树和空树&lt;/h3>
&lt;p>子树：如上图中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且结点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。&lt;/p>
&lt;blockquote>
&lt;p>注意：单个结点也是一棵树，只不过根结点就是它本身。上图中，结点 K、L、F 等都是树，且都是整棵树的子树。&lt;/p>
&lt;/blockquote>
&lt;p>知道了子树的概念后，树也可以这样定义：树是由根结点和若干棵子树构成的。&lt;/p>
&lt;p>空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。&lt;/p>
&lt;p>补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，上图中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。&lt;/p>
&lt;h3 id="4结点的度和层次">4、结点的度和层次&lt;/h3>
&lt;p>对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，上图中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。&lt;/p>
&lt;p>一棵树的度是树内各结点的度的最大值。上图表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。&lt;/p>
&lt;p>结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于上图来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。&lt;/p>
&lt;p>一棵树的深度（高度）是树中结点所在的最大的层次。上图树的深度为 4。&lt;/p>
&lt;p>如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，上图中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。&lt;/p>
&lt;h3 id="5有序树和无序树">5、有序树和无序树&lt;/h3>
&lt;p>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。&lt;/p>
&lt;p>在有序树中，一个结点最左边的子树称为&amp;quot;第一个孩子&amp;quot;，最右边的称为&amp;quot;最后一个孩子&amp;quot;。&lt;/p>
&lt;p>拿上图来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。&lt;/p>
&lt;h3 id="6森林">6、森林&lt;/h3>
&lt;p>由 m（m &amp;gt;= 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。&lt;/p>
&lt;p>前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：&lt;/p>
&lt;p>Tree =（root,F）&lt;/p>
&lt;p>其中，root 表示树的根结点，F 表示由 m（m &amp;gt;= 0）棵树组成的森林。&lt;/p>
&lt;hr>
&lt;h2 id="二二叉树">二、二叉树&lt;/h2>
&lt;p>在上文，我们简单的了解了一下关于树的基本内容，那么在以上的概念继续细化，也就得到了二叉树。&lt;/p>
&lt;blockquote>
&lt;pre>&lt;code>简单地理解，满足以下两个条件的树就是二叉树：
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>本身是有序树；&lt;/li>
&lt;li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>例如，下图a) 就是一棵二叉树，而图 b) 则不是。&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/AboutTree02.gif?raw=true" alt="AboutTree02">&lt;/p>
&lt;h3 id="2二叉树的性质">2、二叉树的性质&lt;/h3>
&lt;p>经过前人的总结，二叉树具有以下几个性质：&lt;/p>
&lt;ol>
&lt;li>二叉树中，第 i 层最多有 2i-1 个结点。&lt;/li>
&lt;li>如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。&lt;/li>
&lt;li>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;pre>&lt;code>性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。
同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2*n2+1。
两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h3 id="3满二叉树">3、满二叉树&lt;/h3>
&lt;p>二叉树还可以继续分类，衍生出满二叉树和完全二叉树。&lt;/p>
&lt;blockquote>
&lt;p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/AboutTree03.gif?raw=true" alt="AboutTree03">&lt;/p>
&lt;p>满二叉树除了满足普通二叉树的性质，还具有以下性质：&lt;/p>
&lt;ol>
&lt;li>满二叉树中第 i 层的节点数为 2n-1 个。&lt;/li>
&lt;li>深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。&lt;/li>
&lt;li>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。&lt;/li>
&lt;li>具有 n 个节点的满二叉树的深度为 log2(n+1)。&lt;/li>
&lt;/ol>
&lt;h3 id="4完全二叉树">4、完全二叉树&lt;/h3>
&lt;blockquote>
&lt;p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/AboutTree04.gif?raw=true" alt="AboutTree04">&lt;/p>
&lt;p>上图 所示是一棵完全二叉树，图中由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。&lt;/p>
&lt;p>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。&lt;/p>
&lt;p>⌊ log2n ⌋ 表示取小于 log2n 的最大整数。例如，⌊log2 4⌋ = 2，而 ⌊log2 5⌋ 结果也是 2。&lt;/p>
&lt;p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：&lt;/p>
&lt;ol>
&lt;li>当 i&amp;gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）&lt;/li>
&lt;li>如果 2&lt;em>i&amp;gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2&lt;/em>i 。&lt;/li>
&lt;li>如果 2&lt;em>i+1&amp;gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2&lt;/em>i+1 。&lt;/li>
&lt;/ol>
&lt;h3 id="5总结">5、总结&lt;/h3>
&lt;p>本节介绍了什么是二叉树，以及二叉树的性质，同时还介绍了满二叉树和完全二叉树以及各自所特有的性质，初学者需理解并牢记这些性质，才能更熟练地使用二叉树解决实际问题。&lt;/p></content></entry><entry><title type="text">数据结构——哈希表</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/hashtab/"/><id>https://quakewang.github.io/tech/hashtab/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-18T21:32:54+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">哈希表 待更新…… 源码地址 ——&amp;gt; 哈希表</summary><content type="html">&lt;h1 id="哈希表">哈希表&lt;/h1>
&lt;p>待更新……&lt;/p>
&lt;p>源码地址 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/hashtab/HashTabDemo.java">哈希表&lt;/a>&lt;/p></content></entry><entry><title type="text">查找——斐波那契查找</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/fibonaccisearch/"/><id>https://quakewang.github.io/tech/fibonaccisearch/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-12T19:20:19+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">源码测试案例失败，求助大佬！！！ issue ——&amp;gt; 斐波那契查找</summary><content type="html">&lt;p>源码测试案例失败，求助大佬！！！&lt;/p>
&lt;p>issue ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/issues/1#issue-699311960">斐波那契查找&lt;/a>&lt;/p></content></entry><entry><title type="text">查找——插值查找</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/insertvaluesearch/"/><id>https://quakewang.github.io/tech/insertvaluesearch/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-10T09:13:35+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">插值查找 一、前言 1、问题引入 在了解过折半查找 之后，可能有些人会有些疑问，为什么选择的……</summary><content type="html">&lt;h1 id="插值查找">插值查找&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1问题引入">1、问题引入&lt;/h3>
&lt;p>在了解过&lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/search/BinarySearch.java">折半查找&lt;/a> 之后，可能有些人会有些疑问，为什么选择的是1/2，而不是 1/3 、1/4 呢？？或者说折更多呢？？&lt;/p>
&lt;p>举个例子，比如说我们在26个英文字母中寻找A，你还会选择折半么，从中间开始向左边部分进行递归？？还是直接从头开始查找、 在这种情况下，折半查找就显得不是那么的好用咯，还存在可以优化的地方。&lt;/p>
&lt;h3 id="2基本介绍">2、基本介绍&lt;/h3>
&lt;p>我们来看一下折半查找的中间值 &lt;code>mid = (left + right) / 2;&lt;/code> 通过我们小学一年级学过的数学知识，可以得出 =&amp;gt; &lt;code>mid = left + (right - left) / 2;&lt;/code> 也就是mid等于最底下标left加上最高下标right与left差的一半。然后再次利用小学一年级的知识，对于这个 1/2 进行优化，得出 &lt;code>mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);&lt;/code>&lt;/p>
&lt;p>将 1/2 改成 (findVal - arr[left]) / (arr[right] - arr[left]) 有什么好处呢？？假设arr[10] = {1, 2, 3, 4 ,5 6, 7, 8, 9}，则left = 0、right = 8、arr[left] = 1、arr[right] = 9。需要查找关键字1，代入上述公式可得 mid = 0，那么就说明只需要一次，感兴趣的可以自己使用折半查找计算一下， 从而可以发现在这种情况下，还是插值查找好使。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>插值查找：&lt;/strong> 是根据要查找的关键字findVal与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的计算公式 (findVal - arr[left]) / (arr[right] - arr[left])。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 说明：差债查找算法，也要求数组是有序的
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param arr 数组
&lt;/span>&lt;span class="cm"> * @param left 左边索引
&lt;/span>&lt;span class="cm"> * @param right 右边索引
&lt;/span>&lt;span class="cm"> * @param findVal 查找值
&lt;/span>&lt;span class="cm"> * @return 如果找到，就返回对应的下标，如果没有找到就返回-1
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">insertValueSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//注意：findVal &amp;lt; arr[0] 和 findVal &amp;gt; arr[arr.length - 1]必须需要，否则得到的mid可能会越界
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 求出mid
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">midVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">midVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">insertValueSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">midVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">insertValueSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>插值查找一般适用于表长较大的，而且关键字分布又比较均匀的查找表来说，插值查找算法的平均性能是优于折半查找的，但如果是表长较小的情况、或者关键字分布不均与的情况，再使用插值查找或许就不是那么合适的了。&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/search/InsertValueSearch.java">插值查找&lt;/a>&lt;/p></content></entry><entry><title type="text">查找——折半查找</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/binarysearch/"/><id>https://quakewang.github.io/tech/binarysearch/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-08T10:58:26+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">折半查找 一、前言 1、基本介绍 折半查找（BinarySearch）： 又称二分查找。它的……</summary><content type="html">&lt;h1 id="折半查找">折半查找&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1基本介绍">1、基本介绍&lt;/h3>
&lt;p>&lt;strong>折半查找（BinarySearch）：&lt;/strong> 又称二分查找。它的前提是线性表的记录必须是关键码有效（通常从小到大有序），线性表必须采用顺序存储。&lt;/p>
&lt;p>&lt;strong>基本思想&lt;/strong> ：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。&lt;/p>
&lt;h3 id="2举栗子">2、举栗子&lt;/h3>
&lt;p>现在有一个有序数组 {1，8，10，89，100，123}，假设我们需要寻找数字8这个数，步骤如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先确定该数组的中间值的下标，即 mid = (left + right) / 2;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后让需要查找的数findVal和arr[mid]比较；&lt;/p>
&lt;ul>
&lt;li>1）findVal &amp;gt; arr[mid] 说明要查找的数在mid的右边，因此需要递归的向右查找；&lt;/li>
&lt;li>2）findVal &amp;lt; arr[mid] 说明要查找的数在mid的左边，因此需要递归的向左查找；&lt;/li>
&lt;li>3）findVal == arr[mid] 说明找到，就返回下标&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/binarySearch.png?raw=true" alt="binarysearch">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="3思考">3、思考&lt;/h3>
&lt;p>什么时候需要结束递归呢？？&lt;/p>
&lt;ul>
&lt;li>找到就结束递归；&lt;/li>
&lt;li>遍历完整个数组，仍然没有找到findVal，也需要结束递归，结束条件为： 左边的索引 大于 右边的索引，即 &lt;strong>left &amp;gt; right&lt;/strong> 。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1非递归实现">1、非递归实现&lt;/h3>
&lt;p>折半查找既可以使用递归，也可以使用非递归来实现，这里我们先来了解一下非递归。left表示左边的索引，初始位置为数组的第一个元素；right表示右边的索引，初始位置为数组的最后一个元素。然后利用while循环进行遍历。当左边的索引大于右边的索引的时候，表示查找结束，没有查找到关键字，则返回-1，否则，返回该元素所在的下标。&lt;/p>
&lt;p>中间值 mid初始值为 &lt;code>mid = (left + right) / 2;&lt;/code> 若查找值比中值小，则最高下标调整到中位下标小一位；若查找值比中值大，则最高下标调整到中位下标大一位；依次类推。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 非递归实现折半查找
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">binarySearch03&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">midVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">midVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">midVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2递归实现">2、递归实现&lt;/h3>
&lt;p>与非递归实现想类似，即根据关键字与中间值的大小，然后做出相应的判断，再分别向左或者向右进行递归。需要注意的是，要避免出现“死龟”的情况，也就是没有查找到所需要的关键字，但仍没有结束递归。因此，当左边的索引大于右边的索引时，即 &lt;code>left &amp;gt; right&lt;/code>表示递归完整个数组，需要结束递归。还有就是需要注意每次递归的起始位置的变化。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * @param arr 数组
&lt;/span>&lt;span class="cm"> * @param left 左边的索引
&lt;/span>&lt;span class="cm"> * @param right 右边的索引
&lt;/span>&lt;span class="cm"> * @param findVal 需要查找的值
&lt;/span>&lt;span class="cm"> * @return 如果找到就返回下标，如果没有找到，就返回-1
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">binarySearch01&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 当 left &amp;gt; right 时，说明递归完整个数组，但是没有找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">midVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">midVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 向右递归
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">binarySearch01&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">midVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 向左递归
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">binarySearch01&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3完善版折半查找">3、完善版折半查找&lt;/h3>
&lt;p>假设，需要查找的关键字，在数组中有多个相同数值时， 在上述两个方法中，都是查找到一个关键字就返回，如何才能够将所有的数值都查找到呢？？&lt;/p>
&lt;p>思路分析：&lt;/p>
&lt;ul>
&lt;li>当查找到mid索引值时，先不要立刻返回；&lt;/li>
&lt;li>向mid索引值的左边扫描，将所有满足元素的下标，加入到集合ArrayList；&lt;/li>
&lt;li>向mid索引值的右边扫描，将所有满足元素的下标，加入到集合ArrayList；&lt;/li>
&lt;li>最后将ArrayList返回即可。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">binarySearch02&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">midVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">binarySearch02&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">findVal&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">binarySearch02&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">resIndexList&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="c1">// 向mid索引值左边扫描，将所有满足元素的下标，加入到集合ArrayList中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 没有找到，退出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 否则，将temp放入到resIndexList中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">resIndexList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">--;&lt;/span>&lt;span class="c1">// temp左移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="n">resIndexList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 向mid索引值右边扫描，将所有满足元素的下标，加入到集合ArrayList中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">findVal&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">resIndexList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">++;&lt;/span>&lt;span class="c1">// temp右移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">resIndexList&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>折半查找的前提条件是需要有序顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。但是对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，就不建议使用咯。&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/search/BinarySearch.java">折半查找&lt;/a>&lt;/p></content></entry><entry><title type="text">查找——线性查找</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/seqsearch/"/><id>https://quakewang.github.io/tech/seqsearch/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-08T09:46:10+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">线性查找 一、前言 假设我们需要在一个毫无顺序摆放的书架上，寻找一本书。但是由于书籍并没……</summary><content type="html">&lt;h1 id="线性查找">线性查找&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>假设我们需要在一个毫无顺序摆放的书架上，寻找一本书。但是由于书籍并没有分类，因此我们要找书只能从头到尾一本一本的对照书名，进行查找，直到找到或者全部查找完为止。实际上，这一个过程就是我们今天所要讲的线性查找。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>线性查找（Sequential Search）&lt;/strong> ：又叫顺序查找，是最基本的查找技术，它的查找过程是：从表中第一个（ &lt;em>或最后一个&lt;/em> ）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果知道最后一个（ &lt;em>或第一个&lt;/em> ）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>线性查找较为简单，我们直接从数组的第一个元素依次开始遍历，然后与需要查找的关键字进行比较相同即可，如果比较成功，返回该元素所在的下标；否则，返回-1，表示遍历完也没有查找到该关键字。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 这里实现的线性查找是找到一个满足条件的值，就返回
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">seqSearch&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 线性查找是注意逐一比对，发现有相同值，就返回下标
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>阅读完代码，大致感觉上没有什么问题，但是呢，如果一个数组有多个相同的关键字呢，返回的就是第一个查找到的关键字，就结束了查找。 因此我们可以定义一个集合用于存放查找结果，然后遍历完整个数组即可。&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/search/SeqSearch.java">线性查找&lt;/a>&lt;/p></content></entry><entry><title type="text">排序——基数排序</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/radixsort/"/><id>https://quakewang.github.io/tech/radixsort/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-09-07T08:52:53+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">基数排序 一、前言 1、基本介绍 基数排序（radix sort）属于“分配式排序”（dis……</summary><content type="html">&lt;h1 id="基数排序">基数排序&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1基本介绍">1、基本介绍&lt;/h3>
&lt;ol>
&lt;li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort），顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用；&lt;/li>
&lt;li>基数排序是属于稳定性的排序，基数排序法的是效率高的 &lt;strong>稳定性&lt;/strong> 排序法；&lt;/li>
&lt;li>基数排序是桶排序的扩展；&lt;/li>
&lt;li>基数排序是1887年赫尔曼·何乐礼发明的。实现如下：将整数按位数切割成不同的数字，然后按每个对应的位数进行分别比较。&lt;/li>
&lt;/ol>
&lt;h3 id="2基本思想">2、基本思想&lt;/h3>
&lt;p>将所有待排序数值统一为同样数位长度（ &lt;em>以最高位为主，位数短的数前面补零&lt;/em> ），然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数组就变成一个有序序列。&lt;/p>
&lt;h3 id="3图文说明">3、图文说明&lt;/h3>
&lt;p>可能看到这里，大部分读者还是挺懵的，下面我们结合一个动态图来进行理解。&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/RadixSort.gif?raw=true" alt="RadixSort">&lt;/p>
&lt;p>因为这里所使用的数组元素都是两位数的，即个位和十位，首先先根据个位数的大小进行排序，依次放入对应的位置（ &lt;em>也就是我们所讲的桶&lt;/em> ），然后根据放入的位置取出，然后再根据十位数的大小进行存放，这个顺序也就是排序之后的顺序。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1得到最高位数">1、得到最高位数&lt;/h3>
&lt;p>根据基数排序的思想可知，是根据最大数的位数多少进行比较的，也就是说我们需要先找到最高位数，&lt;/p>
&lt;p>先假设最大数就是数组的第一个元素，然后使用for循环遍历整个数组，依次进行比较即可。然后再根据最大数，得到它是几位数，即可。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 得到数组中最大的数的位数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">max&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">// 假设第一位数就是最大数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">max&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 得到的最大数就是几位数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxLength&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">max&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2定义相关变量">2、定义相关变量&lt;/h3>
&lt;p>我们需要一个二维数组，来表示10个桶，每个桶就是一个一维数组。这10个桶分别表示从0~9 这十个数，大小为待排序数组的大小（ &lt;em>有可能会出现极端情况，即某个对应位数的数值是一样大的，就考虑取最大，也就是数组的大小&lt;/em> ）。&lt;code>int[][] bucket = new int[10][arr.length];&lt;/code>&lt;/p>
&lt;p>再定义一个一维数组来记录各个桶的每次放入数据的个数，&lt;code>int[] bucketElementsCounts = new int[10];&lt;/code>&lt;/p>
&lt;h3 id="3排序">3、排序&lt;/h3>
&lt;h4 id="放入对应的桶中">①放入对应的桶中&lt;/h4>
&lt;p>首先，我们要根据最大数的位数是多少进行排序，然后还要取出各个位数的对应的值，考虑使用for循环实现，同时增加一个变量n，表示步长，&lt;code>for(int i = 0, n = 1; i &amp;lt; maxLength; i++, n *= 10)&lt;/code> 再嵌套一个for循环用于取出元素，然后放入到对应的桶中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 取出每个元素对应位的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">digitOfElement&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">10&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 放入对应的桶中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bucket&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">digitOfElement&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">digitOfElement&lt;/span>&lt;span class="o">]]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">digitOfElement&lt;/span>&lt;span class="o">]++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>bucket[] 数组&lt;/strong> 表示的意思如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>比如：53和3 这两个数，所对应的就是&lt;code>bucket[3][2]&lt;/code>表示的意思就是 个位数字为3的桶中有两个数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其中digitOfElement对应的是3（个位数字），&lt;code>bucketElementCounts[digitOfElement]&lt;/code>用于记录对应桶中的个数&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="按照桶进行排序">②按照桶进行排序&lt;/h4>
&lt;p>根据一维数组的下标依次取出数据，放入到原来的数组，&lt;code>int index = 0;&lt;/code> 先定义一个index变量用作索引。然后依次遍历每个桶，如果桶中有数据，则取出放入到原数组中，注意index++，后移。每进行一轮操作之后，需要将bucketElementCounts[k]置空，以复用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">//一维数组的下标依次取出数据，放入到原来的数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">//遍历每一个桶，并将桶中的数据放入到原数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//如果桶中有数据，放入到原数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//循环该桶即第k个桶（第k个一维数组），放入
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//取出元素放入到arr
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bucket&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">index&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//第i+1轮处理后，需要将每个bucketElementCounts[k] = 0
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4完整版代码">4、完整版代码&lt;/h3>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 基数排序方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">radixSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 得到数组中最大的数的位数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">max&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">// 假设第一位数就是最大数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">max&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 得到的最大数就是几位数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxLength&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">max&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">// 定义一个二维数组，表示10个桶，每个桶就是一个一维数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> 说明：
&lt;/span>&lt;span class="cm"> 1、二维数组包含10个一维数组
&lt;/span>&lt;span class="cm"> 2、为了防止在放入数的时候，数据溢出，则每个一维数组（桶），大小定位arr.length
&lt;/span>&lt;span class="cm"> 3、基数排序是使用空间换时间的经典算法
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kt">int&lt;/span>&lt;span class="o">[][]&lt;/span> &lt;span class="n">bucket&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="c1">// 再定义一个一维数组来记录各个桶的每次放入的数据个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">bucketElementCounts&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">maxLength&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++,&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">10&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 针对各个元素的对应位进行排序处理，第一次是个位，第二次是十位，以此类推
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 取出每个元素对应位的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">digitOfElement&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">10&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 放入对应的桶中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 比如：53和3 这两个数，所对应的就是bucket[3][2] 表示的意思就是 个位数字为3的桶中有两个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 其中digitOfElement对应的是3（个位数字），bucketElementCounts[digitOfElement]用于记录对应桶中的个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bucket&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">digitOfElement&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">digitOfElement&lt;/span>&lt;span class="o">]]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">digitOfElement&lt;/span>&lt;span class="o">]++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//按照这个桶的顺序（一维数组的下标依次取出数据，放入到原来的数组）
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">//遍历每一个桶，并将桶中的数据放入到原数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//如果桶中有数据，放入到原数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//循环该桶即第k个桶（第k个一维数组），放入
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">];&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//取出元素放入到arr
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bucket&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">index&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//第i+1轮处理后，需要将每个bucketElementCounts[k] = 0
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">bucketElementCounts&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>到这里，关于排序也就告一段落了，从我们最熟悉的冒泡排序到利用空间换取时间的基数排序，毫无疑问是先驱们对于算法的思考，我们虽然很难再设计出一种新的、高效率的算法，但是却可以做到在原算法的基础上，并对其进行改进。大家一起加油！！！&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/sort/RadixSort.java">基数排序&lt;/a>&lt;/p></content></entry><entry><title type="text">排序——归并排序</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/mergesort/"/><id>https://quakewang.github.io/tech/mergesort/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-08-31T20:49:40+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">归并排序 一、前言 1、基本介绍 归并排序（MergeSort）是利用归并的思想实现的排序……</summary><content type="html">&lt;h1 id="归并排序">归并排序&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1基本介绍">1、基本介绍&lt;/h3>
&lt;p>归并排序（MergeSort）是利用归并的思想实现的排序方法，该算法采用经典的&lt;strong>分治（divide-and-conquer）策略&lt;/strong> （&lt;em>分治法将问题分（divide）成一些小的问题然后递归求解，而治（conquer）的阶段则将分的阶段得到的个答案“修补”在一起，即分而治之。&lt;/em>）&lt;/p>
&lt;p>将两个的有序数列合并成一个有序数列，我们称之为&amp;quot;&lt;strong>归并&lt;/strong>&amp;quot;。
归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括&amp;quot;&lt;strong>从上往下&lt;/strong>&amp;quot;和&amp;quot;&lt;strong>从下往上&lt;/strong>&amp;quot;2种方式。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>从下往上的归并排序&lt;/strong>：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>从上往下的归并排序&lt;/strong>：它与&amp;quot;从下往上&amp;quot;在排序上是反方向的。它基本包括3步：
① 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2;
② 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。
③ 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>如下图所示：&lt;/strong>
&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/mergesort01.png?raw=true" alt="归并排序示意图">&lt;/p>
&lt;h3 id="2具体操作">2、具体操作&lt;/h3>
&lt;p>归并算法的实质在于把一个复杂的序列进行分解从而可以局部击破，变得简单化，下面我们举栗子，进行操作一把。在把数组进行分割之后，紧接着要做的事情就是 &lt;strong>治&lt;/strong> ，这里我们取最后一步做图解，实际上的操作过程是每 &lt;strong>分&lt;/strong> 一次，就要进行 &lt;strong>治&lt;/strong> 的操作。&lt;/p>
&lt;h4 id="分合操作">①分合操作&lt;/h4>
&lt;p>我们假设有一个数组如下：&lt;code>int[] arr = {5,4,7,9,3,8,2,1};&lt;/code> 那么我们根据前面所了解的规则，对其进行&lt;strong>分&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/mergesort02.png?raw=true" alt="分+合">&lt;/p>
&lt;h4 id="治">②“治“&lt;/h4>
&lt;p>实现规则如下：首先把一个数组分成左右两个部分，然后还要有一个空的数组，用作中转。在左右数组的两个部分，两边各还需要一个指针，分别进行扫描待排序的原始数组。在扫描的同时，把左右两个部分得到的元素进行比较，哪个较小则移入中转数组（这里我们是升序，降序反之即可），然后被移入元素的数组的指针依次后移，进行比较。&lt;/p>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/mergesort03.png?raw=true" alt=""治"">&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>由具体的实现操作可知，我们需要两个方法，一个进行 &lt;strong>分+合&lt;/strong> 的操作，另一个进行 &lt;strong>治&lt;/strong> 的操作。&lt;/p>
&lt;h3 id="1治合并的方法">1、“治”（合并）的方法&lt;/h3>
&lt;p>该方法用于对被分割之后的数组进行排序的操作。&lt;/p>
&lt;h4 id="定义相关变量">①定义相关变量&lt;/h4>
&lt;p>首先我们需要有传入的变量：&lt;code>int[] arr&lt;/code> 待排序的原始数组； &lt;code>int rigth&lt;/code> 左边有序序列的初始索引； &lt;code>int right&lt;/code> 右边有序序列的初始索引；&lt;code>int mid&lt;/code> 中间索引；&lt;code>int[] temp&lt;/code> 做中转的数组；以上是我们需要通过方法体传入的变量。&lt;/p>
&lt;p>接下来对其相关变量进行初始化：&lt;code>int i = left;&lt;/code> 初始化i，左边有序序列的初始索引；&lt;code>int j = right;&lt;/code> 初始化j，右边有序序列的初始索引；&lt;code>int t = 0;&lt;/code> 指向temp数组的当前索引。&lt;/p>
&lt;h4 id="初步处理左右序列">②初步处理左右序列&lt;/h4>
&lt;p>步骤如下：先把左右两边（有序）的数据按照排序规则填充到temp数组，直到左右两边的有序序列，有一边处理完毕为止。&lt;/p>
&lt;p>所以我们可以利用while循环来实现。循环的条件是有只要有一边扫描完毕，即&lt;code>i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right&lt;/code> 。&lt;/p>
&lt;p>具体的填充规则为：如果左边有序序列的当前元素，小于等于右边有序序列的当前元素，则将左边的当前元素，填充到temp数组，然后指针后移，反之亦然，将右边有序序列的当前元素，填充到temp数组。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果左边的有序序列的当前元素，相遇小于右边有序序列的当前元素
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 即 将左边的当前元素，填充到temp数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 然后 t++ i++ 后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 反之，将右边有序序列的当前元素，填充到temp数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">j&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="填充剩余数据">③填充剩余数据&lt;/h4>
&lt;p>在上个步骤，我们了解到，只要有一边的数据全部处理完毕则结束循环，所以我们需要把剩余数据的一边的数据依次全部填充到temp。这时就需要对于左右两边分别进行扫描。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 处理左边有序序列的剩余数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 处理右边有序序列的剩余数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">j&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="拷贝数据">④拷贝数据&lt;/h4>
&lt;p>我们当前对于待排序数组的数据进行处理后，所有的数据都在temp数组中，我们还需要将其拷贝回原始的数组。这里我们需要注意的是：比昂不是每次都要拷贝所有！！！ 即每进行一次分治操作，就拷贝一次数据。&lt;/p>
&lt;p>从左到右，依次拷贝temp数组中的元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">tempLeft&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">tempLeft&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">tempLeft&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">tempLeft&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="完整版代码">⑤完整版代码&lt;/h4>
&lt;p>我们对于每一步进行可拆分说明，更有助于理解。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 合并的方法
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param arr 待排序的原始数组
&lt;/span>&lt;span class="cm"> * @param left 左边有序序列的初始索引
&lt;/span>&lt;span class="cm"> * @param right 右边有序序列的初始索引
&lt;/span>&lt;span class="cm"> * @param mid 中间索引
&lt;/span>&lt;span class="cm"> * @param temp 做中转的数组
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">merge&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 初始化i，左边有序序列的初始索引
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 初始化j，右边有序序列的初始索引
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向temp数组的当前索引
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> （一）
&lt;/span>&lt;span class="cm"> 先把左右两边（有序）的数据按照规则填充到temp数组
&lt;/span>&lt;span class="cm"> 直到左右两边的有序序列，有一边处理完毕为止。
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 即 将左边的当前元素，填充到temp数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 然后 t++ i++ 后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 反之，将右边有序序列的当前元素，填充到temp数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">j&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> （二）
&lt;/span>&lt;span class="cm"> 把有剩余数据的一边的数据依次全部填充到temp
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 处理左边有序序列的剩余数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 处理右边有序序列的剩余数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">j&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> （三）
&lt;/span>&lt;span class="cm"> 将temp数组的元素拷贝到arr
&lt;/span>&lt;span class="cm"> 注意：并不是每次都要拷贝所有！！！
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">tempLeft&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">tempLeft&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">tempLeft&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">tempLeft&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2分合的方法">2、分+合的方法&lt;/h3>
&lt;p>在编写完合并的方法之后，我们在此基础上进行分合操作。同样需要传入一些所需的相关变量如下：&lt;code>int[] arr&lt;/code> 待排序的原始数组； &lt;code>int rigth&lt;/code> 左边有序序列的初始索引； &lt;code>int right&lt;/code> 右边有序序列的初始索引；&lt;code>int[] temp&lt;/code> 做中转的数组；以上是我们需要通过方法体传入的变量。&lt;/p>
&lt;p>然后利用递归进行执行，执行的条件为&lt;code>left &amp;lt; right&lt;/code> 。分别向左右两个方向拆分，之后调用合并方法。需要注意的是每次拆分的左右指针的位置要选取正确。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 分+合的方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">mergeSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 中间索引
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 向左递归进行分解
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">mergeSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 向右递归进行分解
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">mergeSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 合并
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/sort/MergeSort.java">归并排序&lt;/a>&lt;/p></content></entry><entry><title type="text">排序——快速排序</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/quicksort/"/><id>https://quakewang.github.io/tech/quicksort/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-08-29T14:13:00+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">快速排序 一、前言 1、基本介绍 见名知意，就是一种很快的排序方法。快速排序是基于冒泡排序……</summary><content type="html">&lt;h1 id="快速排序">快速排序&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1基本介绍">1、基本介绍&lt;/h3>
&lt;p>见名知意，就是一种很快的排序方法。快速排序是基于&lt;a href="https://quakewang.github.io/tech/bubblesort/">冒泡排序&lt;/a>的升级，那是因为它们都属于交换排序类。即它也是通过不断比较和移动交换次数来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减少了总的比较次数和移动交换次数。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>基本思想：&lt;/strong> 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，&lt;strong>整个排序过程可以递归进行&lt;/strong>，以达到整个序列有序的目的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="2排序例图">2、排序例图&lt;/h3>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/QuickSort.png?raw=true" alt="快速排序">&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1定义基本变量">1、定义基本变量&lt;/h3>
&lt;p>首先，我们需要的有：传入待排序的数组&lt;code>int[] arr&lt;/code>、左索引&lt;code>int left&lt;/code>、右索引&lt;code>int right&lt;/code>。&lt;/p>
&lt;p>在方法体内，我们需要有左下标：&lt;code>int l = left;&lt;/code> 右下标：&lt;code>int r = right;&lt;/code> 中轴值：&lt;code>int pivot = arr[(left + right) / 2];&lt;/code> （&lt;em>这里我们默认中轴值的基准为位于数组中间的元素&lt;/em>） 最后还有一个临时变量&lt;code>int temp = 0;&lt;/code> 用于交换。&lt;/p>
&lt;h3 id="2初步分组">2、初步分组&lt;/h3>
&lt;p>这里我们利用&lt;strong>while&lt;/strong>循环来说完成分组的规则，即把数组根据所选基准pivot的大小分成两个部分。while循环的条件为：&lt;strong>左下标小于右小标&lt;/strong> 即&lt;code>l &amp;lt; r&lt;/code>。&lt;/p>
&lt;h4 id="遍历左部分">①遍历左部分&lt;/h4>
&lt;p>我们需要在pivot的左边部分一直寻找，直到找到一个元素的数值大于等于pivot值，才退出。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">while&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">l&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>左下标的起始位置为：数组的第一个元素，所以每遍历一个元素需要后移一位。&lt;/p>
&lt;h4 id="遍历右部分">②遍历右部分&lt;/h4>
&lt;p>这时，需要在pivot的右边部分一直寻找，直到找到一个元素的数值小于等于pivot值，才退出。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">while&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">r&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>右下标的起始位置为：数组的最后一个元素，即&lt;code>arr.length - 1&lt;/code> ，所以每遍历一个元素需要前移一位。&lt;/p>
&lt;h4 id="结束循环">③结束循环&lt;/h4>
&lt;p>如果 &lt;code>l &amp;gt;= r&lt;/code> 说明pivot左边的值，已经全部是小于等于pivot值，右边全部是大于等于pivot值，这时需要结束循环。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">if&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="交换">④交换&lt;/h4>
&lt;p>当完成②③的遍历的时候，分别在pivot左右两个部分找到了符合要求的元素，则可以开始执行交换，从而使得每个元素归位于所适合的位置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 交换
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3防止溢出">3、防止溢出&lt;/h3>
&lt;p>当我们完成交换的规则之后，接下来就需要保证防止出现栈溢出的情况，这一步也是为了在后面步骤进行左右递归做好前提条件，是必不可少的一步。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 如果 l == r ， 必须l++、r--，否则会出现栈溢出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">l&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">r&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4递归">4、递归&lt;/h3>
&lt;p>在完成上述所有的操作之后，下一步就是进行递归操作。这里需要注意的就是进行左右递归的条件以及起始位置是不同的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 向左递归
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">quickSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 向右递归
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">quickSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="5完整版代码">5、完整版代码&lt;/h3>
&lt;p>因为整个快速排序流程较为复杂，所以对于方法体中的代码进行了拆分讲解，以下是快速排序方法体中的完整代码：&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 快速排序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">quickSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 左下标
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 右下标
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">pivot&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">// 中轴值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 临时变量
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// while循环的目的是让比pivot值小放到左边，比pivot值大放到右边
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 在pivot的左边一直找，找到大于等于pivot值，才退出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">l&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 在pivot的右边一直找，找到小于等于pivot值，才退出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">r&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 如果 l &amp;gt;= r 说明pivot左边的值，已经全部是小于等于pivot值，右边全部是大于等于pivot值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 交换
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 如果交换完后，发现 arr[l] == pivot值相等，r-- 前移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">r&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 如果交换完后，发现arr[r] == pivot值相等，l++ 后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">l&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 如果 l == r ， 必须l++、r--，否则会出现栈溢出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">l&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">r&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 向左递归
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">quickSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 向右递归
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">quickSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/sort/QuickSort.java">快速排序&lt;/a>&lt;/p></content></entry><entry><title type="text">排序——希尔排序</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/shellsort/"/><id>https://quakewang.github.io/tech/shellsort/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-08-22T20:19:43+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">希尔排序 一、前言 1、简单插入排序存在的问题 我们看简单的插入排序可能存在的问题，如下：……</summary><content type="html">&lt;h1 id="希尔排序">希尔排序&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1简单插入排序存在的问题">1、简单插入排序存在的问题&lt;/h3>
&lt;p>我们看简单的插入排序可能存在的问题，如下：&lt;/p>
&lt;p>数组 &lt;code>int[] arr = {2,3,4,1}&lt;/code> 这时需要插入的数1（最小），这样的过程是：&lt;/p>
&lt;p>{2,3,4,4} ——&amp;gt; {2,3,3,4} ——&amp;gt; {2,2,3,4} ——&amp;gt; {1,2,3,4}&lt;/p>
&lt;p>所以我们可以得出如下结论：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。&lt;/p>
&lt;h3 id="2基本介绍">2、基本介绍&lt;/h3>
&lt;p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n^2）的第一批算法之一。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>基本思想：&lt;/strong> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。&lt;/p>
&lt;/blockquote>
&lt;p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。&lt;/p>
&lt;p>我们来看下希尔排序的基本步骤，在此我们选择增量&lt;strong>gap=length/2&lt;/strong>，缩小增量继续以&lt;strong>gap = gap/2&lt;/strong> 的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为&lt;strong>增量序列&lt;/strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。&lt;/p>
&lt;h3 id="3举栗子">3、举栗子&lt;/h3>
&lt;p>&lt;img src="https://github.com/QuakeWang/quakewang.github.io/blob/master/content/imag/shellsort.png?raw=true" alt="希尔排序">&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>希尔排序的实质是对于直接插入排序进行改进，所以我们分为&lt;strong>交换法&lt;/strong>和&lt;strong>移位法&lt;/strong>两种。&lt;/p>
&lt;h4 id="1交换法">1、交换法&lt;/h4>
&lt;p>希尔排序的精髓，也是其关键点就是 对于增量的选择。我们这里使用&lt;strong>当前数组的一半&lt;/strong> 当作增量。&lt;code>for(int gap = arr.length / 2; gap &amp;gt; 0l; gap /= 2)&lt;/code> 这样就对待排序的数组按照增量大小进行了分类。&lt;/p>
&lt;blockquote>
&lt;p>将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。&lt;/p>
&lt;/blockquote>
&lt;p>选择好增量之后，需要做的就是对分好组之后的数组进行排序。交换法在这里进出处理使用的是双层for循环，外层循环用于遍历数组。内层循环根据增量大小，逐一对数组中的元素进行比较，从而进行排序。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 希尔排序，对有序序列在插入时直接使用交换法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">shellSort01&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 用于交换
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 第一层循环，将待排序数组进行分组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">gap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">gap&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">gap&lt;/span> &lt;span class="o">/=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 第二层排序，从第gap个元素，逐个对其所在组进行直接插入排序操作
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 第三层循环，遍历各组中所有的元素（共gap组），步长为gap
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果当前元素大于加上步长后的那个元素，说明交换
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过阅读代码，我们不难发现，利用交换法实现希尔排序中使用了三层for循环，那是因为我们每发现一组增量就进行交换，这样下来，自然而然执行效率就低咯。针对出现的问题，做出优化，也就是接下来的移位法。（效率大幅度提升！！！）&lt;/p>
&lt;h3 id="2移位法">2、移位法&lt;/h3>
&lt;p>移位法的第一步也还是得首先确立增量，这也就是为什么说增量是希尔排序的精髓所在的原因。然后执行的操作就是直接插入排序的操作。&lt;/p>
&lt;p>注意：与之前提到的直接插入排序不同的在于，其移动的位置是根据增量大小而移动的，也就是gap。当退出while循环后，也就给待插入的元素找到指定位置，插入即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 对交换式的希尔排序进行优化 ——&amp;gt; 移位法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">shellSort02&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 增量gap，并逐步的缩小增量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">gap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">gap&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">gap&lt;/span> &lt;span class="o">/=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 从第gap的个元素，逐个对其所在的组进行直接插入排序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">gap&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 移动
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">j&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">gap&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 当退出while后，就给temp找到插入的位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h3 id="3结束语">3、结束语&lt;/h3>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/sort/ShellSort.java">希尔排序&lt;/a>&lt;/p></content></entry><entry><title type="text">排序——直接插入排序</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/insertsort/"/><id>https://quakewang.github.io/tech/insertsort/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-08-20T17:04:38+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">直接插入排序 一、前言 1、基本介绍 想必我们大家都玩过或者了解过斗地主，最基本的扑克玩法……</summary><content type="html">&lt;h1 id="直接插入排序">直接插入排序&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1基本介绍">1、基本介绍&lt;/h3>
&lt;p>想必我们大家都玩过或者了解过斗地主，最基本的扑克玩法都是一边摸牌，一边理牌的。我们可以思考一下，理牌的顺序，是不是把大的牌直接插入在小的牌后面的呢？？例如有以下几张牌（不考虑花色）：6、4、5、3 。将4和5移动到6的左侧，再将3移动到最左侧，顺序就算是整理好了。这里我们所使用到的理牌方法就是&lt;strong>直接插入排序&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。&lt;/p>
&lt;/blockquote>
&lt;p>插入排序的&lt;strong>基本思想&lt;/strong>：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中含有 n - 1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序吗进行比较，将它插入到有序表中的适当的位置，使之成为新的有序表。&lt;/p>
&lt;h3 id="2举栗子">2、举栗子&lt;/h3>
&lt;p>下面以数列{101,34,119,1}为例，&lt;/p>
&lt;p>排序流程：&lt;/p>
&lt;p>第1轮：i=0。交换34和101的位置， 34,101,119,1；&lt;/p>
&lt;p>第2轮：i=1。因为119比101数值大，所以该趟不做任何处理；&lt;/p>
&lt;p>第3轮：i=3。1依次与有序表中的数进行比较，直到找到合适的位置为止，也就是最终的顺序，1,34,101,119；&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>因为我们使用一个有序表和一个无序表进行排序，所以默认数组的第一个元素为有序表，也就是&lt;strong>for循环&lt;/strong> 的其实位置，&lt;code>for(int i = 1; i &amp;lt; arr.length; i++)&lt;/code> 所有的排序过程都需要在当前这个for循环中完成。此外，我们还需要定义&lt;code>int insertVal = arr[i];&lt;/code> 表示为待插入的数；&lt;code>int insertIndex = i - 1;&lt;/code> 即待插入数的前面的这个数值的下标。&lt;/p>
&lt;p>接下来，我们使用&lt;strong>while循环&lt;/strong> 给insertVal找到插入的位置。在执行循环的过程中，既要保证给insertVal找插入位置时，&lt;strong>不越界&lt;/strong> ；&lt;code>insertVal &amp;gt; 0&lt;/code>又要确保找到&lt;strong>合适的插入位置&lt;/strong> &lt;code>insertVal &amp;lt; arr[insertIndex]&lt;/code> 。然后将&lt;strong>arr[insertVal] 后移&lt;/strong>，因为已将待插入的数arr[i] 保存到临时变量insertVal中，所以后移过程中不会覆盖，比如将举栗子的数列进行第一轮后移变成：{101,101,119,1}。然后再将&lt;code>insertIndex--;&lt;/code> 如此可以保证有效地执行while循环。&lt;/p>
&lt;p>当退出while循环时，说明插入的位置找到，即 &lt;strong>insertIndex + 1&lt;/strong>。然后需要做出判断是否需要赋值，即这个位置是否等于待插入数的下标，使用if选择语句即可完成。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 直接插入排序
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">insertSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">insertVal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">// 定义待插入的数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">insertIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 即arr[i]的前面的这个数的下标
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> 给insertVal找到插入的位置
&lt;/span>&lt;span class="cm"> 说明：
&lt;/span>&lt;span class="cm"> 1、insertIndex &amp;gt;= 0 保证在给insertVal找插入位置，不越界
&lt;/span>&lt;span class="cm"> 2、insertVal &amp;lt; arr[insertIndex] 待插入的数，还没有找到插入位置
&lt;/span>&lt;span class="cm"> 3、需要将arr[insertIndex] 后移
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">insertIndex&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">insertVal&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">insertIndex&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">insertIndex&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">insertIndex&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">insertIndex&lt;/span>&lt;span class="o">--;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//当退出while循环时，说明插入的位置找到，insertIndex + 1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//判断是否需要赋值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">insertIndex&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">insertIndex&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">insertVal&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>&lt;strong>直接插入排序时间复杂度&lt;/strong>：直接插入排序的时间复杂度是&lt;strong>O(n^2)&lt;/strong>。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(n)，需要遍历多少次呢？N-1！因此，直接插入排序的时间复杂度是O(n^2)。&lt;/p>
&lt;p>&lt;strong>直接插入排序稳定性&lt;/strong>:直接插入排序是稳定的算法，它满足稳定算法的定义。算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/sort/SelectSort.java">直接插入排序&lt;/a>&lt;/p></content></entry><entry><title type="text">排序——选择排序</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/selectsort/"/><id>https://quakewang.github.io/tech/selectsort/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-08-18T17:03:46+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">选择排序 一、前言 1、基本介绍 选择排序（Selection sort）是一种简单直观的排……</summary><content type="html">&lt;h1 id="选择排序">选择排序&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1基本介绍">1、基本介绍&lt;/h3>
&lt;p>选择排序（Selection sort）是一种简单直观的排序算法。它的基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p>
&lt;h3 id="2举栗子">2、举栗子&lt;/h3>
&lt;p>下面以数列{20,40,30,10,60,50}为例，&lt;/p>
&lt;p>排序流程：&lt;/p>
&lt;p>第1轮：i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化：20,40,30,10,60,50 -- &amp;gt; 10,40,30,20,60,50；&lt;/p>
&lt;p>第2轮：i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化：10,40,30,20,60,50 -- &amp;gt; 10,20,30,40,60,50；&lt;/p>
&lt;p>第3轮：i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理；&lt;/p>
&lt;p>第4轮：i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理；&lt;/p>
&lt;p>第5轮：i=4。交换a[4]和a[5]的数据。 数列变化：10,20,30,40,60,50 -- &amp;gt; 10,20,30,40,50,60&lt;/p>
&lt;h3 id="3说明">3、说明&lt;/h3>
&lt;ul>
&lt;li>选择排序一共有 &lt;strong>数组大小 - 1&lt;/strong> 轮排序&lt;/li>
&lt;li>每一轮排序，又是一个循环，循环的规则：
&lt;ul>
&lt;li>先假定当前这个数是最小数&lt;/li>
&lt;li>然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标&lt;/li>
&lt;li>当遍历到数组的最后时，就得到本轮最小数和下标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>选择排序和&lt;a href="https://quakewang.github.io/tech/bubblesort/">冒泡排序&lt;/a>一样，使用双重for循环进行实现。&lt;/p>
&lt;p>外层循环 &lt;code>for(int i = 0; i &amp;lt; arr.length; i++)&lt;/code> 用于确定排序的轮数，同时确定相关变量 &lt;code>minIndex = i;&lt;/code> 最小值的下标，以及 最小值 &lt;code>min = arr[i];&lt;/code> 。然后定义内层循环 &lt;code>for(int j = i + 1; j &amp;lt; arr.length; j++)&lt;/code> 注意内层循环的起始位置是从&lt;strong>i + 1&lt;/strong> 开始的（每执行完一轮排序，就确立一个最小值）。这时，在内层循环要筛选出最小值。当执行完内层循环之后，需要判断当前最小值的位置，是否在已排序数列的最后的位置。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">selectSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">minIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">min&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">min&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 说明假定的最小值不是最小
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">min&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">// 重置min
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">minIndex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 重置minIndex
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 将最小值，放在arr[i]，即交换
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">minIndex&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">minIndex&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">min&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况。其比较次数都是一样的多，第i趟排序需要进行 n - i 次关键字的比较，此时需要比较 n * (n - 1) / 2 次。而对于交换次数而言，当最好的时候，交换次数为0次，当最差的时候，也就初始降序的时候，交换次数为 n - 1 次，基于最终的排序时间是比较与交换次数的总和，因此，总的时间复杂度依然为O(n^2)。&lt;/p>
&lt;p>应该说，尽管与冒泡排序同为O(n^2) ，但简单选择排序的性能是要略优于冒泡排序。&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/sort/SelectSort.java">选择排序&lt;/a>&lt;/p></content></entry><entry><title type="text">排序——冒泡排序</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/bubblesort/"/><id>https://quakewang.github.io/tech/bubblesort/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-08-12T16:54:54+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">冒泡排序 一、前言 回想起来，当时一开始接触编程的时候，在学完循环和数组之后，老师便给我……</summary><content type="html">&lt;h1 id="冒泡排序">冒泡排序&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>回想起来，当时一开始接触编程的时候，在学完循环和数组之后，老师便给我们讲解了&lt;strong>冒泡排序&lt;/strong> ，老师还开玩笑说这种排序的算法最简单，相对而言也最容易理解。但对于当时的我们来说听得还是云里雾里的。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>冒泡排序（Bubble Sort）&lt;/strong> 一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。&lt;/p>
&lt;/blockquote>
&lt;p>因为排序的过程（如果相邻的元素逆序就交换）就像是水中的气泡一样往上冒，因此得名叫做冒泡排序。下面举一个简单的栗子：&lt;/p>
&lt;p>原始数组：3，9，-1，10，20&lt;/p>
&lt;ul>
&lt;li>第一趟排序：&lt;/li>
&lt;/ul>
&lt;p>1）3，9，-1，10，20 // &lt;em>3和9比较，3比9小，位置不变&lt;/em>&lt;/p>
&lt;p>2）3，-1，9，10，20 // &lt;em>9和-1比较，发现逆序，交换位置&lt;/em>&lt;/p>
&lt;p>3）3，-1，9，10，20 // &lt;em>9和10比较，位置不变&lt;/em>&lt;/p>
&lt;p>4）3，-1，9，10，&lt;strong>20&lt;/strong> // &lt;em>10和20比较，从而确定第一趟排序下来最大的数20&lt;/em>&lt;/p>
&lt;ul>
&lt;li>第二趟排序：&lt;/li>
&lt;/ul>
&lt;p>1）-1，3，9，10，&lt;strong>20&lt;/strong> // &lt;em>3和-1比较，发现逆序，交换位置&lt;/em>&lt;/p>
&lt;p>2）-1，3，9，10，&lt;strong>20&lt;/strong> // &lt;em>3和9比较，位置不变&lt;/em>&lt;/p>
&lt;p>3）-1，3，9，&lt;strong>10&lt;/strong>，&lt;strong>20&lt;/strong> // &lt;em>9和10比较，从而确定第二趟排序下来最大的数10&lt;/em>&lt;/p>
&lt;ul>
&lt;li>第三趟排序：&lt;/li>
&lt;/ul>
&lt;p>1）-1，3，9，&lt;strong>10&lt;/strong>，&lt;strong>20&lt;/strong> // &lt;em>-1和3比较，位置不变&lt;/em>&lt;/p>
&lt;p>2）-1，3，&lt;strong>9&lt;/strong>，&lt;strong>10&lt;/strong>，&lt;strong>20&lt;/strong> // &lt;em>3和9比较，从而确定第三趟排序下来最大的数9&lt;/em>&lt;/p>
&lt;ul>
&lt;li>第四趟排序：&lt;/li>
&lt;/ul>
&lt;p>1）-1，&lt;strong>3&lt;/strong>，&lt;strong>9&lt;/strong>，&lt;strong>10&lt;/strong>，&lt;strong>20&lt;/strong> // &lt;em>-1和3比较，从而确定第四趟排序下来最大的数3&lt;/em>&lt;/p>
&lt;p>&lt;strong>小结：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>一共进行 &lt;strong>数组的大小 - 1 次&lt;/strong> 大的循环；&lt;/li>
&lt;li>每一趟排序的次数在逐渐的减少。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1排序">1、排序&lt;/h3>
&lt;p>冒泡排序的算法实现，并不难理解，我们使用双重for循环遍历即可。只不过需要注意的是每一次循环时候的条件。外层循环 &lt;code>for(int i = 0; i &amp;lt; arr.length - 1; i++)&lt;/code> 表示的是&lt;strong>每一趟循环&lt;/strong>，所需要的次数就是&lt;em>数组大小-1&lt;/em> 。而内层循环 &lt;code>for(int j = 0; j &amp;lt; arr.length - i - 1; j++)&lt;/code> 表示的是每一趟需要排序的元素的的个数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 冒泡排序方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">bubbleSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 临时变量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2优化">2、优化&lt;/h3>
&lt;p>在使用冒泡排序的时候，我们不难发现，如果一串数字中有部分两两相邻的元素是顺序的，但是仍然执行 &lt;code>swap函数&lt;/code> 的操作，这样一来极大程度上降低了排序的效率。针对以上出现的情况，我们做出如下的优化：&lt;/p>
&lt;p>增加一个布尔类型的变量&lt;code>flag&lt;/code> 作为标识符，用于判断，当前的两两相邻的元素是否是按照顺序的，如果是就跳出，继续排查下一个元素，依次类推。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 冒泡排序方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">bubbleSort&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">boolean&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 标识符
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 临时变量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 在一趟排序中，一次交换都没有发生过
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 重置flag进行下次判断
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>以上便是关于冒泡排序的基本内容了。如果还有描述不清或者是无法理解的，可以适当画图结合debug进行调试，细心点，坚持下去，总会有结果的。&lt;/p>
&lt;p>分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以判断出就是 n - 1 次的比较。没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表示逆序的情况，此时需要比较 n*(n - 1) / 2 次，并作等数量级的记录移动。因此，总的时间复杂度为O(n^2)。&lt;/p>
&lt;p>源码 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/sort/BubbleSort.java">BubbleSort&lt;/a>&lt;/p></content></entry><entry><title type="text">递归应用——八皇后</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/8queen/"/><id>https://quakewang.github.io/tech/8queen/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-08-03T21:06:03+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">八皇后问题 一、前言 1、问题描述 八皇后问题（英文：Eight queens），是由国际西……</summary><content type="html">&lt;h1 id="八皇后问题">八皇后问题&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;h3 id="1问题描述">1、问题描述&lt;/h3>
&lt;p>&lt;strong>八皇后问题&lt;/strong>（英文：&lt;strong>Eight queens&lt;/strong>），是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出的问题，是&lt;a href="https://quakewang.github.io/tech/recursion/">递归回溯&lt;/a>的典型案例。&lt;/p>
&lt;blockquote>
&lt;p>问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以编程解决此问题。&lt;/p>
&lt;/blockquote>
&lt;h3 id="2思路分析">2、思路分析&lt;/h3>
&lt;p>我们的主要思路是通过一行一行的放置皇后，来使得每一行都有一个皇后。当然，这些皇后在放置时都必须要满足规定的要求才行。&lt;/p>
&lt;h4 id="因此就会出先如下情况">因此就会出先如下情况:&lt;/h4>
&lt;ul>
&lt;li>放置时不符合规则，继续检索同一行的下一列位置是否合理&lt;/li>
&lt;li>如果符合规则就将其放置，然后进行下一行的尝试（递归）&lt;/li>
&lt;li>如果有某一行没有可行的解，则退回上一行，消除上一行摆放的皇后，检索剩余的列，看是否有合理的位置，然后继续进行。(回溯)&lt;/li>
&lt;li>直到所有的行都被放置为止。&lt;/li>
&lt;/ul>
&lt;h4 id="具体操作">具体操作：&lt;/h4>
&lt;p>1)第一个皇后先放第一行第一列;&lt;/p>
&lt;p>2)第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适；&lt;/p>
&lt;p>3)继续第三个皇后，还是第一列、第二列......直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解；&lt;/p>
&lt;p>4)当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到；&lt;/p>
&lt;p>5)然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤。&lt;/p>
&lt;h4 id="注意条件">注意条件：&lt;/h4>
&lt;p>需要注意的是，我们在放置皇后时需要检测其防止和理性的判断条件为:&lt;/p>
&lt;ol>
&lt;li>同一列的上方所有行中是否有皇后&lt;/li>
&lt;li>左上方对角线上是否有皇后&lt;/li>
&lt;li>右上方对角线上是否有皇后&lt;/li>
&lt;/ol>
&lt;h4 id="说明">说明：&lt;/h4>
&lt;p>理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.&lt;code>arr[8]={0,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后，arr[i]=val,val表示第i+1个皇后，放在第i+1行的第val+1列&lt;/code>&lt;/p>
&lt;hr>
&lt;h3 id="二算法实现">二、算法实现&lt;/h3>
&lt;h3 id="1定义相关变量">1、定义相关变量&lt;/h3>
&lt;p>&lt;code>int max = 8;&lt;/code> 定义max变量用于表示有多少个皇后；&lt;/p>
&lt;p>&lt;code>int[] array = new int[max];&lt;/code> 定义数组array，保存皇后放置位置的结果。&lt;/p>
&lt;h3 id="2输出皇后位置">2、输出皇后位置&lt;/h3>
&lt;p>因为我们使用的是一维数组，所以直接遍历输出该数组即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 输出皇后摆放的位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">print&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">();&lt;/span>&lt;span class="c1">// 换行
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3检查冲突">3、检查冲突&lt;/h3>
&lt;p>该方法用于 查看放置第n个皇后，检测该皇后是否和前面已经摆放的皇后冲突。这里我们使用一个&lt;strong>boolean类型&lt;/strong> 的方法用于判定。如果不冲突就返回&lt;code>true&lt;/code> ，否则返回&lt;code>false&lt;/code> 。这里我们传入一个n表示是第几个皇后，如果n = 1，就表示是第一个皇后，需要检查的冲突也就是其本身；如果n = 2，表示是第二个皇后，需要检查的冲突是和第一个皇后的冲突，以此类推……所以可以使用for循环遍历，从第一个皇后开始，直到遍历到其本身为止。&lt;code>for(int i = 0; i &amp;lt; n; i++)&lt;/code>&lt;/p>
&lt;p>那么判断是否冲突需要遵守的规则是：同一行、列以及对角线不能有皇后。由于我们是使用一维数组来存储皇后摆放的位置，所以就不用判断放置的两个皇后是否在同一行的情况咯。&lt;code>array[i] == array[n]&lt;/code> 表示判断第n个皇后是否和前面的n-1个皇后在同一列；&lt;code>Math.abs(n-i) == Math.abs(array[n] - array[i])&lt;/code> 表示判断第n个皇后是否和第i个皇后在同一斜线。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * @param n 表示第n个皇后
&lt;/span>&lt;span class="cm"> * @return 如果不冲突返回true，否则返回false
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">judge&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm"> 说明：
&lt;/span>&lt;span class="cm"> 1、array[i] == array[n] 示判断第n个皇后是否和前面的n-1个皇后在同一列
&lt;/span>&lt;span class="cm"> 2、Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">abs&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">abs&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4放置皇后">4、放置皇后&lt;/h3>
&lt;p>我们传入一个变量n表示放置第n个皇后，当&lt;code>n == max&lt;/code> 表示8个皇后已经全部放置完毕，直接打印输出即可，并使用&lt;code>return;&lt;/code> 语句跳出方法体。&lt;/p>
&lt;p>然后我们利用for循环依次放入皇后&lt;code>for(int i = 0; i &amp;lt; max; i++)&lt;/code>，首先把当前的这个皇后n放入到第1列，然后判断是否冲突，如果不冲突执行&lt;code>check(n + 1);&lt;/code> 也就是开始放置下一个皇后；如果冲突，则就继续执行&lt;code>array[n] = i;&lt;/code>即将第n个皇后放置在本行的后移的一个位置。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 方法：放置第n个皇后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 特别注意：check是每一次递归时，进入到check中都有for(int i = 0; i &amp;lt; max; i++)，因此会有回溯
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// n = 8 时，表示8个皇后已经全部安放好
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">print&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 依次放入皇后，并判断是否冲突
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先把当前和这做个皇后n，放到该行的第1列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 判断当放置第n个皇后到i列时，是否冲突
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">judge&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 不冲突
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//如果冲突，就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>以上便是关于八皇后问题的简单描述，理解起来可能有些许困难，比如为什么使用一维数组存放数据，如何检查冲突以及整个放置过程中的回溯都是值得动脑筋思考的。&lt;/p>
&lt;p>源码 ——&amp;gt;&lt;a href="https://github.com/QuakeWang/DataStructure/blob/master/src/com/quake/recursion/Queen8.java">Queue8&lt;/a>&lt;/p></content></entry><entry><title type="text">递归——解决迷宫问题</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/migong/"/><id>https://quakewang.github.io/tech/migong/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-07-28T09:15:03+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">迷宫问题 一、前言 在上一篇博客中，我们了解了关于递归的一些基本知识，这次我们讲一下递归……</summary><content type="html">&lt;h1 id="迷宫问题">迷宫问题&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在上一篇博客中，我们了解了关于&lt;strong>递归&lt;/strong>的一些基本知识，这次我们讲一下递归的应用——走迷宫。&lt;/p>
&lt;p>我们利用二维数组构建一个迷宫，其中&lt;em>1表示墙，0表示可以的走的路，2表示走过的路。&lt;/em> 可以在迷宫中设置挡板，也用1表示。然后利用递归给小球找路。在走迷宫时，我们需要确定一个策略，不能盲目地瞎走，要不然岂不是在里面绕圈圈，哈哈哈哈。策略如下：&lt;strong>下-&amp;gt;右-&amp;gt;上-&amp;gt;左，如果该点走不通，再回溯&lt;/strong>。下面我们开始代码实现一把。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1创建迷宫">1、创建迷宫&lt;/h3>
&lt;p>我们先定义一个二维数组&lt;code>map&lt;/code> 表示地图。然后再分别将四周（上下左右）设置为墙。再在需要的位置设置挡板，增加出迷宫的难度。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 先创建一个二维数组，模拟迷宫
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[][]&lt;/span> &lt;span class="n">map&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">8&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">7&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="c1">// 使用1表示墙
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 将上下全部置为1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">7&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">7&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 将左右全部置为1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">8&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">6&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 设置挡板
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2递归找路">2、递归找路&lt;/h3>
&lt;p>这里我们使用递归&lt;code>setWay(int[][] map, int i, intj)&lt;/code>方法，来寻找路线。&lt;code>map&lt;/code> 表示地图、传入的&lt;code>i, j&lt;/code> 表示小球的起始位置；将终点设置为&lt;code>map[6][5]&lt;/code> （除去墙在地图中所占的位置）。如果小球你找到通路，就返回&lt;code>true&lt;/code> ，否则返回&lt;code>false&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * @param map 表示地图
&lt;/span>&lt;span class="cm"> * @param i 从哪个位置开始找
&lt;/span>&lt;span class="cm"> * @param j
&lt;/span>&lt;span class="cm"> * @return 如果找到通路，就返回true，否则返回false
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">setWay&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[][]&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">6&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 如果当前这点还没有走过
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 按照策略 下 -&amp;gt; 右 -&amp;gt; 上 -&amp;gt; 左 走
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 假定该点可以走通
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">setWay&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 向下走
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">setWay&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 向右走
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">setWay&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 向上走
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">setWay&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 向左走
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 说明该点是走不通，是死路
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 如果map[i][j] != 0 可能是1、2、3
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>对于迷宫的问题的描述就到这里，总体而言是比较简单的。具体的递归过程可以进行debug一下，更有助于理解。&lt;/p>
&lt;p>源码 ——&amp;gt;&lt;a href="https://github.com/QuakeWang/DataStructes/blob/master/src/com/quake/recursion/MiGong.java">MiGong&lt;/a>&lt;/p></content></entry><entry><title type="text">数据结构——递归</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/recursion/"/><id>https://quakewang.github.io/tech/recursion/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-07-26T10:59:35+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">关于递归 一、前言 说起递归，可能有些同学会问，什么是递归啊？？ 我们举个简单的栗子：如果……</summary><content type="html">&lt;h1 id="关于递归">关于递归&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>说起&lt;strong>递归&lt;/strong>，可能有些同学会问，什么是递归啊？？ 我们举个简单的栗子：如果你站在镜子前面，这时你会在镜子中看见自己的像，称这个镜子为A；那么有没有试一下在手里也拿一面镜子，把手里的镜子称为镜子B，然后将A、B两面镜子互相面对面放着，你再往中间那么一站，神奇的情况发生了，将会发现两面镜子中都有你的“化身”。为什么会出现这种现象呢？？原来，A镜子里有B镜子的像，B镜子里也有A镜子的像，这样反反复复，就会产生一连串的“像中像”。这其实就是一种&lt;strong>递归&lt;/strong>现象。&lt;/p>
&lt;p>说简单点，就是&lt;em>递归就是方法自己调用自己&lt;/em>，每次调用时&lt;em>传入不同的变量&lt;/em>。（递归有助于开发者解决复杂的问题，同时可以让代码变得更简洁）&lt;/p>
&lt;hr>
&lt;h2 id="二递归规则">二、递归规则&lt;/h2>
&lt;p>递归需要遵守的重要规则：&lt;/p>
&lt;p>1）执行一个方法时，就创建一个新的受保护的独立空间（栈空间）；&lt;/p>
&lt;p>2）方法的局部变量是独立的，不会相互影响，比如n变量；&lt;/p>
&lt;p>3）如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据；&lt;/p>
&lt;p>4）递归&lt;strong>必须向退出递归的条件逼近&lt;/strong>，否则就是无限递归，出现StackOverflowError，&lt;em>死龟了&lt;/em> : ) ；&lt;/p>
&lt;p>5）当一个方法执行完毕，或者遇到return，就会返回，&lt;strong>遵守谁调用，就将结果返回给谁&lt;/strong>，同时方法执行完毕或者返回时，该方法也就执行完毕了。&lt;/p>
&lt;hr>
&lt;h2 id="三斐波那契数列">三、斐波那契数列&lt;/h2>
&lt;h3 id="1概要">1、概要&lt;/h3>
&lt;p>**斐波那契数列（Fibonacci）**是一个典型的递归例子，说如果兔子在出生两个月之后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有的兔子都不死。那么，一年以后可以繁殖多少对兔子？？&lt;/p>
&lt;p>我们拿新出生的一对小兔子来分析一下：第一个月的小兔子是没有繁殖能力的，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月后，老兔子又生下一对，因为上个月出生的小兔子还没有繁殖能力，所以还是一共还是三对……依次类推，可以列出下表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>所经过的月数&lt;/th>
&lt;th>1&lt;/th>
&lt;th>2&lt;/th>
&lt;th>3&lt;/th>
&lt;th>4&lt;/th>
&lt;th>5&lt;/th>
&lt;th>6&lt;/th>
&lt;th>7&lt;/th>
&lt;th>8&lt;/th>
&lt;th>9&lt;/th>
&lt;th>10&lt;/th>
&lt;th>11&lt;/th>
&lt;th>12&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>兔子对数&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>2&lt;/td>
&lt;td>3&lt;/td>
&lt;td>5&lt;/td>
&lt;td>8&lt;/td>
&lt;td>13&lt;/td>
&lt;td>21&lt;/td>
&lt;td>34&lt;/td>
&lt;td>55&lt;/td>
&lt;td>89&lt;/td>
&lt;td>144&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>表中数字1,1,2,3,5,8,13……构成一个序列。这个数列有个明显的特点就是：&lt;strong>前面相邻两项之和，构成了后一项&lt;/strong>。&lt;/p>
&lt;h3 id="2常规解法">2、常规解法&lt;/h3>
&lt;p>先思考一下，如果我们要实现斐波那契数列用常规的&lt;em>迭代&lt;/em>方法应该如何实现？&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">13&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">a&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">a&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;未使用递归计算：&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;a[0] = &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;a[1] = &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">a&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;第%d个月兔子总数为：%d&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们来简单看一遍这段代码，&lt;strong>数组a[]&lt;strong>表示从&lt;em>第0月到第12月&lt;/em>，其中第0个月没有任何兔子，第一个月有一对兔子，然后我们利用for循环，从&lt;/strong>第2个月&lt;/strong>开始计算，即下一个月的兔子数为前两个月兔子数相加。&lt;/p>
&lt;p>代码很简单，几乎不用怎么解释，都可以理解，但其实，我们如果使用递归来实现，代码将会更加整洁。&lt;/p>
&lt;h3 id="3递归解法">3、递归解法&lt;/h3>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 使用递归计算
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;使用递归计算如下：&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;第%d个月兔子总数为：%d&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Fbi&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 使用递归的方法处理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">Fbi&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Fbi&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Fbi&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>虽然代码整体而言要简洁许多，但却并不是那么好理解。函数怎么可以自己调用自己？？听起来确实有些难以理解，不过我们可以不把一个递归函数中调用自己的函数看作是在调用自己，而就当它是在调用另一个函数。只不过，这个函数和自己长得一样而已。&lt;/p>
&lt;p>我们来模拟代码中的Fbi(i)函数当i = 5的执行过程。Fbi(5) = Fbi(4) + Fbi(3) = Fbi(3) + Fbi(2) + Fbi(2) + Fbi(1) = Fbi(2) + Fbi(1) + 1 + 1 + 1 = 1 + 1 + 1 + 1 + 1 = 5&lt;/p>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>我们来对比一下这两种实现斐波那契的代码。迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归可以使程序的结构更清晰、更简洁、更容易让人理解。从而有效地减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同的情况选择不同的代码实现方式。&lt;/p>
&lt;p>斐波那契数列源码地址 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructes/blob/master/src/com/quake/recursion/Fibonacci.java">Fibonacci&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>《大话数据结构》 ——程杰&lt;/p>
&lt;/blockquote></content></entry><entry><title type="text">栈的应用——后缀表达式02</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/polandnotation02/"/><id>https://quakewang.github.io/tech/polandnotation02/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-07-16T13:54:47+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">后缀表达式——代码讲解 一、前言 在上一篇博客中我们介绍了有关后缀表达式的有关知识，关于……</summary><content type="html">&lt;h1 id="后缀表达式代码讲解">后缀表达式——代码讲解&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在上一篇&lt;a href="https://quakewang.github.io/tech/polandnotation01/">博客中&lt;/a>我们介绍了有关后缀表达式的有关知识，关于如何将&lt;strong>中缀表达式&lt;/strong>转换为&lt;strong>后缀表达式&lt;/strong>，以及&lt;strong>后缀表达式的运算规则&lt;/strong>，做了详细的介绍。因此这篇博客将会用代码来实现一个完整的后缀表达式。&lt;/p>
&lt;hr>
&lt;h2 id="二算法描述">二、算法描述&lt;/h2>
&lt;h3 id="1将后缀表达式的数据和运算符放入到arraylist中">1、将后缀表达式的数据和运算符放入到ArrayList中&lt;/h3>
&lt;p>我们会获取到一个&lt;strong>String类型&lt;/strong>的后缀表达式，因为对于字符串类型是无法正常完成计算的，因此需要先将后缀表达式里面的数据和运算符按照空格&amp;quot; &amp;quot;分割开，然后存放到ArrayList中。&lt;/p>
&lt;p>这里会用到foreach遍历字符串，每遍历一个元素，再利用 &lt;strong>list.add()&lt;/strong> 方法加入到List中，然后返回List即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 依次将一个逆波兰表达式的数据和运算符放入到ArrayList中
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">getListString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">suffixExpression&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 将suffixExpression按照空格“ ”分开
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">split&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">suffixExpression&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">split&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">list&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">ele&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">split&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">list&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ele&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2后缀表达式的运算">2、后缀表达式的运算&lt;/h3>
&lt;p>关于运算规则，在上一篇博客中已经做过说明，所以这里就不做过多的赘述。我们通过&lt;strong>栈&lt;/strong>来存放扫描到的数字（&lt;em>这里使用正则表达式来判断是否是多位数&lt;/em>）。扫描表达式的时候如果遇见运算符，则分别取出栈顶元素和次顶元素，进行计算，并把运算结果再重新入栈。最后留在栈中的数就是该表达式最后的运算结果。&lt;em>需要注意的是：在进行减、除运算的时候，需要注意栈顶元素和次顶元素的位置&lt;/em>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">calculate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ls&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 创建一个栈（在这里只需要一个栈即可）
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;();&lt;/span>
&lt;span class="c1">// 遍历ls
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ls&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 使用正则表达式来取出数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">matches&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;\\d+&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 匹配的是多位数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// pop出两个数，并运算，再入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">parseInt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">parseInt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;+&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">num1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;-&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">num1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;*&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">num1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">num1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;输入的运算符有误！！！&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 把res入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">);&lt;/span>&lt;span class="c1">// 加上双引号即可转换为字符串形式
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 最后留在stack中的数据就是运算结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">parseInt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>通过上述两种方法，可以实现对于后缀表达式的直接运算。但后缀表达式是计算机容易理解，而相对于人而言，其转换过程是比较头疼的，所以接下来我们实现关于中缀表达式转换后缀表达式的方法。&lt;/p>
&lt;hr>
&lt;h3 id="3将中缀表达式转换成对应的list">3、将中缀表达式转换成对应的List&lt;/h3>
&lt;p>对于一个字符串，我们是无法进行操作的，所以首先要做的就是先把中缀表达式转成对应的List。&lt;/p>
&lt;p>需要的变量有： &lt;strong>ls(List)&lt;/strong> 用于存放扫描得到的元素； &lt;strong>i(int)&lt;/strong> 当作指针，用于扫描中缀表达式； &lt;strong>str(String)&lt;/strong> 用于多位数的拼接； &lt;strong>c(char)&lt;/strong> 每遍历一个字符，就放入到c。&lt;/p>
&lt;p>这里我们使用&lt;strong>do……while&lt;/strong>循环来进行遍历，循环的条件是&lt;strong>i &amp;lt; s.length()&lt;/strong>;扫描遇到的如果是操作符，直接加入即可；如果是数字，则每次添加的时候先将&lt;strong>str置空&lt;/strong>，然后利用&lt;strong>str += c&lt;/strong>拼接多位数。每次扫描到一个元素之后，指针i需要进行后移，可以利用ASCII码来判断数字的范围，然后进行相关操作。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 将中缀表达式转换成对应的List
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">toInfixExpressionList&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 定义一个List，存放在中缀表达式中对应的内容
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 这是一个指针，用于遍历中缀表达式字符串
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">str&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 用于多位数的拼接
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 每遍历一个字符，就放入到c
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果是一个非数字，就需要加入到ls
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">((&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">48&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">57&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ls&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++;&lt;/span>&lt;span class="c1">// i需要后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 如果是一个数，需要考虑多位数的情况
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 先将str置空“ ”
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">48&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">57&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">str&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">i&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">ls&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ls&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 返回
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4将中缀表达式对应的list转换成后缀表达式">4、将中缀表达式对应的List转换成后缀表达式&lt;/h3>
&lt;p>关于中缀表达式转换的规则，在之前也进行过相关的阐述，这里也就不再细说了，不过需要注意的是转换之后的后缀表达式对应的也是List。对于运算符符号操作的时候，我们需要比较运算符的优先级，所以定义一个类，用于返回运算符的优先级。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">// 编写一个类Operation
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Operation&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">ADD&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">SUB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MUL&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">DIV&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 编写一个方法，返回对应的优先级数字
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getValue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">operation&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">operation&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;+&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ADD&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;-&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SUB&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;*&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">MUL&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DIV&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;不存在该运算符&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">operation&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>具体操作代码如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">
&lt;span class="c1">// 将得到的中缀表达式对应的List转换成后缀表达式对应的List
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">parseSuffixExpressionList&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ls&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 定义一个栈，用于存放扫描所得到的符号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">s1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>&lt;span class="c1">// 符号栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 定义一个ArrayList用于存储中间的结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">s2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="c1">// 遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ls&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果是一个数，加入s2
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">matches&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;\\d+&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">s2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;(&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;)&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果是右括号&amp;#34;)&amp;#34;，则依次pop出s1栈顶的运算符，并加入s2，直到遇见左括号为止，此时将这一对括号丢弃
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;(&amp;#34;&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">s2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>&lt;span class="c1">// 将 ( 弹出s1栈，消除小括号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 当item的优先级小于或等于s1栈顶运算符，将s1栈顶的运算符弹出，并加入到s2中然后再与s1中新的栈顶运算符相比较
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">Operation&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getValue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">Operation&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getValue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">s2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 将s1中剩余的运算符依次弹出并加入到s2
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">s2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">s2&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 注意：因为是存放到List，因此按顺序输出就是对应后的后缀表达式对应的List
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>对于栈的应用，使用了&lt;em>中缀表达式&lt;/em>和&lt;em>后缀表达式&lt;/em>来进行说明，由此可见，想把数据结构学好还是得下一定功夫的，世界上没有随随便便的成功，一步一步踏踏实实地向前走。&lt;/p>
&lt;p>源码 —— &amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructes/blob/master/src/com/quake/stack/PolandNotation.java">PolandNotation&lt;/a>&lt;/p></content></entry><entry><title type="text">栈的应用——后缀表达式01</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/polandnotation01/"/><id>https://quakewang.github.io/tech/polandnotation01/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-07-15T08:31:49+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">后缀表达式——预备知识 一、前言 在上一篇博客中，我们介绍了中缀表达式的相关操作过程，虽……</summary><content type="html">&lt;h1 id="后缀表达式预备知识">后缀表达式——预备知识&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在上一篇博客中，我们介绍了&lt;a href="https://quakewang.github.io/tech/calculator/">中缀表达式&lt;/a>的相关操作过程，虽然中缀表达式比较符合我们的日常使用习惯，但是对于计算机却不那么容易去理解，因此有了我们今天要介绍的——后缀表达式。&lt;/p>
&lt;p>例如：( 3 +4 ) * 5 - 6 对应的后缀表达式就是3 4 + 5 * 6 -，那么这个操作过程是怎么实现的呢？？以及后缀表达式该如何进行运算呢？？在下面的内容，我们来一探究竟。&lt;/p>
&lt;hr>
&lt;h2 id="二中缀表达式转后缀表达式">二、中缀表达式转后缀表达式&lt;/h2>
&lt;h3 id="1规则">1、规则：&lt;/h3>
&lt;p>1）初始化一个运算符栈s1和一个用云储存中间结果的List s2；&lt;/p>
&lt;p>2）从左到右扫描中缀表达式；&lt;/p>
&lt;p>3）如果遇到操作数，直接加入到s2；&lt;/p>
&lt;p>4）如果遇到运算符，则比较其与s1栈顶元素的优先级：&lt;/p>
&lt;p>4.1）如果s1为空，或栈顶运算符为左括号&amp;quot;(&amp;quot;，则直接将此运算符入栈；&lt;/p>
&lt;p>4.2）若当前运算符比栈顶运算符的优先级高，也将此运算符入栈；&lt;/p>
&lt;p>4.3）否则，将s1栈顶的运算符弹出并加入到s2中，然后再回到4.1）与s1中新的栈顶运算符相比较；&lt;/p>
&lt;p>5）遇到括号时：&lt;/p>
&lt;p>5.1）如果是左括号&amp;quot;(&amp;quot;，则直接压入s1；&lt;/p>
&lt;p>5.2）如果是右括号&amp;quot;)&amp;quot;，则依次弹出s1栈顶的运算符，并加入s2，直到遇见左括号为止，此时将这一对括号丢弃；&lt;/p>
&lt;p>6）重复上述步骤 2）至 5），直到表达式的最右边；&lt;/p>
&lt;p>7）再将s1中剩余的运算符依次加入到s2；&lt;/p>
&lt;p>8）依次输出s2中的元素，输出结果就是相对应的后缀表达式。&lt;/p>
&lt;h3 id="2举例说明">2、举例说明&lt;/h3>
&lt;p>将中缀表达式&amp;quot;1+((2+3)*4)-5&amp;quot;转换为后缀表达式的过程如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>扫描到的元素&lt;/th>
&lt;th>s2（表头—&amp;gt;表尾）&lt;/th>
&lt;th>s1（栈底—&amp;gt;栈顶）&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>空&lt;/td>
&lt;td>数字，直接加入到s2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>1&lt;/td>
&lt;td>+&lt;/td>
&lt;td>s1为空，运算符直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(&lt;/td>
&lt;td>1&lt;/td>
&lt;td>+ (&lt;/td>
&lt;td>左括号直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>(&lt;/td>
&lt;td>1&lt;/td>
&lt;td>+ ( (&lt;/td>
&lt;td>左括号直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>1 2&lt;/td>
&lt;td>+ ( (&lt;/td>
&lt;td>数字，直接加入到s2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>1 2&lt;/td>
&lt;td>+ ( ( +&lt;/td>
&lt;td>s1栈顶为左括号，运算符直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>1 2 3&lt;/td>
&lt;td>+ ( ( +&lt;/td>
&lt;td>数字，直接加入到s2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>)&lt;/td>
&lt;td>1 2 3 +&lt;/td>
&lt;td>+ (&lt;/td>
&lt;td>右括号，弹出s1中的运算符，直至遇到左括号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;/td>
&lt;td>1 2 3 +&lt;/td>
&lt;td>+ ( *&lt;/td>
&lt;td>s1栈顶元素为左括号，运算符直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>1 2 3 + 4&lt;/td>
&lt;td>+ ( *&lt;/td>
&lt;td>数字，直接加入到s2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>)&lt;/td>
&lt;td>1 2 3 + 4 *&lt;/td>
&lt;td>+&lt;/td>
&lt;td>右括号，弹出s1中的运算符，直至遇到左括号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>1 2 3 + 4 * +&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-与＋优先级相同，因此弹出+，再压入-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>1 2 3 + 4 * + 5&lt;/td>
&lt;td>-&lt;/td>
&lt;td>数字，直接加入到s2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>到达最右端&lt;/td>
&lt;td>1 2 3 + 4 * + 5 -&lt;/td>
&lt;td>空&lt;/td>
&lt;td>s1中剩余的运算符&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="三后缀表达式运算">三、后缀表达式运算&lt;/h2>
&lt;p>后缀表达式的运算还是利用&lt;strong>栈&lt;/strong>这种数据结构，这里我们利用&amp;quot;3 4 + 5 * 6 -&amp;quot;这个后缀表达式来进行说明：&lt;/p>
&lt;h3 id="1规则-1">1、规则：&lt;/h3>
&lt;blockquote>
&lt;p>从左到右遍历表达式的每个数字和字符，遇到是数字就进栈，遇到是运算符，就将处于栈顶两个数字（栈顶元素和次顶元素）出栈，进行运算，运算结果进栈，一直到最终获得结果。&lt;/p>
&lt;/blockquote>
&lt;h2 id="2具体操作">2、具体操作：&lt;/h2>
&lt;p>1）从左至右扫描，将3和4压入栈；&lt;/p>
&lt;p>2）遇到+运算符，依次弹出4和3（4为栈顶元素，3为次顶元素），并计算4 + 3的结果，得7，再将7入栈；&lt;/p>
&lt;p>3）将5入栈；&lt;/p>
&lt;p>4）接下来是*运算符，依次弹出5和7，计算出7 * 5 = 35，将35入栈；&lt;/p>
&lt;p>5）将6入栈；&lt;/p>
&lt;p>6）最后是-运算符，计算出35-6的值，即29，由此得出最终结果。&lt;/p>
&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>因为后缀表达式相对而言是比较复杂的，所以我们分两篇博客进行讲解，这里先介绍的是&lt;em>如何将中缀表达式转换为后缀表达式&lt;/em>以及&lt;em>后缀表达式的运算&lt;/em>。在下一篇博客中，将进行具体的代码说明。&lt;/p></content></entry><entry><title type="text">栈的应用——中缀表达式</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/calculator/"/><id>https://quakewang.github.io/tech/calculator/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-07-06T21:15:48+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">中缀表达式 一、前言 栈的现实应用有很多，这次我们重点来说一下，关于如何使用栈来求数学表……</summary><content type="html">&lt;h1 id="中缀表达式">中缀表达式&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>栈的现实应用有很多，这次我们重点来说一下，关于如何使用栈来求数学表达式的值，这里我们描述的为&lt;strong>中缀表达式&lt;/strong>，也就是我们在日常生活中经常使用的四则运算式的形式。&lt;/p>
&lt;p>大家是否还记得，当我们在上小学的时候，老师们时常强调的“先乘除后加减，从左往右算”之类的话呢？？这其实就是四则运算的规则，那么在我们学习编程之后，该如何使用程序来解决这个问题呢？？&lt;/p>
&lt;h2 id="二算法描述">二、算法描述&lt;/h2>
&lt;p>我们需要一个栈来存放数据（&lt;strong>数栈numStack&lt;/strong>）和另一个栈来存放运算符（&lt;strong>符号栈operStack&lt;/strong>）。那么在此之前，我们需要定义一个类来表示栈。&lt;/p>
&lt;h3 id="1定义一个类表示栈">1、定义一个类表示栈&lt;/h3>
&lt;p>在这个类中，我们需要完成的方法有：判断栈满栈空、入栈、出栈、查看栈顶元素、判断是否是运算符、比较运算符的优先级以及运算方法。&lt;/p>
&lt;p>在这里有些方法以及变量的说明，在&lt;a href="https://quakewang.github.io/tech/arraystackdemo/">数组模拟栈&lt;/a>已经做出相关说明，这里就直接使用，不做过多的解释。&lt;/p>
&lt;h4 id="定义相关变量及赋值">①定义相关变量及赋值&lt;/h4>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 数组，用于模拟栈，数据就存放在该数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 栈的大小
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 表示栈顶，初始化为-1
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 构造器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">ArrayStack2&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">maxSize&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">maxSize&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="判断栈满-栈空">②判断栈满 栈空&lt;/h4>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 栈满
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isFull&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">maxSize&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 栈空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="入栈--push">③入栈 —— push&lt;/h4>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 入栈 —— push
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;栈满&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">top&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="出栈--pop">④出栈 —— pop&lt;/h4>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 出栈 —— pop
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">pop&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;栈空，没有数据~~~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">top&lt;/span>&lt;span class="o">--;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="查看栈顶元素">⑤查看栈顶元素&lt;/h4>
&lt;p>在这里增加一个方法，用于返回当前栈顶的值，但不是真正的top。那么有些小伙伴可能会问，为什么会在这里增加一个查看栈顶元素的方法呢？？其实我们在存放运算符入符号栈的时候，需要先判断入栈元素与栈顶元素的优先级。这里增加查看栈顶元素的方法，就不用再取出栈顶元素咯，更加有利于我们进行比较运算符的优先级。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 增加一个方法，可以返回当前栈顶的值，但不是真正的top
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">peek&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="判断是否是运算符">⑥判断是否是运算符&lt;/h4>
&lt;p>这个方法用于判断表达式中的元素是否是运算符，如果是运算符则直接入符号栈。在这里我们只考虑&amp;quot;+&amp;quot;、&amp;quot;-&amp;quot;、&amp;quot;*&amp;quot;、&amp;quot;/&amp;quot;四种运算符。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 判断是否是运算符
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isOper&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;+&amp;#39;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;-&amp;#39;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;*&amp;#39;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;/&amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="比较运算符的优先级">⑦比较运算符的优先级&lt;/h4>
&lt;p>因为进行四则运算需要遵循”先乘除后加减“的规则，所以需要规定运算符的优先级。我们在这里规定：优先级越高，则返回的数字越大。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 返回运算符的优先级，优先级是由程序猿来确定的，使用数字表示
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这里规定：优先级越高，返回的数字越大
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">priority&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">oper&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">oper&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;*&amp;#39;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">oper&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;/&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">oper&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;+&amp;#39;&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">oper&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;-&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 假定目前表达式的运算符只有+、-、*、/
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="计算方法">⑧计算方法&lt;/h4>
&lt;p>具体的计算流程如下：分别从数栈pop出两个数：&lt;em>num1&lt;/em>和&lt;em>num2&lt;/em>，以及从符号栈pop出一个符号：&lt;em>oper&lt;/em>，然后根据pop出的符号进行相关运算。&lt;/p>
&lt;p>在这里我们需要注意的是：因为num1是先取出的，num2是后取出的，所以在进行减除运算的时候，需要注意一下顺序。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 计算方法
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">cal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">oper&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// res用于存放计算的结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">switch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">oper&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;+&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">num2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;-&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">num1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;*&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">num1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;/&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">num1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h3 id="2具体运算操作">2、具体运算操作&lt;/h3>
&lt;h4 id="相关变量的定义">①相关变量的定义&lt;/h4>
&lt;p>我们前文提到了，需要一个数栈&lt;strong>numStack&lt;/strong>，用于存放从表达式中扫描得到的数字；再定义一个符号栈&lt;strong>operStack&lt;/strong>，用于存放扫描得到的运算符；定义一个&lt;strong>index&lt;/strong>用于扫描表达式；&lt;strong>num1、num2、oper&lt;/strong>分别表示取出的数字和运算符。再定义一个字符类型的变量&lt;strong>ch&lt;/strong>，用于存放每次扫描所得到的运算符；定义&lt;strong>res&lt;/strong>用于存放经过计算之后的数；在对于数字进行扫描到时候，如果是多位数，不能发现是一个数就入栈，需要往后面再看一位，如果是数字就继续扫描，否则push入栈，因此需要定义一个变量&lt;strong>keepNum&lt;/strong>用于拼接多位数。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="n">String&lt;/span> &lt;span class="n">expression&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;7*21*2-5+1-5+3-4+2/1&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">//创建两个栈，一个数栈，一个符号栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ArrayStack2&lt;/span> &lt;span class="n">numStack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayStack2&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">100&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">ArrayStack2&lt;/span> &lt;span class="n">operStack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ArrayStack2&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">100&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">//定义需要的相关变量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//用于扫描
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">num2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">oper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">ch&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//将每次扫面得到的运算符保存到ch
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">keepNum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//用于拼接,处理扫描到的数字是多位数
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="扫描表达式">②扫描表达式&lt;/h4>
&lt;p>这一步是程序的核心内容，也是运算实现的关键步骤。我们可以使用&lt;strong>while循环&lt;/strong>来操作。&lt;/p>
&lt;p>首先，利用&lt;strong>index&lt;/strong>索引进行扫描表达式，依次得到表达式的每一个字符，可以使用&lt;strong>substring()&lt;strong>来操作，即&lt;/strong>ch = expression.substring(index,index+1).charAt(0);&lt;/strong> 在得到表达式的各个字符之后，然后判断ch是什么符号。&lt;/p>
&lt;p>先假设扫描得到的&lt;strong>ch&lt;/strong>是运算符。如果此时符号栈&lt;strong>operStack&lt;/strong>中已经有运算符，则需要比较当前运算符和栈顶元素的运算符的优先级，如果当前的操作运算符的优先级&lt;strong>小于或者等于&lt;/strong>栈中的操作符，就需要从数栈中pop出两个数再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的运算符入符号栈。（&lt;em>注意：别忘了把当前的运算符push入符号栈&lt;/em>）；如果当前的运算符的优先级&lt;strong>大于&lt;/strong>栈中的运算符，则直接入符号栈。另外注意，我们到现在为止，所描述的都是符号栈内有操作符的情况，如果符号栈为空，直接push当前运算符入栈即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isOper&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//如果是运算符
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//判断当前的符号栈是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//如果符号栈有操作符，就进行比较，如果当前的操作运算符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的运算符入符号栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">priority&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">priority&lt;/span>&lt;span class="o">((&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">num1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">num2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">oper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">cal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">num1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">num2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">oper&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">//把运算的结果入数栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">res&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">//然后将当前的操作符入符号栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//如果为空直接入符号栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ch&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们来假设如果扫描得到的是数字，将会如何操作呢？？因为扫描得到的数字，其实是字符型，所以需要转化为整型，这里使用的是&lt;strong>Integer&lt;/strong>。还有需要注意的就是，该如何处理多位数的问题。&lt;/p>
&lt;pre>&lt;code>分析思路：
* 1、当处理多位数时，不能发现是一个数就立即入栈，因为它有可能是多位数
* 2、在处理数时，需要向expression的表达式的index 后再看一位，如果是数就进行扫描，如果是符号才入栈
* 3、因此需要定义一个变量 字符串，用于拼接
&lt;/code>&lt;/pre>&lt;p>在定义变量的时候我们提到了&lt;strong>keepNum&lt;/strong>，可以使用它来拼接多位数，即&lt;strong>keepNum += ch;&lt;/strong> 但是如果扫描得到的数字是最后一个数字，直接push入栈即可；如果不是最后一位，就需要&lt;em>往后看一位&lt;/em>，若后面一位还是数字，则需要继续扫描，直到不是数字为止，同样可以利用&lt;strong>substring&lt;/strong>来实现。每次扫描完成之后需要将拼接符&lt;strong>keepNum&lt;/strong>清空，这一步是千万不能少！！！&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//如果是数，则直接入数栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//处理多位数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">keepNum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">ch&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">//如果ch已经是expression的最后一位，就直接入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">expression&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">parseInt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">keepNum&lt;/span>&lt;span class="o">));&lt;/span>&lt;span class="c1">//Integer将字符串转化为整型
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//注意是最后一位，不是index++
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isOper&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">expression&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">substring&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">)))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//如果后一位是运算符，则入栈 keepNum = &amp;#34;1&amp;#34; 或者 ”123“
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">parseInt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">keepNum&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="c1">//重要！！！！！，keepNum清空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">keepNum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在完成上述操作之后，需要将&lt;strong>index&lt;/strong>后移，直到index的比表达式长度的值大时，退出循环。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">//让index + 1，并判断是否扫描到expr最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">expression&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="完成计算">③完成计算&lt;/h4>
&lt;p>在完成扫描之后，就顺序从数栈和符号栈中pop出相应的数字和符号完成计算。&lt;/p>
&lt;p>同样可以利用&lt;strong>while循环&lt;/strong>来完成。将最后的计算结果&lt;strong>res&lt;/strong>入数栈。别忘了把数栈中最后的数取出，这个数就是表达式的计算结果。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">//当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果符号栈为空，则运算到最后的结果，数栈中只有一个数字【结果】
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">num1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">num2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">oper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">operStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">cal&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">num1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">num2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">oper&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">res&lt;/span>&lt;span class="o">);&lt;/span>&lt;span class="c1">//入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">//将数栈的最后数，pop出，就是结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">res2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">numStack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;表达式%s = %d\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span>&lt;span class="n">expression&lt;/span>&lt;span class="o">,&lt;/span>&lt;span class="n">res2&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>关于使用栈实现中缀表达式的描述，真的太吃力了，能明显感觉到需要描述不清晰的地方，如果小伙伴们有较好的阐述方法或者建议，都可以提交pr或者issue。&lt;/p>
&lt;p>源码——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructes/blob/master/src/com/quake/stack/Calculator.java">Calculator&lt;/a>&lt;/p></content></entry><entry><title type="text">数据结构——链表模拟栈</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/linkedliststackdemo/"/><id>https://quakewang.github.io/tech/linkedliststackdemo/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-06-27T00:53:22+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">单链表模拟栈 一、前言 在上一篇博客中，我们开启了对于栈的数据结构的相关讲解，使用的是数……</summary><content type="html">&lt;h1 id="单链表模拟栈">单链表模拟栈&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在上一篇博客中，我们开启了对于栈的数据结构的相关讲解，使用的是&lt;strong>数组&lt;/strong>模拟&lt;strong>栈&lt;/strong>，在这篇博客中，我们将介绍一下如何利用&lt;strong>链表&lt;/strong>来模拟&lt;strong>栈&lt;/strong>。&lt;/p>
&lt;p>之前对于栈这种数据结构的相关定义以及应用场景已经做了简单的说明，在此就不做过多的赘述，下面我们开始了解一下算法的实现过程吧。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1创建结点类">1、创建结点类&lt;/h3>
&lt;p>在使用链表模拟栈之前，我们需要先创建一个结点类，存放信息，以及相关的使用方法。&lt;/p>
&lt;p>该类中所包含的信息有：创建&lt;strong>data域&lt;/strong>用于存放结点信息，&lt;strong>next域&lt;/strong>用于指向下一个结点的指针；利用&lt;strong>构造器&lt;/strong>传入给结点赋值的信息；以及利用&lt;strong>toString方法&lt;/strong>显示结点信息。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">// 定义一个类表示结点
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">StackNode&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// data域用于存储数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">StackNode&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// next域用于链接下一个结点
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 构造器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">StackNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;StackNode{&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;data=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">data&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2创建一个类用于管理结点">2、创建一个类用于管理结点&lt;/h3>
&lt;h4 id="定义相关变量以及赋值">①定义相关变量以及赋值&lt;/h4>
&lt;p>我们可以定义一个&lt;strong>头结点top&lt;/strong>，用来表示&lt;strong>栈顶&lt;/strong>，再定义一个&lt;strong>size&lt;/strong>用于表示栈的大小，并且用于记录入栈和出栈的元素。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">private&lt;/span> &lt;span class="n">StackNode&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 定义一个头结点，表示栈顶
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 初始化
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">LinkedListStack&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">top&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="判断链栈是否为空">②判断链栈是否为空&lt;/h4>
&lt;p>定义的头结点top是可以存放数据的，所以当top没有存放任何数据的时候，链栈为空。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 判断链栈是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="获取有效结点的个数">③获取有效结点的个数&lt;/h4>
&lt;p>在定义变量size的时候，提到size可以用来记录链栈的数据入栈和出栈情况，所以我们可以使用&lt;strong>getSize()方法&lt;/strong>，返回的值就是当前链栈的有效结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 获取size的大小
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getSize&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="入栈--push">④入栈 —— push&lt;/h4>
&lt;p>链栈的入栈操作总体上来说还是比较简单的，传入一个需要添加的结点&lt;strong>stackNode&lt;/strong>。与单链表添加结点不同的是，单链表添加的结点在链表的最后，而链栈需要保证的是所添加的结点需要在栈顶。&lt;/p>
&lt;p>因此，我们需要先将新的结点后继结点指向当前链栈的栈顶元素，即&lt;strong>stackNode.next = top;&lt;/strong> （&lt;em>这时原来栈顶的位置就变成了先添加结点的后继结点的位置&lt;/em>），然后再将新添加的结点设置为栈顶元素，即&lt;strong>top = stackNode;&lt;/strong> （&lt;em>这时新添加的结点就是栈顶元素&lt;/em>）。最后别忘记，每添加一个结点，&lt;strong>size需要+1&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 入栈 —— push
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">StackNode&lt;/span> &lt;span class="n">stackNode&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">stackNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">top&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">top&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stackNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">size&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="出栈--pop">⑤出栈 —— pop&lt;/h4>
&lt;p>在出栈之前，我们需要先判断链栈是否为空，如果为空则给出相应的提示（&lt;em>这里我们通过抛出异常的方式来进行处理&lt;/em>）。至于链栈的出栈操作，具体实现如下：&lt;/p>
&lt;p>先将栈顶元素临时赋值给临时变量temp保存，然后将栈顶元素toptemp的下一个结点。这时栈顶元素的信息已经保存在temp当中。紧接着，再定义一个临时变量&lt;strong>retValue&lt;/strong>，用于存储栈顶元素的data域。在完成上述操作之后，我们还需要将 temp置空，别忘了**size--**和返回retValue。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 出栈 —— pop
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">pop&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;链栈为空~~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">StackNode&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">top&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 辅助变量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">retValue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">data&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 定义一个临时变量，用于保存栈顶元素
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 将temp置空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">--;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">retValue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="显示链栈信息">④显示链栈信息&lt;/h4>
&lt;p>显示链栈信息的方法，与单链表显示方法一样，所以我们直接上代码，哈哈哈哈哈&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 显示栈中信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">show&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;链栈为空~~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">StackNode&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">top&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>到这里，我们完成了对于栈的两种实现方式，相对于使用链表实现，数组更容易让我们接受一点。在编写入栈和出栈方法的时候，一开始直接参照单链表的相关实现方法，因此走了不少弯路，所以在学习过程中我们需要学会比较着来学，这样可以帮助我们更好地巩固所学的知识。&lt;/p>
&lt;p>其实关于出栈操作的方法，我总觉得不够好，似乎缺少了点什么。关于临时变量temp，如果不定义temp，而是对栈顶元素直接操作，会发生些什么呢？？小伙伴们可以自己尝试一下，如果有更好的实现方法，也欢迎提出issue噢！&lt;/p>
&lt;p>源码 ——&amp;gt; [数据结构]&lt;/p></content></entry><entry><title type="text">数据结构——数组模拟栈</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/arraystackdemo/"/><id>https://quakewang.github.io/tech/arraystackdemo/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-06-21T21:59:55+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">数组模拟栈 一、基本介绍 1、相关定义 栈是一个先入后出的有序列表； 栈是限制线性表中元素的……</summary><content type="html">&lt;h1 id="数组模拟栈">数组模拟栈&lt;/h1>
&lt;h2 id="一基本介绍">一、基本介绍&lt;/h2>
&lt;h3 id="1相关定义">1、相关定义&lt;/h3>
&lt;ul>
&lt;li>栈是一个先入后出的有序列表；&lt;/li>
&lt;li>栈是限制线性表中元素的插入和删除只能在线性表的同一段进行的一种特殊线性表。允许插入和删除的一端，为&lt;strong>变化的一端&lt;/strong>，称为栈顶（Top）,另一端为&lt;strong>固定的一端&lt;/strong>，称为栈底（Bottom）；&lt;/li>
&lt;li>根据栈的定义可知，最先&lt;em>放入&lt;/em>栈中的元素在栈底，最后放入的元素在栈顶，而&lt;em>删除&lt;/em>元素刚好相反，最后放入的元素最先删除，最先删除的元素最后删除。&lt;/li>
&lt;/ul>
&lt;h3 id="2应用场景">2、应用场景&lt;/h3>
&lt;ul>
&lt;li>子程序的调用：在跳往子程序前，会先将下个指令的地址存放到堆中，直到子程序执行完后再将地址取出，以回到原来的程序中。&lt;/li>
&lt;li>处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数、区域变量等数据存入到堆栈中。&lt;/li>
&lt;li>表达式的转换[&lt;em>中缀表达式转后缀表达式&lt;/em>]与求值（实际解决）。&lt;/li>
&lt;li>二叉树的遍历。&lt;/li>
&lt;li>图形的深度优先（&lt;strong>depth - first&lt;/strong>）搜索法。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>需要构建一个&lt;strong>ArrayStack&lt;/strong>类，用于表示栈。&lt;/p>
&lt;h3 id="1定义相关变量以及赋值">1、定义相关变量以及赋值&lt;/h3>
&lt;p>需要定义的相关变量有：定义一个数组模拟栈&lt;strong>int[] stack&lt;/strong>、栈的大小&lt;strong>maxSize&lt;/strong>以及栈顶元素&lt;strong>top&lt;/strong>。（&lt;em>在这里我们把栈顶元素top的初始值为-1，有利于后期存入和删除数据&lt;/em>）。&lt;/p>
&lt;p>定义完相关变量之后，我们可以利用构造器对&lt;strong>maxSize&lt;/strong>和&lt;strong>stack数组&lt;/strong>进行赋值。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 栈的大小
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 数组，数组模拟栈，数据就在该数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// top表示栈顶，初始化为-1
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 构造器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">ArrayStack&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">maxSize&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">maxSize&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2判断栈是否为满">2、判断栈是否为满&lt;/h3>
&lt;p>因为数组的下标是从0开始的，所以当栈满时，栈顶元素的下标为&lt;strong>stack[top] = maxSize - 1&lt;/strong>;所以当 top == maxSize - 1时，&lt;strong>栈满&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 栈满
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isFull&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">maxSize&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3判断栈是否为空">3、判断栈是否为空&lt;/h3>
&lt;p>之前在定义相关变量的时候，我们提到&lt;strong>top&lt;/strong>的初始值为-1，即当 top == -1时，栈中没有存入任何数据，为空。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 栈空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4入栈push-方法">4、入栈——push 方法&lt;/h3>
&lt;p>在入栈之前，我们首先需要判断栈是否已满，如果栈满则给出提示，并结束程序。否则执行以下操作：由于&lt;strong>top&lt;/strong>的初始值为-1，即数组第一个元素的前一个位置，因此需要先移动&lt;strong>top&lt;/strong>到指定位置，然后给其赋值即可。（&lt;em>先后移再赋值&lt;/em>）&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 入栈——push
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先判断栈是否未满
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;栈满&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">top&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="5出栈pop-方法">5、出栈——pop 方法&lt;/h3>
&lt;p>在进行出栈操作之前，我们首先需要判断栈是否为空，如果为空，则给出相关提示（&lt;em>这里我们是用抛出异常的方式来进行处理&lt;/em>）；否则，执行以下操作：先定义一个临时变量&lt;strong>value&lt;/strong>来存储栈顶元素，然后栈顶元素&lt;strong>top--&lt;/strong>，往前移动，最后返回临时变量即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 出栈——pop
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">pop&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;栈空，没有数据~~~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">top&lt;/span>&lt;span class="o">--;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="6打印输出栈的信息">6、打印输出栈的信息&lt;/h3>
&lt;p>如果栈为空，则没有任何数据可以显示，所以在输出栈的信息之前，我们需要先判断栈是否为空。在遍历的时候，我们需要从&lt;strong>栈顶&lt;/strong>开始显示数据。可以通过&lt;em>for循环&lt;/em>l来实现。&lt;/p>
&lt;p>因为是从栈顶开始显示数据，所以循环的起始位置应该为&lt;strong>栈顶top&lt;/strong>，循环结束的条件应该为&lt;strong>i &amp;lt; 0&lt;/strong>，每执行一次循环，则需要&lt;strong>i--&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 遍历栈，遍历时，需要从栈顶开始显示数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">show&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;栈空，没事有数据~~~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 需要从栈顶开始显示数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">top&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;stack[%d]=%d\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>这里我们使用的是&lt;em>数组模拟栈&lt;/em>的操作，所以说对应的也可以利用链表来模拟栈，小伙伴们可以自己先尝试一下噢。&lt;/p>
&lt;p>在写代码的时候，因为是利用数组模拟栈的相关操作，不由的想起之前写过的&lt;a href="https://quakewang.github.io/tech/arrayqueue/">数组模拟单向队列&lt;/a>，两者可以进行比较的学习，可以思考一下，同样是没有取模的操作，为什么单向队列不能够进行复用，而栈却可以呢？？&lt;/p>
&lt;p>源码地址——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructes">数据结构&lt;/a>&lt;/p></content></entry><entry><title type="text">数据结构——约瑟夫环</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/circlelinkedlistdemo/"/><id>https://quakewang.github.io/tech/circlelinkedlistdemo/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-06-14T11:03:36+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">环形链表 一、基本介绍 1、问题来历 据说著名犹太历史学家Josephus有过以下的故事：……</summary><content type="html">&lt;h1 id="环形链表">环形链表&lt;/h1>
&lt;hr>
&lt;h2 id="一基本介绍">一、基本介绍&lt;/h2>
&lt;h2 id="1问题来历">1、问题来历&lt;/h2>
&lt;p>据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第&lt;em>k&lt;/em>个人。接着，再越过k-1个人，并杀掉第&lt;em>k&lt;/em>个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。&lt;/p>
&lt;h2 id="2问题简化">2、问题简化&lt;/h2>
&lt;p>在了解了约瑟夫环的来历之后，我们对该问题进行以下简化。其实我们联系一下，将会发现约瑟夫环是不是和我们小时候玩的丢手帕有些类似呢？&lt;/p>
&lt;p>那么我们首先假设有五个小孩围城一个圈，然后从第一个小孩开始报数，每次数到2，则这个小孩出圈，以此类推，通过简单地推理我们可以得出，出队列的顺序是：2—&amp;gt;4—&amp;gt;1—&amp;gt;5—&amp;gt;3.&lt;/p>
&lt;p>在了解了有关约瑟夫环的介绍之后，我们可以使用单向环形链表来对它进行相关操作。这里我们使用的是没有头结点的链表。&lt;/p>
&lt;hr>
&lt;h2 id="二算法描述">二、算法描述&lt;/h2>
&lt;h3 id="1定义结点">1、定义结点&lt;/h3>
&lt;p>定义一个结点，存放小孩的编号。在之前介绍链表的时候，我们定义变量的属性都是共有的，这里我们尝试一下私有的，因此需要使用到&lt;strong>get&lt;/strong>和&lt;strong>set&lt;/strong>方法，来进行赋值和获取相关变量。同时，还需要一个&lt;strong>构造器&lt;/strong>，分别用于&lt;em>传入结点的编号&lt;/em>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="c1">// 创建一个Boy类，表示一个结点
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Boy&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 编号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">Boy&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向下一个结点，默认为null
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 构造器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">Boy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getNo&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Boy&lt;/span> &lt;span class="nf">getNext&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setNo&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Boy&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2定义一个类用于管理结点">2、定义一个类用于管理结点&lt;/h3>
&lt;p>首先需要创建一个first结点，不存放任何数据，也就是当前没有编号的结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 创建一个first结点，当前没有编号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">Boy&lt;/span> &lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="添加结点入链表">①添加结点入链表&lt;/h4>
&lt;p>首先传入一个&lt;strong>nums&lt;/strong>表示需要添加结点的个数。在进行添加之前，还需要判断传入的nums是否符合要求。然后定义一个&lt;strong>curBoy&lt;/strong>辅助指针，帮助构建环形链表。&lt;/p>
&lt;p>我们通过for循环创建结点，先创建第一个结点，让first结点指向该结点，然后first的next域指向自己，构成一个&lt;em>环&lt;/em>，最后再让辅助指针curBoy指向first，即完成第一个结点的添加操作；添加其它结点的方法如下：先让curBoy的下一个结点指向需要添加的结点（通过setNext方法），然后再让该结点的next域指向first结点，形成环，最后使curBoy指向当前添加的结点（为了方便下一次添加结点），从而完成添加结点的相关操作。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 添加小孩结点，构建一个环形的链表，nums表示需要添加结点的个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">addBoy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//检验
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;nums的值不正确&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">Boy&lt;/span> &lt;span class="n">curBoy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 辅助指针，帮助构建环形链表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 使用for循环俩创建环形链表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 根据编号，创建小孩结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Boy&lt;/span> &lt;span class="n">boy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Boy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 如果是第一个小孩
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">boy&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">first&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="o">);&lt;/span>&lt;span class="c1">// 构成环
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">curBoy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">curBoy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">boy&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">boy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">curBoy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">boy&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="遍历输出环形链表">②遍历输出环形链表&lt;/h4>
&lt;p>首先判断链表是否为空，即&lt;strong>if(first == null)&lt;/strong>，如果为空则给出提示；不为空则执行以下操作：因为first结点不能动，因此需要一个辅助变量用于完成遍历，即 &lt;strong>Boy curBoy = first&lt;/strong>，然后我们使用while来进行循环遍历。通过getNext方法实现后移，如果curBoy的下一个结点为first则遍历结束，退出循环。完成链表的遍历。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 遍历当前的环形链表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">showBoy&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 判断链表是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;该环形链表为空~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 因为first不能动，因此需要一个辅助指针完成遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Boy&lt;/span> &lt;span class="n">curBoy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;小孩的编号%d\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">curBoy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNo&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">curBoy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 说明已经遍历完毕
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">curBoy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curBoy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">();&lt;/span>&lt;span class="c1">// curBoy后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="完成结点出链表">③完成结点出链表&lt;/h4>
&lt;p>我们需要传入几个参数，&lt;strong>startNo&lt;/strong>表设从第几个结点开始报数，&lt;strong>countNum&lt;/strong>表示需要数几下，&lt;strong>nums&lt;/strong>表示圈中有多少个小孩。&lt;/p>
&lt;p>首先需要对数据进行一个校验，即判断环形链表是否为空，开始报数的位置不能低于1，也不能大于圈中的结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">startNo&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">startNo&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;参数输入有误，请重新输入~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后需要创建一个辅助指针&lt;strong>helper&lt;/strong>，帮助完成小孩出圈。接下来我们需要将helper先指向链表的最后这个结点，即helper的下一个结点就是first结点。紧接着通过while循环，我们再将first和helper指针同时移动&lt;strong>countNum - 1&lt;/strong>次，到达需要出圈结点的位置。&lt;/p>
&lt;p>最后也是最关键的一步，完成小孩结点出圈。先让first结点指向它的下一个结点，即&lt;strong>first = first.getNext();&lt;/strong>，然后再将helper的下一个结点设置为当前first所指向的结点，即&lt;strong>helper = helper.setNext(first);&lt;/strong>，这样first原来所指向的结点没有任何引用，就会被回收。&lt;/p>
&lt;p>如果&lt;strong>helper == first&lt;/strong>,则说明圈中只有一个结点。输出这个结点的信息，就完成了出圈的操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 根据用户的输入，计算出小孩出圈的顺序
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param startNo 表示从第几个小孩开始数数
&lt;/span>&lt;span class="cm"> * @param countNum 表示数几下
&lt;/span>&lt;span class="cm"> * @param nums 表示最初有多少个小孩在圈中
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">countNum&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">startNo&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">countNum&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先对数据进行校验
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">startNo&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">startNo&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;参数输入有误，请重新输入~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 创建一个辅助指针，帮组完成小孩出圈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Boy&lt;/span> &lt;span class="n">helper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">//需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">helper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 说明helper指向最后小孩结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">helper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">helper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 当小孩报数前，先让first和helper指针同时移动 startNo - 1 次，到达需要报数的位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">startNo&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">helper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">helper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 当小孩报数时，让first和helper指针同时移动countNum - 1次，然后出圈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 这里使用循环操作，直到圈中只有一个结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">helper&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 说明圈中只有一个结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 让first和helper指针同时移动countNum - 1次
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">countNum&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">helper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">helper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 这时first指向的结点，就是要出圈的小孩结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;小孩%d出圈\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNo&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">first&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNext&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">helper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setNext&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;最后留在圈中的小孩编号%d\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNo&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>在此，更新了环形链表，关于链表的所有基础知识也就要告一段落咯。谈谈我一开始学习链表的感觉吧，从一个小白，刚开始接触数据结构，就被其中各种复杂的结构所惊讶到。特别在学习到链表的时候，更加感觉到举步维艰，似乎很玄学，说不懂，但其实还是有一点点明白大概的结构。但是距离能够独立写出一个链表的结构还有很长一段路要走。因此我查阅了一些相关博客，只看代码和文字描述，总感觉少了点什么，写得再好的代码和文字，倒不如一张图来得实在，所以在学习的时候，我建议可以结合画图来实际操作，这样更方便理解，还有利于记忆。&lt;/p>
&lt;p>环形链表源码—&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructes/blob/master/src/com/quake/linkedlist/Josephus.java">数据结构&lt;/a>&lt;/p></content></entry><entry><title type="text">数据结构——双向链表</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/doublelinkedlist/"/><id>https://quakewang.github.io/tech/doublelinkedlist/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-06-06T14:48:57+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">双向链表 一、基本介绍 在上一篇博客中，我们提到了单链表，它只有一个next指针，指向下……</summary><content type="html">&lt;h1 id="双向链表">双向链表&lt;/h1>
&lt;hr>
&lt;h2 id="一基本介绍">一、基本介绍&lt;/h2>
&lt;p>在上一篇博客中，我们提到了单链表，它只有一个next指针，指向下一个结点，所以我们要查找下一个结点是很容易做到的，但是要想查找上一个结点就复杂的多了。因此有了&lt;strong>双向链表&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>双向链表&lt;/strong>有两个指针域，除了有next域指向下一个结点之外，还有pre域指向上一个结点。这样使得双链表可以双向遍历。节省了时间成本，但相比于单链表插入数据和删除数据就相对复杂一些。下面我们对双链表进行简单学习一下吧。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>双链表和单链表一样，需要创建一个类用于存放结点信息，再创建一个类用于管理结点，对双链表进行相关的操作。&lt;/p>
&lt;h3 id="1定义节点类">1、定义节点类&lt;/h3>
&lt;p>我们需要在HeroNode2类中实现相关变量的定义、赋值以及显示信息的方法。&lt;/p>
&lt;h4 id="相关变量">①相关变量&lt;/h4>
&lt;p>这里我们使用双链表存储水浒英雄，和单链表相同，还得增加一个pre指针，指向前一个结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">nickname&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">pre&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向下一个结点，默认为null
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向前一个结点，默认为null
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="构造器">②构造器&lt;/h4>
&lt;p>利用构造器，对相关变量进行赋值。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">HeroNode2&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">nickname&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">nickname&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nickname&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="显示链表信息">③显示链表信息&lt;/h4>
&lt;p>这里利用toString方法，返回链表的信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 为了显示方法，重写toString
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;HeroNode2{&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;no=&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;, name=&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;, nickname=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">nickname&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h3 id="2定义一个doublelinkedlist类管理结点">2、定义一个DoubleLinkedList类管理结点&lt;/h3>
&lt;p>我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，同样需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 先初始化一个结点，头结点不要动，不存放具体的数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HeroNode2&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="添加数据到队列尾">①添加数据到队列尾&lt;/h4>
&lt;p>与单链表相同，需要先定义一个辅助变量temp，利用while循环遍历到链表的最后。当退出while循环时，即temp指向了链表的最后。这时我们需要将temp的next域指向需要添加的结点，然后再将需要添加的结点的pre域指向temp，完成添加。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 添加一个结点到双向链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 因为head结点不能动，因此我们需要添加一个辅助变量temp
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 遍历链表，知=找到链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 遍历到链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 如果没有找到将temp后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">// 当退出while循环时，temp就指向了链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 形成了一个双向链表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">heroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="根据编号顺序添加结点">②根据编号顺序添加结点&lt;/h4>
&lt;p>与单链表相同，需要先找到需要添加结点(heroNode2)的前一个结点（temp），这里不做过多赘述。当找到需要添加的结点的前一个结点之后，需要进行如下操作：&lt;/p>
&lt;p>需要先将heroNode2完成拼接，即先将heroNode2的next域指向temp.next;（新插入节点的前一个结点指向它的下一个结点），再将heroNode的pre域指向temp（将新插入的结点指向它的前一个结点），这时heroNode的pre域和next域已经分别指向了heroNode的前驱结点和后继结点；剩余需要做的就是让heroNode的前驱结点的next域和后继结点的pre域指向heroNode，但需要注意的是：如果添加的位置刚好是最后一个结点，则heroNode没有后继结点，也就是不用执行&lt;strong>temp.next.pre = heroNode2&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 根据编号顺序添加结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">addByOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">boolean&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;需要插入的英雄编号%d已存在，添加失败\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">heroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 将新插入的结点指向它的下一个结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 将新插入的结点指向它的前一个结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 注：如果不是最后一个结点，则不需要执行下面这块代码，否则会出现空指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">heroNode2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="修改结点信息">③修改结点信息&lt;/h4>
&lt;p>修改结点信息的方法和单链表如出一辙，通过遍历找到需要修改结点所在的位置即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 修改结点信息（可以看待双向链表的结点内容修改和单向链表一样）
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">update&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">newHeroNode2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 判断链表是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;链表为空~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 找到需要修改的结点，根据no编号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 定义一个辅助变量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">newHeroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//根据flag判断是否找到需要修改的节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newHeroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">nickname&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newHeroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">nickname&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//没有找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;没有找到 编号%d的节点，不能修改&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">newHeroNode2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="删除结点">④删除结点&lt;/h4>
&lt;p>从双向链表中删除一个结点，我们只需直接找到需要删除的结点，找到后，双链表可以实现&lt;strong>自我删除&lt;/strong>。&lt;/p>
&lt;p>具体操作如下：定义一个辅助变量temp = head.next;这里我们直接找到该结点所在的位置，所以temp直接等于head.next;还需要一个flag标记是否找到待删除结点。通过遍历找到链表的最后，然后让temp的前驱结点的next域直接指向temp的下一个结点，即&lt;strong>temp.pre.next = temp.next&lt;/strong>;如果待删除结点不是最后的结点，则还需要执行下列操作：让temp的下一个结点的pre指向temp的前一个结点，即&lt;strong>temp.next.pre = temp.pre&lt;/strong>;完成上述操作之后，待删除结点的前后指针都指向null，也就完成了删除。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">del&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 判断当前链表是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 空链表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;链表为空，无法删除~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 辅助变量(指针)
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// 标志是否找到待删除节点的
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">// 已经到链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 找到的待删除节点的前一个节点temp
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">// temp后移，遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">// 判断flag
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="c1">// 找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 可以删除
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pre&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pre&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;要删除的 %d 节点不存在\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="输出链表信息">⑤输出链表信息&lt;/h4>
&lt;p>和单链表操作相同。。。。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 遍历打印输出链表信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">show&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先判断链表是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;链表为空~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 因为头结点不能动，定义一个辅助变量用于遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode2&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 判断是否到链表最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 输出结点信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 将temp后移！！！
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>到这里，我们完成了对于双链表的相关操作。双向链表相对于单链表来说，要更复杂一些，毕竟它多了pre指针，进行删除和操作的时候需要格外小心。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点操作带来了方便，可以有效提高算法的时间性能。说白了，就是用空间换时间。&lt;/p>
&lt;p>源代码——&amp;gt;&lt;a href="https://github.com/QuakeWang/DataStructes">数据结构&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>《大话数据结构》 ——程杰&lt;/p>
&lt;p>图解数据结构与算法——韩顺平&lt;/p>
&lt;/blockquote></content></entry><entry><title type="text">单链表的使用</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/><id>https://quakewang.github.io/tech/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-06-01T21:22:48+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">单链表的应用举例 一、前言 在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操……</summary><content type="html">&lt;h1 id="单链表的应用举例">单链表的应用举例&lt;/h1>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操作：&lt;/p>
&lt;ol>
&lt;li>获取单链表的有效结点&lt;/li>
&lt;li>查找单链表中的倒数第k个结点&lt;/li>
&lt;li>逆序打印单链表（从尾到头打印）&lt;/li>
&lt;li>反转单链表&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="二算法介绍">二、算法介绍&lt;/h2>
&lt;h3 id="1获取单链表的有效结点">1、获取单链表的有效结点&lt;/h3>
&lt;p>作为使用的第一个方法难度不是很大。因为需要求出单链表中有效结点的个数，所以我们可分为&lt;strong>带头结点&lt;/strong>和&lt;strong>不带头结点&lt;/strong>两种情况。&lt;/p>
&lt;p>我们这边考虑的是不带头结点的单链表，（如果是带头结点的链表需要再加上头结点即可）。需要的变量有&lt;strong>length(统计链表的长度)&lt;strong>和&lt;/strong>cur(辅助变量，用于遍历)&lt;/strong>，可以通过传入一个头结点，然后依次遍历该链表，当链表遍历到最后的时候，即&lt;strong>cur.next == null&lt;/strong>，每一次遍历链表的长度加一，即&lt;strong>length++&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// head链表的头结点，返回的就是有效结点的个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getLength&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 链表为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 定义一个辅助变量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">cur&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">length&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2查找单链表中的倒数第k个结点">2、查找单链表中的倒数第k个结点&lt;/h3>
&lt;p>因为单链表是单向的，只能从头到尾开始遍历，而无法从后往前遍历，所以我们需要传入一个头结点&lt;strong>head（遍历的起始位置）&lt;strong>和&lt;/strong>index(倒数第k个结点)&lt;/strong>。&lt;/p>
&lt;p>定义一个&lt;strong>size&lt;/strong>表示链表的长度，也就是链表有效结点的个数，可以通过方法一来获取。即&lt;strong>size = getLength(head)&lt;/strong>，然后需要定义一个辅助变量用于遍历。然后通过for循环定位到倒数的index，即&lt;strong>size - index&lt;/strong>的位置，也就是需要查找的倒数第k个结点。最后返回当前的辅助变量，完成查找。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="nf">findLastIndexNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 判断链表是否为空，如果是则返回null
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 没有找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">// 第一次遍历得到链表对的长度（结点个数）
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getLength&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 先做一个index校验
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 定义一个辅助变量，for循环定位到倒数的index
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 第二次遍历 size - index位置，就是倒数的第k个结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3逆序打印单链表">3、逆序打印单链表&lt;/h3>
&lt;p>在不改变链表结构的情况下，进行逆序打印，我们可以利用栈这个数据结构来实现。栈的特点就是&lt;strong>先进后出&lt;/strong>。先把链表push压入栈中，再pop出栈即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">reversePrint&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 空链表，不能打印
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">// 创建一个栈，将各个结点压入栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HeroNode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Stack&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">// 将链表的所有结点压入到栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">cur&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cur&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 将栈中的结点进行打印，pop出栈
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">());&lt;/span>&lt;span class="c1">// stack的特点就是先进后出
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4反转单链表有点难度">4、反转单链表（有点难度）&lt;/h3>
&lt;p>对单链表进行反转，表示的意思是：将最后的结点变成最前端的结点，以此类推。所以我们需要分为两种情况：&lt;/p>
&lt;ol>
&lt;li>当前链表为空，或者当前链表只有一个结点，无需反转，直接返回即可。&lt;/li>
&lt;li>有多个结点时：&lt;/li>
&lt;/ol>
&lt;p>需要的变量有：&lt;strong>cur(用于遍历原来的链表)&lt;/strong>，&lt;strong>nextNode(指向当前结点[cur]的下一个结点)&lt;/strong>，&lt;strong>reverseHead(结点，新链表的最前端)&lt;/strong>。&lt;/p>
&lt;p>具体操作过程如下：先将nexNodet指向cur的下一个结点，&lt;em>用于保存当前结点的下一个结点&lt;/em>，然后将cur的下一个结点指向新链表的最前端，即&lt;strong>cur.next = reverseHead.next&lt;/strong>,然后再&lt;em>将cur连接到新的链表上&lt;/em>，这样才能形成一个完成的链表（一个回路）。然后后移，遍历下一个结点，即&lt;strong>cur = nextNode&lt;/strong>;在进行上述操作之后，我们已经将链表的所有结点取出，并存放在新的链表下，这时我们需要将head.next 指向 reverseHead.next，实现单链表的反转，即 &lt;strong>head.next = reverseHead.next;&lt;/strong> 完成单链表的反转。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">reverseList&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 如果当前链表为空，或者只有一个结点，无需反转，直接返回
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 定义一个辅助变量，帮助遍历原来的链表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">nextNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向当前结点[cur]的下一个结点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">reverseHead&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HeroNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 遍历原来的链表，每遍历一个结点，将其取出，并放在新的链表reverseHead的最前端
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">cur&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">nextNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 先暂时保存当前结点的下一个结点，
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">reverseHead&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;;&lt;/span>&lt;span class="c1">// 将cur的下一个结点指向新的链表的最前端
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">reverseHead&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 将cur连接到新的链表上
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nextNode&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 让cur后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">// 将 head.next 指向 reverseHead.next，实现单链表的反转
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">reverseHead&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>其实我们不难发现，数组也好，链表也罢，都只是存储信息的不同方式，最重要的还是对其的理解和使用，只有这样才能更好的掌握。对于一个刚接触数据结构的小白来说，学到这里的时候，信息量已经远远超过之前所学的知识，但并不应该气馁，数据结构多而且难，所以更需要我们耐下性子，去慢慢琢磨、回顾，愿成长路上，与君共勉！&lt;/p>
&lt;p>源码地址——&amp;gt;&lt;a href="https://github.com/QuakeWang/DataStructes">数据结构&lt;/a>&lt;/p></content></entry><entry><title type="text">数据结构--单向链表</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/singlelinkedlist/"/><id>https://quakewang.github.io/tech/singlelinkedlist/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-05-30T16:23:52+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">单向链表 一、基本介绍 1、相关定义 链表实际上是线性表的链式存储结构，与数组不同的是，它……</summary><content type="html">&lt;h1 id="单向链表">单向链表&lt;/h1>
&lt;h2 id="一基本介绍">一、基本介绍&lt;/h2>
&lt;h3 id="1相关定义">1、相关定义&lt;/h3>
&lt;p>链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的，且链表的长度不是固定的。链表的每个元素称为一个结点，每个结点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑关系，以便构成“一个结点链着一个结点”的链式存储结构，为了保持每个结点之间的链接，所以链表除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个结点都包含两个部分，第一部分用于存储元素本身的数据信息，称为&lt;strong>数据域&lt;/strong>，它不局限于一个成员数据，也可是多个成员数据；第二部分是一个结构体指针，称为链表的&lt;strong>指针域&lt;/strong>，用于存储其直接后继的结点信息，这里用next表示，next的值实际上就是&lt;strong>下一个结点的地址&lt;/strong>，当前结点为末结点时，next的值设为空指针，即为null。链表在使用过程中，可以根据实际需求来判断是否需要添加头结点。&lt;/p>
&lt;h3 id="2链表与数组比较">2、链表与数组比较&lt;/h3>
&lt;p>数组（包括结构体数组）的实质是一种线性表的顺序表示方式，它的优点是使用直观，便于快速、随机地存取线性表中的任一元素，但缺点是对其进行插入和删除操作时需要移动大量的数组元素，同时由于数组属于静态内存分配，定义数组时必须指定数组的长度，程序一旦运行，其长度就不能再改变，实际使用个数不能超过数组元素最大长度的限制，否则就会发生下标越界的错误，低于最大长度时又会造成系统资源的浪费，因此空间效率差。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;p>我们需要定义一个类用来存放结点信息，同时也还需要定义一个类用于管理结点，实现单链表的增删改查。&lt;/p>
&lt;h3 id="1定义一个heronode类表示结点">1、定义一个HeroNode类表示结点&lt;/h3>
&lt;p>我们需要在HeroNode类中实现相关变量的定义、赋值以及显示信息的方法。&lt;/p>
&lt;h4 id="-相关变量">① 相关变量&lt;/h4>
&lt;p>这里我们使用单链表来存储水浒英雄，需要存储的信息有：编号、姓名和昵称。还需要定义一个next域用于指向下一个结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 编号
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 姓名
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">nickname&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 昵称
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// next域，指向下一个节点
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="构造器">②构造器&lt;/h4>
&lt;p>可以利用构造器对相关变量进行赋值。&lt;/p>
&lt;p>&lt;strong>代买实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="nf">HeroNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">nickname&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">nickname&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nickname&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="显示链表信息">③显示链表信息&lt;/h4>
&lt;p>我们可以使用toString方法来显示链表的信息。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 利用toString显示信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;HeroNode{&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;no=&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;, name=&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="s">&amp;#34;, nickname=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">nickname&lt;/span> &lt;span class="o">+&lt;/span>
&lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2定义一个singlelinkedlist类管理结点">2、定义一个SingleLinkedList类管理结点&lt;/h3>
&lt;p>我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">//先初始化一个头节点，头节点不要动，不存放具体的数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">HeroNode&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="直接添加数据到单链表">①直接添加数据到单链表&lt;/h4>
&lt;p>直接添加数据到队列尾，即不考虑编号按照添加顺序，入链表。因为头结点不能动，所以需要定义一个临时变量temp用于遍历。通过后移temp实现遍历，&lt;strong>temp = temp.next&lt;/strong> 。遍历的目的在于，找到当前链表最后的结点，然后将最后这个结点的next指向新的结点，便完成了添加的操作。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">heroNode&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//因为head节点不能动，因此我们需要一个辅助变量temp
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="c1">//遍历链表，找到最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//找到链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//如果没有找到最后，将temp后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//当退出while循环时，temp指向了链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//将最后这个节点的next指向新的节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">heroNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="根据编号添加结点">②根据编号添加结点&lt;/h4>
&lt;p>这次我们使用按照编号顺序添加结点，如果该编号已经存在，则添加失败，并给出提示。按照编号添加结点，使用的方法是通过 &lt;strong>后移temp&lt;/strong> 遍历，找到该编号的前一个结点，然后让需要添加的结点先指向前一个结点的下一个结点，然后再让前一个结点指向需要添加的结点。所以需要一个flag变量来标记是否找到当前结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">addByOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">heroNode&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//因为头节点不能动，因此仍然需要通过一个辅助指针（变量）来帮助找到添加的位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//因此我们找的temp是位于添加位置的前一个节点，否则插入不了
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">boolean&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//标志添加的编号是否存在，默认为false
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//说明temp已经在链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">heroNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//位置找到，就在temp的后面插入
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">heroNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//说明希望添加的heroNode编号已经存在
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//说明编号存在
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//后移，遍历当前链表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">//判断flag的值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//不能添加，说明编号已经存在
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;准备插入的英雄编号%d已经存在，添加失败\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">heroNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//插入到链表中，temp的后面
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">heroNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">heroNode&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="修改结点信息">③修改结点信息&lt;/h4>
&lt;p>这里我们通过根据编号来修改结点信息，即编号不能改。同时需要传入一个新的结点 &lt;strong>newHeroNode&lt;/strong> ，用于存储修改结点的信息。在进行修改之前，需要先判断单链表是否为空，&lt;strong>head.next == null&lt;/strong> 链表为空。然后定义一个辅助变量temp和flag分别用于遍历和标记是否找到当前结点。如果 &lt;strong>temp.no == newHeroNode.no&lt;/strong> 表示找到当前需要修改的结点。赋予新的name和nickname完成修改结点的操作。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">//1、根据newHeroNode的no来修改即可
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">update&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">newHeroNode&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//判断是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;链表为空&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//2、找到需要修改的节点，根据num编号修改
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//定义一个辅助变量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//表示是否找到该节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//已经遍历结束
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">newHeroNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//3、根据flag，判断是否找到需要修改的节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newHeroNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">nickname&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newHeroNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">nickname&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//没有找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;没有找到编号%d的节点，不能修改\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">newHeroNode&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="删除结点">④删除结点&lt;/h4>
&lt;p>在进行删除结点的操作的时候，我们仍然根据编号来进行寻找需要删除的结点。找到需要删除结点的前一个结点，让前一个结点的next跨过需要删除的结点，直接指向下一个结点，即 &lt;strong>temp.netx = temp.next.next&lt;/strong> ，完成删除。在进行删除之前仍然需要定义temp和flag用于遍历和标记是否找到需要删除结点的前一个结点。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">del&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">HeroNode&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">boolean&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//标志是否找到待删除节点
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//已经到链表的最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">no&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//找到待删除节点的前一个节点temp
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">//temp后移，遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;span class="c1">//判断flag
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">//找到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//可以删除
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;需要删除的%d节点不存在\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="显示链表信息-1">⑤显示链表信息&lt;/h4>
&lt;p>在显示链表信息之前，需要先判断链表是否为空，并给出相关信息。通过后移临时变量temp完成遍历。先输出结点信息，每当输出一个结点信息，就需要后移一次。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">//显示链表，遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">show&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">//判断链表是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;链表为空&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">//因为头节点不能动，因此我们需要一个辅助变量来遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">HeroNode&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 判断是否到链表最后
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//输出节点的信息
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">//将temp后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">next&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>到此，我们了解了有关单链表的相关操作。在算法实现过程中，可能不少小朋友会发现一些问题，比如为什么有时候临时变量 &lt;strong>temp = head.next&lt;/strong> ， 而有时却变成了&lt;strong>temp = head&lt;/strong> 了呢？？其实仔细阅读一遍代码，我们不难发现，当进行增删操作的时候，&lt;strong>temp = head&lt;/strong> ，那是因为需要增删的结点刚好是直接添加到头结点之后的，如果变成了 &lt;strong>head.next&lt;/strong> ， 则会造成覆盖结点的情况；而在进行修改和遍历的时候，临时变量 &lt;strong>temp = head.next&lt;/strong> ，那是因为我们这里定义头结点为空，不存放任何数据，所以修改和遍历的时候，需要从真正的有效结点开始。&lt;/p>
&lt;p>源码已经push到 ——&amp;gt;&lt;a href="https://github.com/QuakeWang/DataStructes">数据结构&lt;/a>&lt;/p></content></entry><entry><title type="text">数据结构--数组模拟环形队列</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/circlearrayqueue/"/><id>https://quakewang.github.io/tech/circlearrayqueue/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-05-27T13:49:32+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">数组模拟环形队列 一、前言 在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程……</summary><content type="html">&lt;h1 id="数组模拟环形队列">数组模拟环形队列&lt;/h1>
&lt;hr>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1初始化相关变量">1、初始化相关变量&lt;/h3>
&lt;p>需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对&lt;strong>front&lt;/strong>和&lt;strong>rear&lt;/strong>做以下调整：&lt;strong>front&lt;/strong>由原来指向队列的前一个位置，改变为队列的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；&lt;strong>rear&lt;/strong>从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为&lt;strong>maxSize - 1&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 表示数组的最大容量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">rear&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 该数组用于存放数据，模拟队列
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 构造器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">CircleArray&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">maxSize&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">maxSize&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2判断队列是否为满">2、判断队列是否为满&lt;/h3>
&lt;p>我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针&lt;strong>下一个位置&lt;/strong>是头指针的时候，表示队列满。（&lt;em>在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满&lt;/em>）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 &lt;strong>(rear + 1) % maxSize == front&lt;/strong> 。( &lt;em>这里取模的目的就是为了整合rear和front大小为一个问题&lt;/em> )&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 判断队列是否为满
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isFull&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">rear&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">maxSize&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3判断队列是否为空">3、判断队列是否为空&lt;/h3>
&lt;p>因为front和rear的初始值相同，所以判断队列空的方法与之前一样。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 判断队列是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4求出当前队列的有效数据个数">4、求出当前队列的有效数据个数&lt;/h3>
&lt;p>这个方法与之前相比是新添加的，其目的是为了判断遍历队列的长度。队列的有效数据的个数 = 尾队列 - 头队列，但有时front比rear大，有时front比rear小，所以可以通过取模的方式来实现。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 求出当前队列的有效数据的个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">rear&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">maxSize&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="5入队列">5、入队列&lt;/h3>
&lt;p>添加数据入队的操作和之前相类似，只不过该队列front指向队列的第一个元素的位置，所以需要进行先赋值，然后再后移。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 添加数据入队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">addQueue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;该队列已满，，无法添加任何数据~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">rear&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 直接将数据加入
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">rear&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 将rear后移，这里必须考虑取模
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="6出队列">6、出队列&lt;/h3>
&lt;p>&lt;del>之前由于头指针指向队列的前一个位置，所以先后移，到达需要取出数据的位置，从而返回即可&lt;/del> 。但此时头指针所在的位置就是需要取出的位置，如果直接返回则无法进行后移，如果先后移，则取出的数据就是下一个位置的数据。我们可以做一下处理，从而达到想要的效果：&lt;/p>
&lt;ol>
&lt;li>先把front对应的值保留到一个临时变量；&lt;/li>
&lt;li>将front后移，考虑取模&lt;/li>
&lt;li>将临时保存的变量返回&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 从队列中取出数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getQueue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;该队列为空，无任何数据可以取出~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">front&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="7显示队列的所有数据">7、显示队列的所有数据&lt;/h3>
&lt;p>在遍历的时候，我们需要注意到因为是环形队列，需要从front开始遍历，遍历到什么位置结束呢？？ 在之前我们已经求出了有效数据的个数，所以遍历元素为 &lt;strong>front + size()&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 显示队列的所有数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">show&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;该队列为空，无任何数据可以显示~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 遍历时，从front开始遍历，遍历元素为 front+有效数据的个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;arr[%d]=%d\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="8显示队列的头数据">8、显示队列的头数据&lt;/h3>
&lt;p>因为front指向的队列的一个元素的位置，所以直接返回即可。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 显示队列的头数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">headQueue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;该队列为空，无头数据可显示~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>到此，我们了解了关于数组模拟循环队列的相关操作，在判断队列是为满的时候，可以尝试画图理解，（记住要队列要空出一个位置，留作约定哦！）还有一个难点，求出有效数据个数。其余方法，根据数组模拟队列做出相应的调整即可（由于front和rear指向的位置不同而做出的改变）。&lt;/p>
&lt;p>源码地址 ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructes">数据结构&lt;/a>&lt;/p></content></entry><entry><title type="text">数据结构--数组模拟队列</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/arrayqueue/"/><id>https://quakewang.github.io/tech/arrayqueue/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-05-21T21:26:33+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">数组模拟队列 一、基本介绍 1、队列介绍： 队列是只允许在一段进行插入操作，而在另一端进行……</summary><content type="html">&lt;h1 id="数组模拟队列">数组模拟队列&lt;/h1>
&lt;hr>
&lt;h2 id="一基本介绍">一、基本介绍&lt;/h2>
&lt;h3 id="1队列介绍">1、队列介绍：&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用&lt;strong>数组&lt;/strong>或是&lt;strong>链表&lt;/strong>来实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>遵循&lt;strong>先入先出&lt;/strong>的原则，允许插入的一端称为队尾，允许删除的一端称队头。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="2举例说明">2、举例说明：&lt;/h3>
&lt;p>队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是&lt;strong>先入先出&lt;/strong>的原则。&lt;/p>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1所需元素及其方法">1、所需元素及其方法&lt;/h3>
&lt;p>在实现数组模拟队列的时候，我们需要先定义一个&lt;strong>ArrayQueue&lt;/strong>类来存放所需的元素以及相关方法，所需元素有：数组&lt;strong>arr[]&lt;/strong>：用于存放数据，模拟队列；数组的最大容量&lt;strong>maxSize&lt;/strong>；队列头&lt;strong>front&lt;/strong>；以及队列尾&lt;strong>rear&lt;/strong>。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 表示数组的最大容量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">front&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 队列头
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">rear&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 队列尾
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 该数组用于存放数据，模拟队列
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2初始化相关变量">2、初始化相关变量&lt;/h3>
&lt;p>在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量&lt;strong>maxSize&lt;/strong>，这时数组可以存放maxSize的数据，但数组下标的范围为&lt;strong>arr[0]--arr[maxSize - 1]&lt;/strong>。为front和rear赋值为-1，即队列的前一个位置。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 创建队列的构造器
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="nf">ArrayQueue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">maxSize&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">maxSize&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">maxSize&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">front&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向队列头部，front是指向队列头的前一个位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 指向队列的尾部，rear是队列最后一个数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3判断队列是否为满">3、判断队列是否为满&lt;/h3>
&lt;p>​ 在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在&lt;em>不断变大&lt;/em>。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即&lt;strong>rear == arr[maxSize - 1]&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 判断队列是否为满
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isFull&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">rear&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">maxSize&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4判断队列是否为空">4、判断队列是否为空&lt;/h3>
&lt;p>​ 在初始状态下，front和rear均指向下标为-1的&lt;strong>同一个位置&lt;/strong>，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向&lt;strong>同一个下标&lt;/strong>的时候，表示所有数据已经全部出队列。所以当&lt;strong>rear == front&lt;/strong>时，队列空。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 判断队列是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">rear&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="5添加数据到队列">5、添加数据到队列&lt;/h3>
&lt;p>在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（&lt;em>注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置&lt;/em>）&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 添加数据到队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">addQueue&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 首先判断队列是否为满
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;该队列已满，无法添加任何数据~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">rear&lt;/span>&lt;span class="o">++;&lt;/span>&lt;span class="c1">// 让rear后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">rear&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="6取出队列的数据">6、取出队列的数据&lt;/h3>
&lt;p>在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 获取队列的数据，出队列
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">getQueue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 首先判断队列是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="c1">// 这里可以通过抛出异常处理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;该队列为空，无法取出任何数据&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">front&lt;/span>&lt;span class="o">++;&lt;/span>&lt;span class="c1">// 让front后移
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="7显示队列所有数据">7、显示队列所有数据&lt;/h3>
&lt;p>我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。注意在执行出队列的操作之后，front的值也随之后移，而且front指向的位置为队列的前一个位置，所以遍历的起始位置应该为&lt;strong>front + 1&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 显示队列所有数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">showQueue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先判断是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;该队列为空，无数据可显示~&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 遍历
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">front&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;arr[%d]=%d\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="8显示队列头的信息">8、显示队列头的信息&lt;/h3>
&lt;p>需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要&lt;strong>front + 1&lt;/strong>。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 显示头队列的信息，注意不是取出数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">headQueue&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先判断是否为空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;队列为空，无数据可显示&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">front&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="三结束语">三、结束语&lt;/h2>
&lt;p>至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——&amp;gt; &lt;a href="https://github.com/QuakeWang/DataStructes">数据结构&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>《大话数据结构》——程杰&lt;/p>
&lt;p>图解数据结构与算法——韩顺平&lt;/p>
&lt;/blockquote></content></entry><entry><title type="text">数据结构--稀疏数组</title><link rel="alternate" type="text/html" href="https://quakewang.github.io/tech/sparsearray/"/><id>https://quakewang.github.io/tech/sparsearray/</id><updated>2021-01-23T11:17:40+00:00</updated><published>2020-05-15T14:45:36+08:00</published><author><name>AKA二夕</name><uri>https://quakewang.github.io/</uri><email>wangfuzheng0814@foxmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">稀疏数组 一、基本介绍 1、实际需求 假设一个五子棋盘，用1表示黑子，2表示白子，0表示空……</summary><content type="html">&lt;h1 id="稀疏数组">稀疏数组&lt;/h1>
&lt;hr>
&lt;h2 id="一基本介绍">一、基本介绍&lt;/h2>
&lt;h3 id="1实际需求">1、实际需求&lt;/h3>
&lt;p>假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：&lt;/p>
&lt;pre>&lt;code class="language-0" data-lang="0"> 0 0 0 2 0 0 0 0 0 0 0
0 0 0 1 2 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
&lt;/code>&lt;/pre>&lt;p>那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用&lt;strong>稀疏数组&lt;/strong>来保存该数组。&lt;/p>
&lt;h3 id="2相关概念">2、相关概念&lt;/h3>
&lt;p>基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="center">行&lt;/th>
&lt;th align="center">列&lt;/th>
&lt;th align="center">值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="center">A&lt;/td>
&lt;td align="center">B&lt;/td>
&lt;td align="center">C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">E&lt;/td>
&lt;td align="center">F&lt;/td>
&lt;td align="center">G&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>A：表示总行数&lt;/li>
&lt;li>B：表示总列数&lt;/li>
&lt;li>C：表示真正有效数值的个数（除0外的数值）&lt;/li>
&lt;li>E：表示该元素所在的行&lt;/li>
&lt;li>F：表示该元素所在的列&lt;/li>
&lt;li>G：表示该元素的数值&lt;/li>
&lt;/ul>
&lt;p>所以上述原始的二维数组转化成稀疏数组，应该如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>row&lt;/th>
&lt;th>col&lt;/th>
&lt;th align="center">value&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>10&lt;/td>
&lt;td align="center">4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>3&lt;/td>
&lt;td align="center">2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>3&lt;/td>
&lt;td align="center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>4&lt;/td>
&lt;td align="center">2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td align="center">1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>​&lt;/p>
&lt;hr>
&lt;h2 id="二算法实现">二、算法实现&lt;/h2>
&lt;h3 id="1创建并输出原始二维数组">1、创建并输出原始二维数组&lt;/h3>
&lt;h4 id="创建原始的二维数组">&lt;em>①创建原始的二维数组：&lt;/em>&lt;/h4>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="c1">// 0表示没有棋子，1表示黑子，2表示白子
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">chessArr1&lt;/span>&lt;span class="o">[][]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="o">];&lt;/span>&lt;span class="c1">// 创建一个原始的二维数组 10*10
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">chessArr1&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">chessArr1&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">chessArr1&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">chessArr1&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="打印输出原始的二维数组">&lt;em>②打印输出原始的二维数组：&lt;/em>&lt;/h4>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">chessArr1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">data&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%d\t&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2将二维数组转换成稀疏数组">2、将二维数组转换成稀疏数组&lt;/h3>
&lt;h4 id="先遍历二维数组记录非0数值的个数">&lt;em>①先遍历二维数组，记录非0数值的个数&lt;/em>&lt;/h4>
&lt;p>​ 遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kt">int&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// 用于记录非0数值的个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">chessArr1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">chessArr1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">chessArr1&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">sum&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="创建对应的二维数组">&lt;em>②创建对应的二维数组&lt;/em>&lt;/h4>
&lt;p>​ 在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kt">int&lt;/span> &lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[][]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">sum&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="c1">// 给稀疏数组赋值
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">10&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">10&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="遍历二维数组将非0的值存放到-sparsearr-中">&lt;em>③遍历二维数组，将非0的值存放到 sparseArr 中&lt;/em>&lt;/h4>
&lt;p>​ 在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>&lt;span class="c1">// count用于记录是第几个非0数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">sparseArr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">sparseArr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">chessArr1&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">count&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">chessArr1&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="打印输出稀疏数组">&lt;em>④打印输出稀疏数组&lt;/em>&lt;/h4>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">sparseArr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%d\t%d\t%d\t\n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span>&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">],&lt;/span>&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">],&lt;/span>&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="3将稀疏数组恢复成原始的二维数组">3、将稀疏数组恢复成原始的二维数组&lt;/h3>
&lt;h4 id="先读取稀疏数组的第一行根据第一行的数据创建原始的二维数组">&lt;em>①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组&lt;/em>&lt;/h4>
&lt;p>​ 将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kt">int&lt;/span> &lt;span class="n">chessArr2&lt;/span>&lt;span class="o">[][]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]][&lt;/span>&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]];&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="再读取稀疏数组后后几行的数据--从第二行开始">&lt;em>②再读取稀疏数组后后几行的数据&lt;/em> &lt;strong>（从第二行开始！！！）&lt;/strong>&lt;/h4>
&lt;p>​ 因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i = 1; 读取所有非0数据即可，其余的位置，默认值为0。&lt;/p>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">sparseArr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">chessArr2&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]][&lt;/span>&lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sparseArr&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="输出恢复后的二维数组">&lt;em>③输出恢复后的二维数组&lt;/em>&lt;/h4>
&lt;p>&lt;strong>代码实现如下：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">chessArr2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">data&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%d\t&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="三结束语">三、结束语：&lt;/h2>
&lt;p>​ 第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！&lt;/p>
&lt;p>​ 源码我已push到我的Github仓库，&lt;a href="https://github.com/QuakeWang/DataStructes">数据结构&lt;/a>，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！&lt;/p></content></entry></feed>