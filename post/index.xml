<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>https://quakewang.github.io/post/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 01 Jun 2020 21:22:48 +0800</lastBuildDate>
    
	<atom:link href="https://quakewang.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>单链表的使用</title>
      <link>https://quakewang.github.io/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jun 2020 21:22:48 +0800</pubDate>
      
      <guid>https://quakewang.github.io/post/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>单链表的应用举例 一、前言 在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操作：
 获取单链表的有效结点 查找单链表中的倒数第k个结点 逆序打印单链表（从尾到头打印） 反转单链表   二、算法介绍 1、获取单链表的有效结点 作为使用的第一个方法难度不是很大。因为需要求出单链表中有效结点的个数，所以我们可分为带头结点和不带头结点两种情况。
我们这边考虑的是不带头结点的单链表，（如果是带头结点的链表需要再加上头结点即可）。需要的变量有length(统计链表的长度)和cur(辅助变量，用于遍历)，可以通过传入一个头结点，然后依次遍历该链表，当链表遍历到最后的时候，即cur.next == null，每一次遍历链表的长度加一，即length++。
代码实现如下：
// head链表的头结点，返回的就是有效结点的个数  public static int getLength(HeroNode head) { if (head.next == null) {// 链表为空  return 0; } int length = 0; HeroNode cur = head.next;// 定义一个辅助变量  while (cur != null) { length++; cur = cur.next; } return length; } 2、查找单链表中的倒数第k个结点 因为单链表是单向的，只能从头到尾开始遍历，而无法从后往前遍历，所以我们需要传入一个头结点head（遍历的起始位置）和index(倒数第k个结点)。
定义一个size表示链表的长度，也就是链表有效结点的个数，可以通过方法一来获取。即size = getLength(head)，然后需要定义一个辅助变量用于遍历。然后通过for循环定位到倒数的index，即size - index的位置，也就是需要查找的倒数第k个结点。最后返回当前的辅助变量，完成查找。
代码实现如下：
public static HeroNode findLastIndexNode(HeroNode head, int index) { // 判断链表是否为空，如果是则返回null  if (head.</description>
    </item>
    
    <item>
      <title>数据结构--单向链表</title>
      <link>https://quakewang.github.io/post/singlelinkedlist/</link>
      <pubDate>Sat, 30 May 2020 16:23:52 +0800</pubDate>
      
      <guid>https://quakewang.github.io/post/singlelinkedlist/</guid>
      <description>单向链表 一、基本介绍 1、相关定义 链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的，且链表的长度不是固定的。链表的每个元素称为一个结点，每个结点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑关系，以便构成“一个结点链着一个结点”的链式存储结构，为了保持每个结点之间的链接，所以链表除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个结点都包含两个部分，第一部分用于存储元素本身的数据信息，称为数据域，它不局限于一个成员数据，也可是多个成员数据；第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的节点信息，这里用next表，next的值实际上就是下一个结点的地址，当前结点为末结点时，next的值设为空指针，即为null。链表在使用过程中，可以根据实际需求来判断是否需要添加头结点。
2、链表与数组比较 数组（包括结构体数组）的实质是一种线性表的顺序表示方式，它的优点是使用直观，便于快速、随机地存取线性表中的任一元素，但缺点是对其进行插入和删除操作时需要移动大量的数组元素，同时由于数组属于静态内存分配，定义数组时必须指定数组的长度，程序一旦运行，其长度就不能再改变，实际使用个数不能超过数组元素最大长度的限制，否则就会发生下标越界的错误，低于最大长度时又会造成系统资源的浪费，因此空间效率差。
 二、算法实现 我们需要定义一个类用来存放结点信息，同时也还需要定义一个类用于管理结点，实现单链表的增删改查。
1、定义一个HeroNode类表示结点 我们需要在HeroNode类中实现相关变量的定义、赋值以及显示信息的方法。
① 相关变量 这里我们使用单链表来存储水浒英雄，需要存储的信息有：编号、姓名和昵称。还需要定义一个next域用于指向下一个结点。
代码实现如下：
public int no;// 编号  public String name;// 姓名  public String nickname;// 昵称  public HeroNode next;// next域，指向下一个节点 ②构造器 可以利用构造器对相关变量进行赋值。
代买实现如下：
public HeroNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; } ③显示链表信息 我们可以使用toString方法来显示链表的信息。
代码实现如下：
// 利用toString显示信息  @Override public String toString() { return &amp;#34;HeroNode{&amp;#34; + &amp;#34;no=&amp;#39;&amp;#34; + no + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, nickname=&amp;#34; + nickname + &amp;#39;}&amp;#39;; } 2、定义一个SingleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。</description>
    </item>
    
    <item>
      <title>数据结构--数组模拟环形队列</title>
      <link>https://quakewang.github.io/post/circlearrayqueue/</link>
      <pubDate>Wed, 27 May 2020 13:49:32 +0800</pubDate>
      
      <guid>https://quakewang.github.io/post/circlearrayqueue/</guid>
      <description>数组模拟环形队列  一、前言 在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。
 二、算法实现 1、初始化相关变量 需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对front和rear做以下调整：front由原来指向队列的前一个位置，改变为队列的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；rear从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为maxSize - 1。
代码实现如下：
private int maxSize;// 表示数组的最大容量  private int front;// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素  private int rear;// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0  private int[] arr;// 该数组用于存放数据，模拟队列  // 构造器  public CircleArray(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = 0; rear = 0; } 2、判断队列是否为满 我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针下一个位置是头指针的时候，表示队列满。（在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 (rear + 1) % maxSize == front 。( 这里取模的目的就是为了整合rear和front大小为一个问题 )
代码实现如下：
// 判断队列是否为满  public boolean isFull() { return (rear + 1) % maxSize == front; } 3、判断队列是否为空 因为front和rear的初始值相同，所以判断队列空的方法与之前一样。</description>
    </item>
    
    <item>
      <title>数据结构--数组模拟队列</title>
      <link>https://quakewang.github.io/post/arrayqueue/</link>
      <pubDate>Thu, 21 May 2020 21:26:33 +0800</pubDate>
      
      <guid>https://quakewang.github.io/post/arrayqueue/</guid>
      <description>数组模拟队列  一、基本介绍 1、队列介绍：   队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用数组或是链表来实现。
  遵循先入先出的原则，允许插入的一端称为队尾，允许删除的一端称队头。
  2、举例说明： 队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是先入先出的原则。
二、算法实现 1、所需元素及其方法 在实现数组模拟队列的时候，我们需要先定义一个ArrayQueue类来存放所需的元素以及相关方法，所需元素有：数组arr[]：用于存放数据，模拟队列；数组的最大容量maxSize；队列头front；以及队列尾rear。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。
代码实现如下：
private int maxSize;// 表示数组的最大容量  private int front;// 队列头  private int rear;// 队列尾  private int[] arr;// 该数组用于存放数据，模拟队列 2、初始化相关变量 在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量maxSize，这时数组可以存放maxSize的数据，但数组下标的范围为arr[0]&amp;ndash;arr[maxSize - 1]。为front和rear赋值为-1，即队列的前一个位置。
代码实现如下：
// 创建队列的构造器  public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1;// 指向队列头部，front是指向队列头的前一个位置  rear = -1;// 指向队列的尾部，rear是队列最后一个数据  } 3、判断队列是否为满 ​	在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在不断变大。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即rear == arr[maxSize - 1]。</description>
    </item>
    
    <item>
      <title>数据结构--稀疏数组</title>
      <link>https://quakewang.github.io/post/sparsearray/</link>
      <pubDate>Fri, 15 May 2020 14:45:36 +0800</pubDate>
      
      <guid>https://quakewang.github.io/post/sparsearray/</guid>
      <description>稀疏数组  一、基本介绍 1、实际需求 假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：
0 0 0 2 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用稀疏数组来保存该数组。</description>
    </item>
    
    <item>
      <title>Hello World ! Hello Blog !</title>
      <link>https://quakewang.github.io/post/hello/</link>
      <pubDate>Sun, 10 May 2020 21:55:40 +0800</pubDate>
      
      <guid>https://quakewang.github.io/post/hello/</guid>
      <description>前言 大政的Blog就这样稀里糊涂的开通了。
 有时候闲着无聊，总想着写点什么，可能是乱七八糟的想法，可能是一段书评，也有可能是一段歌词。因为相对于话语的直白，文字能表达的情感是更加细腻的，它也可以将有些事情一直保存下去。
也有可能是我天生就有点内向，甚至比较丧，不太喜欢说话。
 当时之所以想开通Blog最主要是想督促自己保持学习的习惯，并且可以在这里记录一些关于学习的笔记。也有一部分原因是在这段时间接触了许多之前没有接触过的人和事，总想着这些美好的事和可爱的人更应该被文字所记录，而不是埋藏在我的心里。
所以博客的内容可能是一串代码，一行文字，一条书评，一段歌词，或许是一句心里话。
我既做不上神明，那当个野兽也好。</description>
    </item>
    
  </channel>
</rss>