
  
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/05/10/hello-world-hello-blog/">Hello World ! Hello Blog !</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h2 id="前言">前言</h2>
<p>大政的Blog就这样稀里糊涂的开通了。</p>
<hr>
<p><em><strong>有时候闲着无聊，总想着写点什么，可能是乱七八糟的想法，可能是一段书评，也有可能是一段歌词。因为相对于话语的直白，文字能表达的情感是更加细腻的，它也可以将有些事情一直保存下去。</strong></em></p>
<p><em><strong>也有可能是我天生就有点内向，甚至比较丧，不太喜欢说话。</strong></em></p>
<hr>
<p>当时之所以想开通Blog最主要是想督促自己保持学习的习惯，并且可以在这里记录一些关于学习的笔记。也有一部分原因是在这段时间接触了许多之前没有接触过的人和事，总想着这些美好的事和可爱的人更应该被文字所记录，而不是埋藏在我的心里。</p>
<p>所以博客的内容可能是<em>一串代码，一行文字，一条书评，一段歌词，或许是一句心里话</em>。</p>
<p><del>我既做不上神明，那当个野兽也好。</del></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-05-10T21:55:40&#43;08:00">
            10 May 2020
        </time>
    </footer>
</article>


  
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/">数据结构--数组模拟环形队列</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="数组模拟环形队列">数组模拟环形队列</h1>
<hr>
<h2 id="一前言">一、前言</h2>
<p>在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。</p>
<hr>
<h2 id="二算法实现">二、算法实现</h2>
<h3 id="1初始化相关变量">1、初始化相关变量</h3>
<p>需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对<strong>front</strong>和<strong>rear</strong>做以下调整：<strong>front</strong>由原来指向队列的前一个位置，改变为队列对的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；<strong>rear</strong>从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为<strong>maxSize - 1</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">;</span><span style="color:#75715e">// 表示数组的最大容量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> front<span style="color:#f92672">;</span><span style="color:#75715e">// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> rear<span style="color:#f92672">;</span><span style="color:#75715e">// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">;</span><span style="color:#75715e">// 该数组用于存放数据，模拟队列
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 构造器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CircleArray</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maxSize</span> <span style="color:#f92672">=</span> maxSize<span style="color:#f92672">;</span>
        arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>maxSize<span style="color:#f92672">];</span>
        front <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        rear <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="2判断队列是否为满">2、判断队列是否为满</h3>
<p>我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针<strong>下一个位置</strong>是头指针的时候，表示队列满。（<em>在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满</em>）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 <strong>(rear + 1) % maxSize == front</strong> 。( <em>这里取模的目的就是为了整合rear和front大小为一个问题</em> )</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 判断队列是否为满
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isFull</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>rear <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxSize <span style="color:#f92672">==</span> front<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="3判断队列是否为空">3、判断队列是否为空</h3>
<p>因为front和rear的初始值相同，所以判断队列空的方法与之前一样。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 判断队列是否为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> rear <span style="color:#f92672">==</span> front<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="4求出当前队列的有效数据个数">4、求出当前队列的有效数据个数</h3>
<p>这个方法与之前相比是新添加的，其目的是为了判断遍历队列的长度。队列的有效数据的个数 = 尾队列 - 头队列，但有时front比rear大，有时front比rear小，所以可以通过取模的方式来实现。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 求出当前队列的有效数据的个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>rear <span style="color:#f92672">+</span> maxSize <span style="color:#f92672">-</span> front<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="5入队列">5、入队列</h3>
<p>添加数据入队的操作和之前相类似，只不过该队列front指向队列的第一个元素的位置，所以需要进行先赋值，然后再后移。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 添加数据入队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addQueue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isFull<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列已满，，无法添加任何数据~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        arr<span style="color:#f92672">[</span>rear<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span><span style="color:#75715e">// 直接将数据加入
</span><span style="color:#75715e"></span>        rear <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>rear <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">;</span><span style="color:#75715e">// 将rear后移，这里必须考虑取模
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="6出队列">6、出队列</h3>
<p>~~之前由于头指针指向队列的前一个位置，所以先后移，到达需要取出数据的位置，从而返回即可。~~但此时头指针所在的位置就是需要取出的位置，如果直接返回则无法进行后移，如果先后移，则取出的数据就是下一个位置的数据。我们可以做一下处理，从而达到想要的效果：</p>
<ol>
<li>先把front对应的值保留到一个临时变量；</li>
<li>将front后移，考虑取模</li>
<li>将临时保存的变量返回</li>
</ol>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 从队列中取出数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无任何数据可以取出~&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>front<span style="color:#f92672">];</span>
        front <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>front <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> val<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="7显示队列的所有数据">7、显示队列的所有数据</h3>
<p>在遍历的时候，我们需要注意到因为是环形队列，需要从front开始遍历，遍历到什么位置结束呢？？ 在之前我们已经求出了有效数据的个数，所以遍历元素为 <strong>front + size()</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 显示队列的所有数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">show</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无任何数据可以显示~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 遍历时，从front开始遍历，遍历元素为 front+有效数据的个数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> front<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> front <span style="color:#f92672">+</span> size<span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;arr[%d]=%d\n&#34;</span><span style="color:#f92672">,</span> i <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">,</span> arr<span style="color:#f92672">[</span>i <span style="color:#f92672">%</span> maxSize<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="8显示队列的头数据">8、显示队列的头数据</h3>
<p>因为front指向的队列的一个元素的位置，所以直接返回即可。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 显示队列的头数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">headQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无头数据可显示~&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>front<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

</code></pre></div><hr>
<h2 id="三结束语">三、结束语</h2>
<p>到此，我们了解了关于数组模拟循环队列的相关操作，在判断队列是为满的时候，可以尝试画图理解，（记住要队列要空出一个位置，留作约定哦！）还有一个难点，求出有效数据个数。其余方法，根据数组模拟队列做出相应的调整即可（由于front和rear指向的位置不同而做出的改变）。</p>
<p>源码地址 ——&gt; <a href="https://github.com/QuakeWang/DataStructes">数据结构</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-05-27T13:49:32&#43;08:00">
            27 May 2020
        </time>
    </footer>
</article>


  
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/">数据结构--数组模拟队列</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="数组模拟队列">数组模拟队列</h1>
<hr>
<h2 id="一基本介绍">一、基本介绍</h2>
<h3 id="1队列介绍">1、队列介绍：</h3>
<ol>
<li>
<p>队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用<strong>数组</strong>或是<strong>链表</strong>来实现。</p>
</li>
<li>
<p>遵循<strong>先入先出</strong>的原则，允许插入的一端称为队尾，允许删除的一端称队头。</p>
</li>
</ol>
<h3 id="2举例说明">2、举例说明：</h3>
<p>队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是<strong>先入先出</strong>的原则。</p>
<h2 id="二算法实现">二、算法实现</h2>
<h3 id="1所需元素及其方法">1、所需元素及其方法</h3>
<p>在实现数组模拟队列的时候，我们需要先定义一个<strong>ArrayQueue</strong>类来存放所需的元素以及相关方法，所需元素有：数组<strong>arr[]</strong>：用于存放数据，模拟队列；数组的最大容量<strong>maxSize</strong>；队列头<strong>front</strong>；以及队列尾<strong>rear</strong>。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">;</span><span style="color:#75715e">// 表示数组的最大容量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> front<span style="color:#f92672">;</span><span style="color:#75715e">// 队列头
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> rear<span style="color:#f92672">;</span><span style="color:#75715e">// 队列尾
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">;</span><span style="color:#75715e">// 该数组用于存放数据，模拟队列
</span></code></pre></div><h3 id="2初始化相关变量">2、初始化相关变量</h3>
<p>在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量<strong>maxSize</strong>，这时数组可以存放maxSize的数据，但数组下标的范围为<strong>arr[0]&ndash;arr[maxSize - 1]</strong>。为front和rear赋值为-1，即队列的前一个位置。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 创建队列的构造器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ArrayQueue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maxSize</span> <span style="color:#f92672">=</span> maxSize<span style="color:#f92672">;</span>
        arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>maxSize<span style="color:#f92672">];</span>
        front <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span><span style="color:#75715e">// 指向队列头部，front是指向队列头的前一个位置
</span><span style="color:#75715e"></span>        rear <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span><span style="color:#75715e">// 指向队列的尾部，rear是队列最后一个数据
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="3判断队列是否为满">3、判断队列是否为满</h3>
<p>​		在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在<em>不断变大</em>。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即<strong>rear == arr[maxSize - 1]</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 判断队列是否为满
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isFull</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> rear <span style="color:#f92672">==</span> maxSize <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="4判断队列是否为空">4、判断队列是否为空</h3>
<p>​		在初始状态下，front和rear均指向下标为-1的<strong>同一个位置</strong>，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向<strong>同一个下标</strong>的时候，表示所有数据已经全部出队列。所以当<strong>rear == front</strong>时，队列空。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 判断队列是否为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> front <span style="color:#f92672">==</span> rear<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="5添加数据到队列">5、添加数据到队列</h3>
<p>在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（<em>注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置</em>）</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 添加数据到队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addQueue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 首先判断队列是否为满
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isFull<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列已满，无法添加任何数据~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        rear<span style="color:#f92672">++;</span><span style="color:#75715e">// 让rear后移
</span><span style="color:#75715e"></span>        arr<span style="color:#f92672">[</span>rear<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="6取出队列的数据">6、取出队列的数据</h3>
<p>在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 获取队列的数据，出队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 首先判断队列是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span><span style="color:#75715e">// 这里可以通过抛出异常处理
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无法取出任何数据&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        front<span style="color:#f92672">++;</span><span style="color:#75715e">// 让front后移
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>front<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="7显示队列所有数据">7、显示队列所有数据</h3>
<p>我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。注意在执行出队列的操作之后，front的值也随之后移，而且front指向的位置为队列的前一个位置，所以遍历的起始位置应该为<strong>front + 1</strong>。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 显示队列所有数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">showQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 先判断是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;该队列为空，无数据可显示~&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// 遍历
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> front <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;arr[%d]=%d\n&#34;</span><span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h3 id="8显示队列头的信息">8、显示队列头的信息</h3>
<p>需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要<strong>front + 1</strong>。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">// 显示头队列的信息，注意不是取出数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">headQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 先判断是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;队列为空，无数据可显示&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>front <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="三结束语">三、结束语</h2>
<p>至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——&gt; <a href="https://github.com/QuakeWang/DataStructes">数据结构</a>。</p>
<blockquote>
<p>《大话数据结构》——程杰</p>
<p>图解数据结构与算法——韩顺平</p>
</blockquote>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-05-21T21:26:33&#43;08:00">
            21 May 2020
        </time>
    </footer>
</article>


  
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://quakewang.github.io/post/2020/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/">数据结构--稀疏数组</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="稀疏数组">稀疏数组</h1>
<hr>
<h2 id="一基本介绍">一、基本介绍</h2>
<h3 id="1实际需求">1、实际需求</h3>
<p>假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：</p>
<pre><code class="language-0" data-lang="0">              0 0 0 2 0 0 0 0 0 0 0
              0 0 0 1 2 0 0 0 0 0 0
              0 0 0 1 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
              0 0 0 0 0 0 0 0 0 0 0
</code></pre><p>那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用<strong>稀疏数组</strong>来保存该数组。</p>
<h3 id="2相关概念">2、相关概念</h3>
<p>基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：</p>
<table>
<thead>
<tr>
<th align="center">行</th>
<th align="center">列</th>
<th align="center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">A</td>
<td align="center">B</td>
<td align="center">C</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">F</td>
<td align="center">G</td>
</tr>
</tbody>
</table>
<ul>
<li>A：表示总行数</li>
<li>B：表示总列数</li>
<li>C：表示真正有效数值的个数（除0外的数值）</li>
<li>E：表示该元素所在的行</li>
<li>F：表示该元素所在的列</li>
<li>G：表示该元素的数值</li>
</ul>
<p>所以上述原始的二维数组转化成稀疏数组，应该如下：</p>
<table>
<thead>
<tr>
<th>row</th>
<th>col</th>
<th align="center">value</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>10</td>
<td align="center">4</td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td align="center">2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td align="center">1</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td align="center">2</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<p>​</p>
<hr>
<h2 id="二算法实现">二、算法实现</h2>
<h3 id="1创建并输出原始二维数组">1、创建并输出原始二维数组</h3>
<h4 id="创建原始的二维数组"><em>①创建原始的二维数组：</em></h4>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	      <span style="color:#75715e">// 0表示没有棋子，1表示黑子，2表示白子
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> chessArr1<span style="color:#f92672">[][]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>10<span style="color:#f92672">][</span>10<span style="color:#f92672">];</span><span style="color:#75715e">// 创建一个原始的二维数组 10*10
</span><span style="color:#75715e"></span>        chessArr1<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
        chessArr1<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>4<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
        chessArr1<span style="color:#f92672">[</span>2<span style="color:#f92672">][</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
        chessArr1<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>				
</code></pre></div><h4 id="打印输出原始的二维数组"><em>②打印输出原始的二维数组：</em></h4>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> row <span style="color:#f92672">:</span> chessArr1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> data <span style="color:#f92672">:</span> row<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;%d\t&#34;</span><span style="color:#f92672">,</span> data<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
</code></pre></div><h3 id="2将二维数组转换成稀疏数组">2、将二维数组转换成稀疏数组</h3>
<h4 id="先遍历二维数组记录非0数值的个数"><em>①先遍历二维数组，记录非0数值的个数</em></h4>
<p>​		遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span><span style="color:#75715e">// 用于记录非0数值的个数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> chessArr1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> chessArr1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>chessArr1<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    sum<span style="color:#f92672">++;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
</code></pre></div><h4 id="创建对应的二维数组"><em>②创建对应的二维数组</em></h4>
<p>​		在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">int</span> sparseArr<span style="color:#f92672">[][]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>sum <span style="color:#f92672">+</span> 1<span style="color:#f92672">][</span>3<span style="color:#f92672">];</span>
        <span style="color:#75715e">// 给稀疏数组赋值
</span><span style="color:#75715e"></span>        sparseArr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>
        sparseArr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>
        sparseArr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> sum<span style="color:#f92672">;</span>
</code></pre></div><h4 id="遍历二维数组将非0的值存放到-sparsearr-中"><em>③遍历二维数组，将非0的值存放到 sparseArr 中</em></h4>
<p>​		在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span><span style="color:#75715e">// count用于记录是第几个非0数据
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> sparseArr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> sparseArr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>chessArr1<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    count<span style="color:#f92672">++;</span>
                    sparseArr<span style="color:#f92672">[</span>count<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
                    sparseArr<span style="color:#f92672">[</span>count<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
                    sparseArr<span style="color:#f92672">[</span>count<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> chessArr1<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">];</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
</code></pre></div><h4 id="打印输出稀疏数组"><em>④打印输出稀疏数组</em></h4>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">				<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> sparseArr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
           System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;%d\t%d\t%d\t\n&#34;</span><span style="color:#f92672">,</span>sparseArr<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>0<span style="color:#f92672">],</span>sparseArr<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>1<span style="color:#f92672">],</span>sparseArr<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>2<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
</code></pre></div><h3 id="3将稀疏数组恢复成原始的二维数组">3、将稀疏数组恢复成原始的二维数组</h3>
<h4 id="先读取稀疏数组的第一行根据第一行的数据创建原始的二维数组"><em>①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</em></h4>
<p>​		将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">			<span style="color:#66d9ef">int</span> chessArr2<span style="color:#f92672">[][]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>sparseArr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>0<span style="color:#f92672">]][</span>sparseArr<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>1<span style="color:#f92672">]];</span>
</code></pre></div><h4 id="再读取稀疏数组后后几行的数据--从第二行开始"><em>②再读取稀疏数组后后几行的数据</em>  <strong>（从第二行开始！！！）</strong></h4>
<p>​		因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i  = 1; 读取所有非0数据即可，其余的位置，默认值为0。</p>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">			<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> sparseArr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            chessArr2<span style="color:#f92672">[</span>sparseArr<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>0<span style="color:#f92672">]][</span>sparseArr<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>1<span style="color:#f92672">]]</span> <span style="color:#f92672">=</span> sparseArr<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>2<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
</code></pre></div><h4 id="输出恢复后的二维数组"><em>③输出恢复后的二维数组</em></h4>
<p><strong>代码实现如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">			<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> row <span style="color:#f92672">:</span> chessArr2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> data <span style="color:#f92672">:</span> row<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;%d\t&#34;</span><span style="color:#f92672">,</span>data<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h2 id="三结束语">三、结束语：</h2>
<p>​		第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！</p>
<p>​		源码我已push到我的Github仓库，<a href="https://github.com/QuakeWang/DataStructes">数据结构</a>，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://quakewang.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            AKA二夕
        
        
        <time class="post-date" datetime="2020-05-15T14:45:36&#43;08:00">
            15 May 2020
        </time>
    </footer>
</article>

