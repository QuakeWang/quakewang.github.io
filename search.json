[{"categories":null,"content":"上班第一天 this is a test\nhello world～～\nHello LQ～～\nadd some words for test\n","description":"","tags":null,"title":"Hello LQ","uri":"/life/work001/"},{"categories":null,"content":"遇见问题？？ 这两天在折腾一个数仓测试环境的迁移，MySQL 自然是必不可少缺少的咯，因为是测试环境，配置都是按最方便的来做，配置过程可参考：MySQL 安装\n前一天使用都是正常的，结果第二天不知什么原因，在使用 Maxwell 进行增量同步业务数据到 HDFS 过程中，爆出以下错误：java.sql.SQLException: Access denied for user 'root'@'aliyun001' (using password: YES) 这是一个常见的错误，遇到好几次，所以记录以下。\n解决？？？ 遇到该问题，立刻就尝试使用mysql -u root -p来登录数据库看看，结果仍然报错，同上。这时意识到数据库是进不去了。。。\n于是乎，可以先设置跳过密码：\n1 2  vim /etc/my.cnf skip-grant-tables #在[mysqld]下面添加这一行，忽略权限表   重启 MySQL：sudo systemctl restart mysqld.service\n进入之后选择 use mysql，然后 select user, host from user; 出现的结果令人惊讶！！！没有 root 用户了？？？没有就自己造一个！！！\n养成好习惯先刷新一下：flush privileges;\n创建create user 'root'@'localhost' identified by '123456';，然后报错：ERROR 1396 (HY000): Operation CREATE USER failed for 'root'@'localhost'，估计应该是没删干净？？再删一下：drop user root@'localhost';，刷新一下；这个时候再创建就 ok 了~~\n有了 root 用户之后，再给权限：mysql\u003e GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION; #赋予所有库所有表操作权限；刷新一下~~\n再回到 /etc/my.cnf 删除 skip-grant-tables。重启数据库，这个时候就可以正常使用了~~\n如果为了方便还可以再设置一下 host 为 %：update user set host=\"%\" where user=\"root\";\n","description":"","tags":null,"title":"MySQL——Access denied for user 'root'@'localhost' (using password: YES) 问题解决","uri":"/tech/mysql_access_problem/"},{"categories":null,"content":"Windows 配置 Scala 开发环境 零、前言 谈起现如今的大数据开发框架，那么 Spark 想必是众所周知的。而 Spark 就是使用 Scala 语言编写的。所以问题来了，该如何配置一套 Scala 的环境呢？\n其实，有了 Java 的底子之后，配置一套 Scala 开发环境并不是很难，因为 Scala 一门以 JVM 为运行环境并将面向对象和函数式编程的最佳特性结合在一起的 静态类型编程语言，支持面向对象和函数式编程。\n一、Scala 环境搭建 前文提到，Scala 是运行在 JVM 上的，所以首先先保证开发环境已经配置了 JDK，这里不做过多赘述。（我使用的 JDK1.8）\n1.下载所需要的 Scala 版本，download；\n2.将下载好的 zip 文件压解至无中文的目录下，最好也不要有空格；\n3.打开 Windows 的系统属性中的环境变量，配置 Scala 的环境变量：SCALA_HOME 以及所属目录：D:\\DevelopmentTool\\scala-2.12.11\n配置 path 路径，将 bin 目录添加至系统环境 %SCALA_HOME%\\bin\n4.测试\n打开 terminal 终端，输入 scala 出现如下图所示表示配置好环境~~\n二、在 IDEA 中配置 Scala 开发环境 IDEA 懂的都懂 好用就完事了！！！下面将演示如何在 IDEA 集成 Scala 开发环境。\n1.在 Setting 的 plugins 中搜素 Scala -\u003e点击 Install-\u003e点击 ok-\u003e点击 apply，重启 IDEA；\n2.创建一个 projet，默认是不支持 Scala 的开发。需要手动引入 Scala 框架，在项目上，点击右键-\u003e Add Framework Support... -\u003e选择 Scala-\u003e点击 OK。\n注意：如果是第一次引入框架，Use libary 看不到，需要选择你的 Scala 安装目录，然后工具就会自动识别，就会显示 user libary。\n3.测试\n以上我们已经完成了 Scala 的开发环境，可以完成一些基础的相关。\n三、配置 Spark 开发环境 1.创建 Spark 项目，添加相关依赖：\n\u003cdependency\u003e \u003cgroupId\u003eorg.apache.spark\u003c/groupId\u003e \u003cartifactId\u003espark-core_2.12\u003c/artifactId\u003e \u003cversion\u003e3.0.0\u003c/version\u003e \u003c/dependency\u003e 添加依赖之后，就可以使用 Spark 相关的 API，但是在运行过程中，控制台可以会出现一些神奇的错误，如下所示：\nERROR Shell: Failed to locate the winutils binary in the hadoop binary path java.io.IOException: Could not locate executable null\\bin\\winutils.exe in the Hadoop binaries. at org.apache.hadoop.util.Shell.getQualifiedBinPath(Shell.java:382) at org.apache.hadoop.util.Shell.getWinUtilsPath(Shell.java:397) at org.apache.hadoop.util.Shell.\u003cclinit\u003e(Shell.java:390) at org.apache.hadoop.util.StringUtils.\u003cclinit\u003e(StringUtils.java:80) at org.apache.hadoop.security.SecurityUtil.getAuthenticationMethod(SecurityUtil.java:611) at org.apache.hadoop.security.UserGroupInformation.initialize(UserGroupInformation.java:274) at org.apache.hadoop.security.UserGroupInformation.ensureInitialized(UserGroupInformation.java:262) at org.apache.hadoop.security.UserGroupInformation.loginUserFromSubject(UserGroupInformation.java:807) at org.apache.hadoop.security.UserGroupInformation.getLoginUser(UserGroupInformation.java:777) at org.apache.hadoop.security.UserGroupInformation.getCurrentUser(UserGroupInformation.java:650) at org.apache.spark.util.Utils$.$anonfun$getCurrentUserName$1(Utils.scala:2412) at scala.Option.getOrElse(Option.scala:189) at org.apache.spark.util.Utils$.getCurrentUserName(Utils.scala:2412) at org.apache.spark.SparkContext.\u003cinit\u003e(SparkContext.scala:303) at org.erxi.spark.core.rdd.operator.transform.AdClickCount$.main(AdClickCount.scala:8) at org.erxi.spark.core.rdd.operator.transform.AdClickCount.main(AdClickCount.scala) 这是因为在程序中使用了 Hadoop 相关的内容，比如写入文件到 HDFS。出现这个问题并不是程序的错误，而是windows 系统用到了 hadoop 相关的服务，解决办法是通过配置关联到 windows 的系统依赖就可以了。\n2.解决异常 安装 Spark：到官网 https://spark.apache.org/downloads.html 选择合适的版本下载，注意 Spark 与Hadoop 版本选择要相对应，建议下载预编译（Pre-built）好的版本，省得麻烦。解压文件，然后与配置 Scala 环境类似配置对应的 SPARK_HOME 与 path 变量 %SPARK_HOME%\\bin;\n安装 Hadoop：到官网 https://hadoop.apache.org/releases.html 下载与上边的 Spark 对应的版本。后与配置 Scala 环境类似配置对应的 HADOOP_HOME 与 path 变量 %HADOOP_HOME%\\bin。\n除此之外，还需要到这里 https://github.com/cdarlint/winutils 下载对应版本的 bin 目录中的 hadoop.dll 和 winutils.exe，复制到 hadoop 目录的 bin 目录下。\n完成上述操作之后，已经在 Windows 环境下搭建了可用于测试的 Spark 环境和 Hadoop 环境。最后还需要再 IDEA 中导入一下 HADOOP_HOME，这样运行程序就不会报错啦~~\n在 IDEA 中配置 Run Configuration，添加 HADOOP_HOME 变量：\n","description":"","tags":null,"title":"Windows 配置 Scala 开发环境","uri":"/tech/bigdata/scala/"},{"categories":null,"content":"标题写在变“羊”之前 占个坑 按照目前国内的这个趋势 躲得过初一 能躲得过十五嘛？？？？？？？？？\n","description":"","tags":null,"title":"我与开源的那些事儿","uri":"/life/covid-19/"},{"categories":null,"content":"单例模式 为什么使用单例模式？ 单例设计模式：一个类只允许创建一个对象（或者实例），那么这个类就是一个单例类，这种设计模式就叫做单例设计模式，简称单例模式。\n单例模式的概念并不是很难，一看就能明白。接下来我们思考一下，为什么需要单例这种设计模式？它能解决哪些问题？\n实战案例：处理资源访问冲突 咱们先来看第一个例子。该例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public class Logger { private FileWriter writer; public Logger() { File file = new File(\"/Users/zhangsan/log.txt\"); writer = new FileWriter(file, true); // true表示追加写入  } public void log(String message) { writer.write(message); } } // Logger类的应用示例： public class UserController { private Logger logger = new Logger(); public void login(String username, String password) { // ...省略业务逻辑代码...  logger.log(username + \" logined!\"); } } public class OrderController { private Logger logger = new Logger(); public void create(OrderVo order) { // ...省略业务逻辑代码...  logger.log(\"Created an order: \" + order.toString()); } }   上述代码的功能并不是很复杂，但请停下来思考一下，这段代码存在什么问题。\n细心的同学可能已经注意到了，所有的日子都写入到同一个文件 /Users/zhangsan/log.txt 中。在 UserController 和 OrderController 中，分别创建了两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日子到 log.txt 文件中，那么就有可能存在日子信息相互覆盖的情况。\n为什么会出现相互覆盖呢？可以这样类比着理解。在多线程环境下，如果两个线程同时给同一个共享变量加 1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加 2，而是只加了 1。同理，这里的 log.txt 文件也是竞争资源，两个线程同时往里面写数据，就有可能会存在相互覆盖的情况。\n那么该如何来解决和这个问题呢？通常的思路应该是加锁：给 log() 函数加互斥锁（Java 中可以通过 synchronized 的关键字），同一时刻只允许一个线程调用 log() 函数。具体的代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Logger { private FileWriter writer; public Logger() { File file = new File(\"/Users/zhangsan/log.txt\"); writer = new FileWriter(file, true); // true表示追加写入  } public void log(String message) { synchronized(this) { writer.write(mesasge); } } }   不过，仔细思考一下，这真的能解决多线程写入日志时相互覆盖的问题吗？答案是否定的！这是因为这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被强制要求顺序执行。但是，不同的对象之间并不能共享同一把锁。在不同的线程下，通过不同的对象调用执行 log() 函数，锁并不会起作用，任然有可能存在写入日志相互覆盖的问题。\n这里稍微补充一下，在刚刚的讲解和给出代码的中，故意“隐藏”了一个事实：我们给 log() 函数加不加对象级别的锁，其实都没有关系。因为 FileWriter 本身就是现场安全的，它的内部实现中本身就假了对象级别的锁，因此，在外层调用 write() 函数的时候，再加对象级别的锁实际上是多此一举。因为不同的 Logger 对象不共享 FileWriter 对象，所以 FileWriter 对象级别的锁也解决不了数据写入相互覆盖的问题。\n那么问题来了，该如何解决呢？实际上，要解决这个问题并不是很难。我们只需要吧对象级别的锁换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 log() 函数，而导致的日志覆盖的问题。具体的代码实现如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Logger { private FileWriter writer; public Logger() { File file = new File(\"/Users/zhangsan/log.txt\"); writer = new FileWriter(file, true); // true表示追加写入  } public void log(String message) { synchronized(Logger.class) { // 类级别的锁  writer.write(mesasge); } } }   除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。\n相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。\n我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。\n按照这个设计思路，我们实现了 Logger 单例类。具体代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class Logger { private FileWriter writer; private static final Logger instance = new Logger(); private Logger() { File file = new File(\"/Users/shangsan/log.txt\"); writer = new FileWriter(file, true); // true表示追加写入  } public static Logger getInstance() { return instance; } public void log(String message) { writer.write(mesasge); } } // Logger类的应用示例： public class UserController { public void login(String username, String password) { // ...省略业务逻辑代码...  Logger.getInstance().log(username + \" logined!\"); } } public class OrderController { public void create(OrderVo order) { // ...省略业务逻辑代码...  Logger.getInstance().log(\"Created a order: \" + order.toString()); } }   实战案例二：表示全局唯一类 从业务概念上，如果有些数据在系统中只应保持一份，那就适合设计为单例类。\n比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存后，以对象的形式存在，也理所应当只有一份。\n再比如，唯一递增 ID 号码生成器，如果程序中有两个对象，就会存在生成重复 ID 的情况，所以我们应该将 ID 生成器类设计为单例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import java.util.concurrent.atomic.AtomicLong; public class IdGenerator { // AtomicLong 是一个 Java 并发库中提供的一个原子变量类型,  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，  // 比如下面会用到的 incrementAndGet().  private AtomicLong id = new AtomicLong(0); private static final IdGenerator instance = new IdGenerator(); private IdGenerator() {} public static IdGenerator getInstance() { return instance; } public long getId() { return id.incrementAndGet(); } } // IdGenerator 使用举例 long id = IdGenerator.getInstance().getId();   如何实现一个单例？ 概括起来，要实现一个单例，我们需要关注的无外乎下面几个：\n 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例； 考虑对象创建时的线程安全问题； 考虑是否支持延迟加载； 考虑 getInstance() 是否加锁（性能是否高）。  1. 饿汉式 饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以 instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：\n1 2 3 4 5 6 7 8 9 10 11  public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static final IdGenerator instance = new IdGenerator(); private IdGenerator() {} public static IdGenerator getInstance() { return instance; } public long getId() { return id.incrementAndGet(); } }   有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，从我的角度来说，并不是很认同这种观点。\n如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。\n如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。\n2. 懒汉式 有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private IdGenerator() {} public static synchronized IdGenerator getInstance() { if (instance == null) { instance = new IdGenerator(); } return instance; } public long getId() { return id.incrementAndGet(); } }   不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。\n3. 双重检测 饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。\n在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private IdGenerator() {} public static IdGenerator getInstance() { if (instance == null) { synchronized(IdGenerator.class) { // 此处为类级别的锁  if (instance == null) { instance = new IdGenerator(); } } } return instance; } public long getId() { return id.incrementAndGet(); } }   网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。\n要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。关于这点的详细解释，跟特定语言有关，我就不展开讲了，感兴趣的同学可以自行研究一下。\n4. 静态内部类 我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class IdGenerator { private AtomicLong id = new AtomicLong(0); private IdGenerator() {} private static class SingletonHolder{ private static final IdGenerator instance = new IdGenerator(); } public static IdGenerator getInstance() { return SingletonHolder.instance; } public long getId() { return id.incrementAndGet(); } }   SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。\n5. 枚举 最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：\n1 2 3 4 5 6 7 8  public enum IdGenerator { INSTANCE; private AtomicLong id = new AtomicLong(0); public long getId() { return id.incrementAndGet(); } }   重点回顾 1. 单例的定义 单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。\n2. 单例的用处 从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。\n3. 单例的实现 单例有下面几种经典的实现方式。\n 饿汉式  饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。\n 懒汉式  懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。\n 双重检测  双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。\n 静态内部类  利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。\n 枚举  最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。\n","description":"","tags":null,"title":"设计模式（一）-- 单例模式 001","uri":"/tech/designpattern/001_signle%E4%B8%80/"},{"categories":null,"content":"Blog010 —— 考研系列完结篇，但是还有生活 零、写在前面 说实在的，我不想去回忆关于考研的任何内容，备考过程也好，考试当天的过程也罢，都不愿意去提起，真的太折磨了。所有 APP 中推荐的关于考研的内容，都刻意的去点了 X，但有可能就是应为刻意而为之，反而越想去逃避，不想去面对这一切。似乎就好像不去主动面对，这一切就还没结束，结果也就不会到来。但时间是一直往前走，不会止步的。除了麻痹、自我安慰、欺骗自己，真的不知道该做些什么。考研结束的这几天，过得也特别颓废。什么都不想做，吃了睡，睡了吃，报复性的“糟蹋”自己，来“补偿”这一年的付出。。。\n每到深夜，闭上眼，脑中回想的都是这一年的点点滴滴，又回头看看备考期间所写下的博客。就像是开篇中所写下的写在之后所提到，我想用文字记录下这一切。当看到这段话的时候，说明我坚持下来了，我也做到去突破自己的壁垒，勇敢的去面对自己这一年的汗水与泪水。既然之前的都写了，为何不写完这最后一篇呢？\n一、回到起点 是的，就像这篇的标题一样，考研终于结束了。这一年来的备考过程也总算是画上了个句号。这一年回想起来，过得也还是挺快的。一步一步也就这样走向了终点。但，真正的生活也才刚刚开始而已。\n这一路走来的点点滴滴，宛如就在昨夜，仍然历历在目，甚至还以为现在真的是结束了吗？？或许，再给我点时间，我还能坚持坚持，还能再努力努力，还能做的更好一点呢。。\n但当专业课交完试卷，走出考场的那一刻起，都已成为过往。很感谢这一年每月的记录，才有现在的最终篇。\n走出考场，整个人都好像失去了目标、失去方向、失去走下去的动力。我好像回到了一年前的自己，又好像看见了三年前的自己。\n一年前的自己，刚刚开始准备考研，还在吃着上一届学长学姐考研的瓜，跟风吐槽着数学出的简单、英语有多难、政治肖大爷有多神。但作为这届刚刚结束这一切的考研人，我不愿去讨论，甚至不想与这个世界存在任何联系，我怕一点点的风吹草动会影响接下来的心情。去年这个时候面对的是不知该如何复习的迷茫感，现在是不知该做些什么的困惑，甚至不知道该向什么方向去努力。那时的自己，你不了解你所处的位置，也无法判断自己真正的能力与实力。但是，却有着极大的野心和孤独一掷的决心与勇气。你说，你要考个牛掰的学校，想体验一下去大城市读书的感觉。同时，你对自己的学习方法也有时摸不着头脑，有时又蜜汁自信。最后，你说不管结果如何，你会坦然去面对这一切的后果，因为你相信，只要坚持到底总不会太差，如果不是，那就是还没到最后。那么值得吗？？？我觉得值！！！这是一段极为难得的专注时光，得以有机会深入地去探求最真实的自我，也是一场与自己的比赛，与自己对话的机会。\n是啊，你现在走完了这一路，为什么不敢去面对当时的自己了呢？？没达到自己预期的样子。。。对，确实没达到。原以为的自己能够在考场上意气风发、洋洋洒洒地写完试卷，走出考场时，还不忘给自己一个微笑。考前，我曾一遍一遍地想象自己在考场上的自己，想着这一年的付出终于能发挥出来，所有的付出都能看得到回报，这一路的坚持也是值得的。但事与愿违，四场下来，一场比一场难受，但我不能表现出来，我怕会影响下一场考试，怕自己会崩溃，怕自己没有踏进下一场考试的勇气。可能，这也就是现实了吧。\n三年前的自己，那时的你带着高考的不甘，极其不情愿的来到现在的学校，都还不知考研对你意味着是什么，就把考研定为自己的目标，大一的时候还不怎么逃课，上课也很积极坐在最前排，对大学里的一切即充满新鲜感，同时也很迷茫。迷茫的是大学和高中完全是两个样子，没有统一的标准，不知道到底怎么做是对的，哪样是错的。那时的你，眼界还仅仅局限于校园内，似乎就感觉世界好大，但与我无关，老老实实的做个普普通通的学生就好了，不是吗？你也更不会想到现如今的自己，不会真正参与到这个更大的世界。但现在，我又好想逃离这个错综复杂的世界。。。\n二、倒计时的煎熬 进入十二月 进入十二月，代表着不足一个月，就得走进考场，那时候政治啥都没背，只把肖八的选择题给做完，其他的老师的模拟题也不愿意去做，对政治这门课，就有点摆烂。英语开始最后一遍过真题，虽然记住大部分的答案，能要求自己的就是读懂文章，并分析答案的选项，正确选项是如何选出来的，错误选项是如何设置干扰的。每天保持一篇作文的量。数学也结束了真题，可能太过于急于求成，做完之后，没有进行详细的、系统的复盘，就去模拟题中挣扎了。现在看来是极其不明智的做法，数学说到底，还是应该以真题为主，模拟题是在全部掌握真题的情况下来开拓眼界、拓展思路，见见新的题型和技巧用的。看周围的同学都在做模拟题，自己也就忍不住去跟风，不免有点本末倒置。\n突然就觉得时间不够用了，每天都对自己说，起的早一点、学得晚一点、多坚持一点。硬生生的压迫自己去学习，效率也就不会太高。但是我不敢对自己有丝毫懈怠，因为真的快到头了，留给自己的时间也不多了。加油，踏踏实实的走下去。\n倒计时两周 这个时候，突然人就崩溃了。感觉好像啥都会，但再仔细想想又觉得自己哪里都不太会。肖四已经到手，根本背不动，学校这边还有一堆恶心的人和事来搞人状态，就想着我只是考个研究生，为什么觉得全世界都和我为敌，到底做错了什么？？英语也被 21 年的真题给打击到。。数学更是被各种模拟题做的我怀疑人生。专业课由于只有参考数目，并不知道实际上复习的咋样，一直都是玄学状态。\n我不止一次想过，要不就这样了吧。实在是坚持不动了。考研，真的是太痛苦了，比我原本的预期要难受的多的多的多。但回过头来再想想，再苦再累也就还剩两周，走完吧，别给自己留有遗憾。考场都没踏上，咋就自己知道自己就一定做不到呢？\n倒计时五天 距离考试还剩一周，真的是过一天少一天。现在也不做新题了，每天翻翻看自己做过的试卷，从错题找原因，再回归到讲义，查缺补漏。也就是在这个时候，回归真题，才意识到真题和模拟题的作用是不等价的。肖四也把当时可能考到的点都背了背，反正每天都在坚持嘛，虽然是不可能背完的了，奇迹也创造不出来。英语单词逐渐开始慢慢减少记忆量，腾出更多的时间来给作文。专业课就根据考纲和之前的真题回忆，每天睡前不断回忆专业课的内容。\n到了这个时间点，反而没有前两周那么慌张，更从容，更平静了。开始慢慢调整自己的状态，虽然不能回到巅峰，但最起码别太差就好。到了临考前两天，晚上从图书馆回宿舍的时候，开始收拾资料，逐渐往宿舍搬，收到一半的时候，突然好舍不得，不禁就呆住去回忆这一年的点点滴滴，眼泪止不住的在眼角里打转，强忍不让其落下来。回宿舍的路上，望着天上的星星，我就在想，所坚持的这一切真的值得吗？？为了考研所放弃的太多太多，真的不会后悔吗？？\n还记得，在十月份的博客中写到：我还在等一场雪，来见证这场考试。周五看好去考场的路线回到酒店，晚上真的飘起了小雪。从唯心主义来说，真的就有很大信心去踏上明天的战场。\n三、但是还有生活 是的，现在距离考研结束已经快过去一周了。这一年就好像做了一场梦，考试结束，梦也就醒了。\n还记得高考结束之后，留下的最多的是疲惫感，现在也是。还有一种无力感，颓废感。从踏进大学校门的那一刻起，就把考研当做自己的最终目标，完成之后，不知道自己下一步该怎么走，该走向哪？？一时间，又好似觉得自己的努力有些可笑，有些一文不值，开始不断的否定自己。\n现在考研都在默认奇数年简单、偶数年简单，虽然事实的确如此，但难与不难，往往更取决于个人的主观感受，而不是你我说了算，我们要做的就是坦然去面对这一切，在考场上做到发挥出最好的自己。回答前面的问题，值得！！！如果再给我一次机会，我还会选择考研，因为只有历经了真正意义上身心的折磨，才能算得上是成长，遇见困难，要硬着头皮冲，而不只想着做逃兵，一直在退缩。有的时候，不逼自己一把，都不知道自己是什么样的。最重要的是，这场考试，虽然发挥的不是太好（巅峰状态的百分之七十），但没有留下太大的遗憾，我尽我所能，做到了最好的自己。\n除了这一切，但是还有生活。\n想想之前所规划的，考试结束之后，想做的事情，好像也没啥了。脱离开源社区半年，突然回去，既熟悉又陌生。熟悉的是那种来自开源人带来的感觉是不会变的，陌生的是又有了许多新的小伙伴、新的代码，还需自己花时间去了解一下。这半年来，没有时间去积累新的技术栈，现在也有时间去探索新的领域，做新的尝试。这半年来，由于备考而落下的书籍，也有时间去阅读了。btw 可以的话，我还想把大学期间读过对我影响比较大的书买纸质版的再来一遍。还有就是，当时想着去健身，现在也有了大把的时间去锻炼自己，让自己朝着更好的方向去发展。\n若干年后，你会怎样回想这一年？人生海海，这一年，我们记得肆虐的洪水，反反复复的疫情，更记得那些逆行的无畏身影，爱与善汇成浩荡星河，在奉献，在永不言弃的精神。这一年，我们记得巨星，灿烂而不朽的陨落，记得他们走过一地荒芜，留下生生不息。记得那些顽强和汗水写下的闪耀时刻。每一个巨浪都成就于微澜，每一个普通的灵魂里都有江河。这一年，我们记得，勇立潮头的你，披荆斩棘前行的你，每一天都努力让自己和周边世界好一点点的你，记得一路千山万壑，希望就是我们自己，都在路上！\n 附：考研歌单\n 《平凡之路》-- 朴树 《一群无知少年的梦想》-- 杨赛 《稻香》-- 周杰伦 《拼个世界给自己》 -- 姜云升 《没有理想的人不伤心》-- 新裤子 《Iridescent》-- Linkin Park 《Beautiful》-- Eminem 《猛犸》-- 后海大鲨鱼 《幸存者》-- 林俊杰 《孤勇者》-- 陈奕迅  最后，有的人说，奇数年的坚持，都是为了在偶数年迎来好运，希望下一年会好一点~~\n还有就是，去 TM 的 2021，终于结束了。。。。。\n","description":"","tags":null,"title":"大政的考研 Blog010 —— 但是还有生活","uri":"/life/kaoyan010/"},{"categories":null,"content":"Blog009 —— 幸存者，十一月复盘 一、再坚持一下 1.1 彻底崩溃 是的，就像标题所说的那样，随着距离考研时间的越来越近，心里也就越来越着急，紧张感、压迫感都在无形的逼近。总想着，还有好多好多没有复习，到底该怎么办啊！就这样想着想着，心态崩了，严格意义上来说，是考研这将近一年的时间中第一次崩溃。\n进入考研倒计时 100 天的时候，我在想，还不着急，还有三个多月呢，时间在一定程度上还是很充裕的，就想着是不是背诵记忆类的内容可以往后放一放，况且专业课复习的不咋滴，数学才是重点。慢慢的到了快倒计时 60 天 的时候，突然的有一种压迫感袭来。马上就剩下两个月了，两个月需要背那么多，你能做到么？？但问题是，其实数学和专业课复习的也不是很好啊。。要知道，我高三的时候都没这样过，有的时候还经常逃课，上课睡觉，考研给我整成什么样子了。我也想去外面玩，好好的睡个懒觉，这学期更是进山窝里到目前为止三个月的时间没有出去过！就算是高考在我眼前，五一假期的时候，我还是该浪浪该玩玩。也许，这就应了那句话：出来混，迟早是要还的。。。\n就这样，到了倒计时 50 天的时候，彻底崩溃，下一步不知该如何是好，整个人都充满了无力感。总想着剩下的时间，英语作文、新题型、翻译、完型都没开始；高数的一些边边角角小的知识点、几何应用、物理应用都不会；线性代数掌握的也不是好牢固，知识点都串不起来，做题的时候都是磕磕巴巴，甚至还做不出来；专业课，笼统的感觉好像全部都掌握的还行，每个点都能说出个一二三出来，但是到具体的题目，又不太行；至于政治，更别提了只听了马原部分，经济学部分掌握的还不好，史纲也知道个点点，其余的压根没看。下一步到底该怎么走。考四门，结果没有一门是能让我安心的。\n下一步该怎么办？是放弃吗？还是做无谓的坚持？？\n很多的崩溃可能往往就是那么一瞬间。（但是学过马哲之后，就要说这句话是错的了，这不明显忽略了量变对于质变的影响嘛）。\n1.2 还剩 50 天 对啊，你还剩 50 天，又不是下周就要考研了，干嘛这么着急呢？焦虑有用吗？也许只会有反作用吧。就像之前暑假时候的状态，想玩但是又不敢玩，只能硬着头皮学，反而没有怎么玩，学的也不咋滴。你现在的问题不是不想学，而是不知道该如何去学，既然是有学习的心，剩余的就是学什么的问题了。\n这一路走来，很多时候我们都习惯于放大自己的缺点，和强调自己的特殊性，认为好像只有自己会遇见这种问题，甚至会觉得，我只是想考个研，怎么全世界都在和我作对！其实不然，我们也只是百万考生中的一员，其实往大了说，大家的问题也都差不多。不排除肯定有复习的特别好的大佬，也肯定有氛围组的炮灰，但是我想说的是绝大多数人都一样。都会感觉到焦虑。在没出成绩之前，谁敢说自己就一定能考上呢？坚持到这个时间段，我们当下需要做的就是走好自己的每一步，过好自己的每一天。但是如果太刻意去强调每天都要学的扎扎实实的，在很大程度上也会有副作用。人是特别容易受主观因素影响的动物，没有人能够保证自己学的特别棒，真的没有，偶尔出现情绪波动都是再正常不过的事情了，我们要学会接受自己的不足，欣赏自己的不完美，只有这样才能把自己的心态给端平，也能够给自己一个喘一口气的机会。\n1.3 30 天倒计时 就这样，不算太顺，但也不能说是太差，进入了三十天倒计时。有的时候，我就会想，为什么通常把三十天左右当做一个结点呢？仅仅是因为一个月的时间在这个范围左右嘛。也许吧。但也有可能是接下来的每一天离自己即会更近一步，又会渐行渐远。。每每这个时候，我就会想起高三对自己说的话：我不去想是否能够成功，既然选择了远方，便只能风雨兼程。其实吧，事情远没有自己想的那么严重。如果不考研的话，我就是一个不起眼的二本院校普普通通的毕业生，再说直白点，本身就没啥好失去的。考研，考上了等于赚了，考不上就问问自己这一年的坚持对自己而言值得吗？？有收获吗？？现在的自己是当时自己所想的样子嘛？？\n和之前的博客里面所写的一样，从选择考研的那一刻起，我就在问自己，为什么要考研，或者说读研对于我来说意味着什么。我能够感觉到，就算是我读研毕业之后，工作能力也许并不会比现在的自己高出多少。这个答案，直到今天，我还在寻找。。。\n 二、十一月复盘 ① 数学 数学分值 150，自然而然是重中之重。但是数学的学习真的很枯燥无味，到现在这个阶段才感觉到在复习前期对数学真的是低估了。从而导致数学的整体进度到中后期开始慢慢落了下了来。从辩证法的角度来看，这一点也不是一点好处没有的，就把高数和线代的强化部分又抽重点给过了一遍，也是因为之前暑假的时候为了赶进度而导致的原因吧。由此可见，学习是真的要学的扎扎实实，不能囫囵吞枣！\n这个月主要就是把武神的 17 堂课给看的差不多，但是后面的几个专题因为时间的原因只是结合课程把里面的一些掌握不太好的题型给做了，并没有全部完成，而且整个课程还剩物理应用没有复习。进入十二月的第一天给它啃了吧。不得不说，武神终究是武神， 17 堂课听得很痛苦，因为全是重难点，几乎没有太多的垃圾题目，刷起来难度就真的大很多。但是对于解决问题的角度，都提供了很好的解法，尤其是微分中值定理的证明，之前看见这种题目从心理上来说是比较畏惧的，无法充分利用题目的已知条件，不会正确的构造函数，但这些经过系统地训练之后，会发现都是有迹可循的。所以考研给我的感觉，后期的付出比天赋重要的多。再有就是二重积分的求解问题，这段时间真题刷下来，二重积分几乎是必考的，往往还会更倾向于大题目的考察，解决此类问题的时候，首先看区间是否是对称区间，以及是否能够通过平移利用函数的奇偶性来适当的简化计算量，以及对于直角坐标和极坐标之间的转化适用于什么样的题目，还有就是像星形线、摆线之类的比较特殊的曲线图像，心里要有个大概的了解，这样的话遇见题目才不会出现无从下手的情况。课程的质量还是可以保证的，干货满满，就是听起来很费精力！！！\n其次，就是从这个月下半旬开始，真题的套卷终于开始刷了，虽然半个月的时间只消化了八张真题试卷。以下是对从 11——18 年真题的简单小结：\n 11 年：难度一般，由于是第一次以套卷的形式开始做数学，出现很多知识点串不起来，像填空题中出现的弧长公式、以及对于微分方程的综合应用掌握的一般，整张试卷下来计算上的细节容易出现丢分情况，物理应用是丢分点之一，二重积分的出题方式比较特殊，但是结合一元的情况还是应该要解出来的； 12 年：难度一般，曲率没有掌握，还有就是对于行列式的计算要学会灵活处理，旋转体的体积的处理、二重积分考察的是心形线，整个试卷我感觉最难的题目是数列极限的题目：用零点定理证明至少有一个零点，再用单调有界准则证明最多有一个零点，在第二问求极限的时候，还要充分利用第一问给的信息；线代大题要注意同解方程的应用； 13 年：难度一般：反常积分的敛散性掌握不熟；以及变上限积分的连续性判定这些小的知识点都不能忽视，实对称矩阵等价=具有相同的特征多项式，伴随矩阵与其代数余子式之间的关系，大题目则比较中规中矩，除了一个考察形心，这是个什么鬼？？还有最后的线代大题，利用技巧来处理问题要引起注意，傻乎乎的展开几乎不太可能实现； 14 年：难度有所上升，函数的性态（单调性、凹凸性等）与导数之间的关系，质心坐标？？微分方程解的形式，以及特征根需要注意。证明题其中数列极限，是个好题。还有多元微分学以及积分的应用来求体积都是要引起关注的点。证明矩阵相似，通常要用一个中间的矩阵作为过渡； 15 年：难度一般，高阶导数的求法，二重积分的计算要想到对称区间——奇偶性，微分方程的物理应用，题目不是很难，要耐下心来读题，以及后面的证明题，比较综合，也是不错的题目； 16 年：难，计算量大！选择填空都还行，主要是计算量真的大！题目思路都比较常规，几乎都能想到，就是算不完。在求定积分的时候遇见绝对值要分区间讨论，以及对于可导性的判断也不能少！微分方程的求解，关于常数 C 如何确定的问题，旋转体的侧面积计算（积分区间的上下限要注意），以及最后线代的大题，求高次幂要想到利用对角矩阵，但是计算量也是令人匪夷所思； 17 年：比较简单，求解极限的时候，分母是含有 x 的变上限积分，不能直接使用洛必达，要想到换元，后面的题目没啥可说的点。。。； 18 年，难，但是计算量我感觉并没有 16 年大，反而选填题的难度有所上升，大题中考到了求不定积分，这玩意的难度是个无底洞，需要注意冲刺时候的训练；还有求拉格朗日最值，计算量比较大；二重积分考的是摆线，画出图形，利用对称区间可以简化计算量。  从 15 年开始，偶数年的题目是真的难，计算量还大，我了个天，谁知道今年会怎么样呢。。\n在当前状态下，模拟卷没有时间就不做，务必要把真题吃透，做好！\n② 英语 英语这个月，算是复习的比较理想的一科了。先是过完了翻译的课程，随后新题型和完型填空又紧随其上。目前还在准备作文阶段，小作文已经初步形成，大作文希望在一周之内可以完成，毕竟留给的时间真的真的不多了。\n这个月则把真题又过了一遍，因为属于多刷了已经，里面的大部分答案都能记住，所以要做的就是通读阅读文章，扫清生词和长难句，以及弄清楚题目与选项之间的关系。要养成良好的做题思维。接下来的日子，真题再过最后一遍，我也希望是我人生中最后一遍过考研英语的历年真题！！\n③ 专业课 专业课怎么说呢。。笼统的看好像全部都掌握的差不多了，但是放到具体的问题来看，还是掌握的不太牢固，就比如排序的算法，对于考纲中给出的内容都能手动模拟出来，但是要是说全部手写代码的话，还是存在一定的困难的，（根据前两年的回忆版真题，只出现了个快速排序的代码要求，而且还有文字提示），对于 BST、AVL 和 B 之类的插入和删除都算是掌握了吧，画图过程都会，但是容易忘，所以在接下的时间要反复巩固。但对于链表、栈和队列只知道这些数据结构的增加结点和删除结点的方式，并没有往下深究，看着之前的回忆版真题，感觉这部分考的不是很深。还有就是时间和空间复杂度的计算要掌握，图比较侧重于迪杰斯特拉，前两年都考到了。还有各种数据结构的存储方式。\n数据库方面的话，难点还是在第三范式和 BCNF 的分解，无损连接和保持函数依赖性掌握的还行，求闭包之类的也可以，求最小依赖集比较生疏，还有就是求候选码容易漏。。写 SQL 的话，经过了一定量的练习，应该不会丢太多分，考得太难了也就无了呗。至于关系代数，回头还需要看看，至于元组演算的话，战略性选择放弃吧。还有重点就是事务和故障恢复，这部分既需要理解，又需要一定量的背诵。难度的话倒不是很难，剩余的我感觉更多的都是偏向于记忆类的知识点，后期需要回归教材，多看看书，把书变薄再变厚。\n加油！\n④ 政治 政治这个是我最不想提起的，因为真的很无聊。马原和史纲部分还能接受，到了毛中特的部分，那就是开始无脑吹。唉。\n里面的 keywords 看着都很熟悉，就是记不清，而且还没有花时间开始背诵。还剩三周多几天的时间，能够背的完么？选择方面，肖八快全部刷完了，前面两套做的是真的惨不忍睹，错的稀里哗啦。。。但好处是之前马原和史纲过了一遍，这块的错误率是比较低的，因为毛中特和思修对于我来说等于啥都不知，只能结合错题回归背诵手册来勾画知识点，反复记忆。到了第四套开始慢慢有了起色，最起码不是做的太难看了。\n说真的，政治我不想花太多时间，毕竟拉不开多大的分，我想的就是在最短的时间内，冲到 60 分以上，最起码证明自己的政治觉悟没有问题是吧，虽然上海还是旱区。。。\n 三、幸存者 天，快亮了！是啊，终于快了，我等了好久，内心是期待的，是渴望这一天早点到来，这样身上的担子就能卸下来了，就能做点自己想做的事情。每当看不下去书的时候，我就在想考研结束的生活，我想看自己喜欢的书籍，睡个懒觉，继续为开源项目做贡献，阅读源码，增加查克拉，再玩玩悠悠球。还有二十几天，就能过上了，一定一定要调整好自己的状态，最起码在面临考试的时候不是恐惧的心理。\n但在期待着她到来的同时，又不愿早点到。因为没有复习好，还是会觉得如果再给我多一个月的时间，我肯定能把哪里哪里给补回来，把什么什么给学的好好的，但是时间对于每个人都是公平的，过去了就是过去了，在剩下的日子里要做的就是在现有的基础上，不断巩固加强，查缺补漏。还有就是，我不知道下一次这么为了自己的目标去奋斗，坚持是什么时候，在选定考研目标的时候，这是我读书以来第一次有机会自主选择自己的院校，所以从根本上来说，我是很喜欢这个为之努力，为之付出的过程的，因为我知道，随着时间的推移，我在慢慢的、一点一点的靠近她。但是我还怕就差一点点，原以为只是踮起脚尖够月亮，没想到回过头来已经是万丈深渊。这段煎熬的时光纵然不舍，但我还是想说享受这一次就好，今年一定要冲上岸！！\n其实在和对大多数的考研人比，我算是比较幸运的，在别人还在焦虑选择院校的时候，我的目标已定；因为是自主命题，所以很感谢导师和实验室的师哥师姐给予的帮助。如果没有你们的帮助，我的心态早就崩了。也正是由于你们的帮助，我敢于去搏一把，去挑战自己心里的那个最高点，去勇于做别人想做但又不敢做的。还有就是离不开家人的支持，家永远是最后的防线。所以从这些角度来说，我是考研大军中，为数不多的幸存者！\n 背负伤的幸存者 争夺着有限名额\n想要闪烁就对自己更严格\n 加油！冲！\n","description":"","tags":null,"title":"大政的考研 Blog009 —— 幸存者","uri":"/life/kaoyan009/"},{"categories":null,"content":"Blog008 —— 莫问终点，十月复盘 一、煎熬 ? 终点 : 放弃 1、10.24 十月份，10.24 程序员节~~ 打心底来说，我还是很喜欢这个职业的，至少从目前为止，也许以后毕业了从事“劳动密集型工作”面对资本家的压榨，会产生厌恶的心情呢，but who cares？以后的事情以后再说咯。\n软件工程，这个专业名字确实听起来确实很高大上，但是临近毕业大四的自己，有掌握软件工程的思想吗？？似乎差的很远吧。但是我喜欢编程所给我带来的东西。在现在这样一个信息化的时代，几乎人人都离不开互联网带来的便利。所以我们将来所从事的职业是一个可以改变世界的，这一点也是挺值得自豪的。还有就是在掌握一些技术栈之后，会慢慢发现这个在互联网影响下，现实和虚拟相互交织的世界到底是如何运转的，我们每天使用电子设备所产生的的数据是如何存储的，又以何种方式被利用等等，这些在我看来都是很有意思，也是值得思考和探索的。所以我很感谢当初的自己选择了这个专业，能给现在的自己一个机会，以程序员的视角去感受这个世界。\n回想去年的 10.24 可谓是真的极限运动，周四晚上连夜做着绿皮小火车，轰隆轰隆吵得头皮发麻，周五到达上海，上午睡一觉，晚上赶往年会会场--微软 Reactor，到晚上回家的时候地铁停运，只能打车，洗漱完成已经是两点多，第二天还得早起，接连两天，然后周天晚上再次连夜赶回合肥。有的同学问我，这么赶时间折腾自己，就是去做志愿者，有必要吗？我想或许不是很有必要，但是有意义，信仰充值。在去年的开源年会，是我第一次得到被肯定的感觉。让我发现世界上有很多和我一样的人，普通却并不平凡为开源输出自己的力量，也更让我找到了考研的目标。（具体的详细感受看 我与开源的那些事儿）其实最好的体验是在于回来之后，写了这篇博客，得到认可的“满足感”和“虚荣心”是无可替代的！\n2、越来越近了… 是的，十月份的结束，代表着距离考研也越来越近了。这个阶段的自己心情是十分矛盾的，一方面想着完了还有好多东西没看没复习还来得及嚒？？另一方面却想赶快结束这一切吧，真的是熬不动了。我想无忧无虑的熬一次夜，更想无所顾虑的睡一次懒觉。但是对于目前这个阶段来说，这无疑是一种奢侈。\n就带着这矛盾的心情，一面是厌学，不想看书；另一面又是逼着自己学习，因为我太渴望考研上岸。就总觉得是这是证明我自己的一次机会，证明自己大学这几年混得还不差，证明自己还是有能力的，证明我能做得到。更想让那些之前看不起我的人，对我刮目相看。似乎从中考失利，就被贴上差等生的标签，从高中到大学，所以当再一次站在选择的路口，我不想再窝窝囊囊只是为了有学上来逃避自己啥都不会的现实，这一次我想选个牛 X 的，更何况机会就摆在我面前，我真的舍不得放弃。嗯，是的。\n但是选择了好的学校，就代表着你需要承受踏上终点的一切负重。其中压力部分是最大的，竞争力也要强上很多，在往年三百七左右的平均分作为参考，以及近年来报考人数的持续增长，很多次很多次很多次有不断地想过问自己，要不要换一个学校，或者说要不就这样了吧？？\n但是我熬了这么久，不是想证明自己临场退缩，我所期待的的是“拟录取”这三个字，是明年的录取通知书。是明年可以骄傲地说：我从做得到，到现在已经做到了！！！\n说实话，这一段不知为何，写得戾气有点重。但我实在是不知道该怎么给自己调整心态，我不相信什么“心灵鸡汤”、“励志成功学”等等之类的，那都是强者拿来安慰或者忽悠弱者的。我想说的是：我能做的就是逼自己认清现实，意识到现在自己的处境。时间是不等人的，今天过去，是不会再回来的。只能尽自己最大的能力，调整好自己的心态，哪怕这心态已经“畸形”了。。。\n 二、十月复盘 ① 数学 数学可谓是整个考研过程中最耗费精力和时间的科目，现在回想起来从去年大约这个时候开始过高数的课本教材到现在已经一年了，但是距离自己最初所期待或者说是所要求的目标还离的有不小的一段距离，离考研也越来越快了，到底怎么样，心里似乎也不是很有底。\n我从来没没有想过数学的强化阶段会持续这么长！！原以为暑假的时候听完强化课，做好讲义上的例题就算是强化结束了。但工作量远比我想的要大得多。满打满算高数部分到上周末才算是强化结束。线代预计还要三天以后。十月份数学的重心大部分都是强化收尾工作。把之前漏看的、掌握不牢固的以及某个知识点题目做得比较少，都拿出来重新过了一遍。\n先具体说一下高数吧，要是论对考点的熟悉程度的话，掌握最好的应该是求极限，函数求极限只要不是太偏太怪太难理论上是没问题的了，数列求极限有待加强（原因很简单，求极限放在第一章，每一次重新过的时候，前半部分的时间花的最多，就好比是英语单词书最熟悉的是第一页的词汇一样）；其次就像是求导求积分之类的题目，不能说是掌握的太好，但是在做此类题目的时候，进入状态的时间有点长；而且求积分这块，尤其是不定积分就像是个无底洞，它有些常见的套路和题型，但却没有那么容易想到，这块的还有个难点是微分中值定理的证明题，从我现在的水平来说，是有希望啃下的，毕竟在暑期的时候就特地有投入时间在这部分，（昨晚在听 17 堂课中该专题的时候，看见题目能自然而然的想到如何构造辅助函数）但我怕的是，由于这部分确实比较难，出题比较灵活，万一出现课下模拟都会做，但是一到考试看见真题的时候傻眼了，这是及其恶心、难受的一件事，不花时间吧，我似乎又不太放心。。\n在不定积分和定积分还有两个盲点：第一个是变上限积分的比阶之类的，第二就是定积分的应用，包括几何应用和物理应用。比较明显的特点就是不是很难，但缺乏训练导致掌握的比较差，之前想的就是跟着武神的 17 堂课，再集合真题和模拟题巩固练习，但有的时候看见此类题目，容易产生抵触的心理。\n高数的下半部分也就是上面的特点，不是很难，但是掌握程度却不太理想。。在这次重新强化的过程中，加强了对于微分方程、多元函数微分学、二重积分的练习，当时想的就是这啥玩意哈，之前都学了个啥！！！由此可见之前学的有多差，现在回头来看要的多了，但是在做题之前还是需要先看一下知识点。。加强练习啊！！！发现问题之后，要学会解决它，不能放任不管。微分方程的话，技巧性不是很强，计算量略微有点点大，套模板记公式。多元函数微分，难度有一点点，特别是定义那块，给我感觉是整个高数部分考定义最难的点了。。。计算的话，需要细心，特别容易绕晕。二重积分，计算量有！根据定义域画出函数图像，这一块要仔细点，我觉得是难点所在，最后剩下的就是计算问题，如果在部分再考难一点，直接放弃吗？？\n线代的话，整体就是比较玄学，说不会吧，多少会一点，但是看见题目的时候，很多时候都无从下手，知识点全部都搅合在一起，能做的也只能是多花时间、多思考、多练习。所以我又把线代的强化课听了一遍，听李老讲题的时候，哎确实是这个道理，只要注意力集中也都听得懂，但是到自己做题目，就是另一回事了，关键原因还是无法利用题目所给的已知条件，甚至有的时候看完答案还得想好久，离考研不到六十天，有的时候，我就在想线代要不给放弃了？？但是放弃的话就代表着数学最多最多考到一百算是不错的了，李老还出了个综合提醒课，下个月抽时间看看吧。加油！\n② 英语 英语的话，阅读能感觉到已经没有问题了，但是问题是除了阅读其他的好像都有问题，准确来说是都还没开始，作文等进入十一月份，就可以准备起来了，新题型的话，我想的是等到十一月中旬再开始，翻译的话，有时间就开始吧。至于完型填空，我的预期目标是最少要及格，不拉后腿就好，可以适当的战略性放弃点。\n但是在做完英语二之后的阅读，再看英一的阅读，对比下来，英一要难好多，也许是自己阅读根本就没掌握好呢。。做英一阅读的时候，题目与文章的定位点大部分都能准确找到，但是英一的文章对于词汇和长难句要求真的是高很多，解题技巧会了，还是基础不牢，地动山摇？？这个阶段给我来这一出，我是真的怕啊！！！\n③ 专业课 专业课这部分我真的很感谢给我提供过帮助的学长学姐，要不然我真的是一脸懵逼。\n数据库：拉了许多的数据库终于补救回来了，呃，应该是抢救。。整个考纲里面所要求的知识点都有所掌握，常见的题目也都掌握的还行，盲点还在于关系代数和 SQL，这部分要抽时间集中练习，然后坚持到考前，至于关系演算，实在是看不懂，是不是可以放弃。。对了，还剩一章数据库设计没有看。。\n数据结构：这部分总体来说是比较熟悉的。但是具体到考点是比较迷茫的，因为数据结构的出题形式真的太多了，可以是只考理论也是可以写代码，甚至是画图。这就很恶心。十月份的重点都花在对于数据结构的查缺补漏上面，下个月计划再花半个月时间在二叉树、图、排序和查找，这部分知识点牵涉比较多，也是难点所在。一定要克服！！\n④ 政治 政治的话，我感觉是不是有点晚了，到现在才把马原看完，题目还没看完。政治这个科目，我已经开始迷了，完全不知道下一步该怎么走，该学什么。不对，是要学的太多，不知该怎么学。。。\n初步打算，跟完腿姐的技巧课。《肖 1000》的马原和史纲部分正确率要提到百分之九十，至于毛中特和思修的话，跟着模拟卷走吧，政治不求多，但是要及格啊。最起码证明自己的思想觉悟没问题，更何况自己还是党的一份子呢。。。。\n 三、莫问终点  是鹰就不留恋地平线，云层上见～\n 对了，我还在等。等一场大雪，来迎接这个冬季的到来，来从容地踏上考场，来记录我这一年的坚持与付出。\n至于终点是哪儿？其实，已经不是太重要了，这大半年的备考，让我自己的心又静下来许多。有的时候看不下去书，就会胡思乱想，其实我本身是一个比较喜欢发呆式思考的。在这断断续续的思想火花中，我也渐渐地更明白自己是一个怎样的人，想成为什么样的人。之前就听很多人说，考研的结果固然重要，但是真正值得回味的是这其中的过程，是一次次勇于挑战自己，敢于知难而上，不满足于目前的现状。\n之前，我总想着，等考上研究生就怎么怎么样，可以给自己放个假。但也许，考研只是这些年给自己的一个奋斗目标，督促自己要努力前进；也许自己并不喜欢读书专研，从而可能导致自己读研的时候会放纵自己；也许自己就是个差生，不是读书的那块料呢？？\n是的，也许吧。但是不坚持怎么会知道结果呢。不去尝试，又怎么能体会到这其中的酸甜苦辣呢。不逼自己一把，又怎么会确认自己就做不到呢？\n距离考研的日子越来越近了，就像前面所说的我已经在尽我最大的努力调整自己的心态，最后的冲刺阶段任务只会越来越重，心态上的煎熬也会加倍。当之前自己付出，到冲刺的白热化阶段慢慢感受到回报的时候，这一切都是值得的。\n考研，只是一场考试，是我所选择踏上的一条路，没必要把自己折磨的那么累，陷入极度的内卷，但这并不意味着是放纵自己的理由。还是要努力的啊！加油吧！\n感谢这个世界还有音乐~~\n","description":"","tags":null,"title":"大政的考研 Blog008 —— 莫问终点","uri":"/life/kaoyan008/"},{"categories":null,"content":"Blog007 —— 再出发，九月复盘 一、开始倒数 1.1 大四开学 时间过得真快，一眨眼，开学就是大四的老学长了。。这三年过来的一点一滴，就宛如刚发生一样，历历在目。现在回头想想，这几年经历了好多，但在学校中又似乎没有太大的收获。\n还记得三年前，这个时候还嚷嚷着想复读，现在看来其实都一样。也许复读顺利考得要稍微好一点，也可能不太幸运，甚至还不如现在呢。但当现在再一次为了一场考试而努力的时候，那种感觉又回来了。很多人都拿考研和高三比较，我感觉吧，相对而言考研要容易一点。因为考研能考个好学校的可能性要大一点，但是反过来看，高考的报录比是要好一点的，但是想读好的学校门槛是不一样的。于是也就有了，选择大于努力这一说话，考研真的是一场信息战！如果让我再选择一次的话，也许我仍然回想复习，但是现在也挺好的。遇见了很多意想不到的事情，遇见了很多有意思的灵魂。\n仔细算一下，正儿八经当时高中所憧憬的大学生活，也只能到大二上。 其余的时间，虽说还在学校，但是学习的内容和处理的事情都逐渐和学校的事情脱节，甚至在一定程度上反感学校许许多多杂七杂八的事情。大一，上课坐前排，参加社团活动，还想着找个对象吧啦吧啦的。。对待各种事情都特别认真。（大一的时候给自己定的目标就是拿到奖学金，认为奖学金就是最高的荣誉，现在看看，呃 不能说一点用都没有吧，反正就是没有之前想的那么重要，也就那么一回事罢了）对于大学的上课方式，社交方面还是很新鲜的，但是慢慢发现，和实际想的还差的很远，特别是遇见很多恶心的事情之后，就感觉天呐，一个学校怎么能是这个样子的，就离谱！！按照当时的脾气还会想着吐槽，但当看得多了，经历的多了，也就认了、不对是佛了。。当时大一特别想创建悠悠球社团，果不其然大二的时候，最折磨我的就是这个社团，每天想的都是怎么推广悠悠球，怎么把悠悠球传播出去，怎么教社员，怎么…… 就这样，心思也不放在学习了。就很难受，说句我不太喜欢的话，“不忘初心”，那么问题来了，初心是啥呢？？我怎么做的意义又在哪呢？？社团是我自己要创的，甩不掉的。。。（现在看看，如果说大学期间最值得纪念的事情，也只剩下这个社团了）再就是大二寒假，发生疫情，也就是在这个时间段发生的事情足以影响到我的大学生活，甚至是整个人生。由于疫情，线上开发协作，从而接触到了开源，也就有了现在的我，一个完全脱离于大学眼界的我。。感谢相遇~~（*这也是我为什么说我的校园生活只到大二上的原因，之后的生活等有时间可以细说*）。\n还记得去年这个时候，我还在犹豫，我到底要不要考研，或者说为什么决定去考研。我回来了??\n1.2 返校生活 是的，回学校之后，我的状态慢慢在恢复。这一点是我自己都感觉到比较惊喜和意外的，连我自己都没想到回到学校之后，状态真的在好转。七八两月暑假，说实话，离自己所要的复习预期，差的太多太多，都出现厌学心理，已经是在弃考的边缘徘徊的人了。。\n也许是因为暑假在自习室没有参照物来对比，整个网上的言论都是“我很努力”的这种，就很搞人心态。回到学校之后，发现大家都差不多嘛，（也许是我的学习太差 bushi）哈哈哈哈\n想通问题，恢复状态我想还是放在最后来说。\n但是最让我无语的事情是大四的课竟然还如此之多，那就逃呗，只要不挂科，就啥都好说，是吧。\n还有一点就是，自己还不够自律，要懂得拒绝，不能受别人影响、\n 二、九月复盘 ① 数学 回到学校的时候，高数和线代已经全部听完强化课了，就想着是不是已经无敌了，结果就是被题目恶狠狠的给教训了一顿，我还是依旧的菜鸡。。。\n起初，刷《考研数学真题大全解·上册》的时候，因为是之前较早的题目，难度不是很大，所以一口气能刷五六十道，还是很嘚瑟的，而且正确率也有一定的保证。但是刷着刷着就变味了，做着前面的章节忘着后面的，于是在刷题之前，还是得巩固一下知识点，《高数辅导讲义》算是三刷了吧，知识点必须要看，边看边在草稿纸上写写画画，好记性不如烂笔头，况且我还没有好记性，再把之前做标记的题目再给做一遍，但是我发现问题的是，之前会做的题目，现在反而不太会做了，之前不会的还是不会，害。。。对了，《严选题》的质量也是很高的，虽然做的比较慢，十月份结束之前一定要二刷，一定！！加油~~\n但这也是比较好的事情，最起码知道自己的不足，是吧（也只能这么想了）\n线代的话，就是一遍一遍的过讲义，把知识点給串起来。效果也就一遍比一遍要好，有意识的去逼自己思考某个知识点可能会关联的东西。然后再做《李林880》的线代部分，习题线代题目给我的感觉还是比较中规中矩的，不像高数的证明题那么让我感觉无奈，有时候给的感觉就是恰到好处想到那一步。就很爽！\n其实在看线代的时候，心里还是比较没底的，因为分值不是很大，所以投入的时间不是很多，就导致过了一段时间就会有部分知识点遗忘，再加上暑假的时候，看线代的强化课有点太追求进度，听得就有点囫囵吞枣，效果自然也就不咋地，特别是二次型那部分，基于以上原因，就决定重新听一边线代的强化课，带着脑子学习，而不是一味的接受知识。类似的情况还出现在高数的后半部分，多元函数微分学以及二重积分都是理解的不太透彻，所以决定重听一下，这些得在国庆假期完成，又回到了没有课的日子，一定要把握住啊！！\n② 英语 英语，怎么说呢，阅读做起来有点感觉了，但我怕的是因为之前刷过的试卷，所以二刷起来效果还行，就导致一种盲目自信的状态。因为是二刷，阅读在做起来，就在一定程度扫清了生词和长难句，所以读起来没有太磕磕巴巴，做题目也能找到定位点，或者是排除干扰选项，较好的还能分清错误选项是怎么设计出来的。\n但是效果太好，反而有点让我不太适应，我怕这一切都是因为是二刷，是因为我下意识的知道这篇文章是关于什么的，讨论的问题是啥。。。\n至于作文和新题型也还没开始，也不知道该何时开始，也不知该准备哪些资料，头大\n单词肯定是每天必不可少的一个环节，有的时候，不想做阅读，就想着今天我背单词了，所以等于我看英语了，来安慰自己。。。\n③ 专业课 这个月专业课算是正式开始了，目标院校的大纲也更新了，与往年相比变化不是很大，考得范围有的还缩小了，所以在复习层面来说，更具体了。但是具体到某些知识点该考哪些题型的时候，还是比较懵的，不知所云。\n这个怎么说呢，有利有弊，因为从我自己来说并不属于刷题类的学生，也不喜欢刷题，没有历年真题的透漏，等于在一定程度上弥补了这一劣势。但是坏处是，我自己也不知该如何复习。能做的就是一遍一遍的根据考纲过知识点，争取做到没有太大的漏洞。\n数据结构：开始算是二刷了吧，第一边只是侧重于知识点的学习，并没有做太多的题目，这一次看一章，死磕一章的课后习题，选择题做到全部拿下，算法大题目前只做历年 408 真题，有的较怪较难的算法题会考虑直接放弃，进度到二叉树。另外听说学院喜欢考对于知识点的理解，而不是代码本身，所以尽可能要做到掌握理解，用图形来表达其中的逻辑关系。\n数据库：这个算是比较头疼的，首先 SQL 写得就不多，而且还比较烂，看课后习题也只是能看懂答案，让我自己徒手写的话，有很大难度，所以之后的两个月要加强对于 SQL 的练习，这一部分可不能丢分啊！查询优化看的比较懵，就是稀里糊涂的。。。依赖与范式那章就直接差点”要了我的命“，国庆集中处理。至于数据库事务和恢复反而比预期学的要好。\n后期需要根据当前的盲点，不断“扫盲”。\n④ 政治 可算是开始政治了，但是也是九月中下旬才开始的，而且花的时间也不是很多，整体进度是比较拉的。说不着急是假的，但是不能慌。要稳住阵脚，一步一个脚印地往前走。\n因为之前对于哲学比较感兴趣，所以读了一些相关的书籍。学马原的时候，虽然是偏重于理解，反而是比较容易找到共鸣的，能在现实生活中找到投影。刷《肖 1000》正确率也还行。\nBtw，蹲坑的时候，政治刷题小程序效果还是不错的。哈哈哈哈。\n进度得加快，投入时间得多加点，加油！\n 三、再出发 为什么说是“再出发”呢？？倒数 100 天，算是比较有仪式感的日子，也预示着距离考研的日子从三位数变成两位数了，时间留给自己的时间不是很多了，得有点紧张感，所以说接下来的每一天如果状态不是很好，都是对这一天的浪费。\n如果把考研分阶段的话，今年三月之前的日子算作“0”，“0”代表着有想考研的想法，也做了一些努力，搜集了一些信息，但是距离真正开始行动，还是有一定的转变的；三月开始到暑假之前属于“1“，在这期间，慢慢开始投入时间和精力准备考研，会觉得考研还早呢，我还有一定的自由时间，复习状态也就还没拉满，整体上是比较放松的，有时候还会啥都抓，导致啥都学了点，但没完全学的尴尬情况；再往后就是暑假”2“，大家都说暑假是至关重要的两个月，因为这段时间完全是自己掌握的，这一点是真的，但没想到的是，在家复习没有学校的学习氛围，每天更要面对许许多多的日常琐事，眼看着自己的进度达不到所想的预期，心烦；九月开学——”3“，状态恢复，更想通了许多问题，所以是在解决了上面”012”的迷茫与不解之后的再出发！\n在预报名成功的那一刻，我不由的说了一句，我等这一刻，等了三年。对，为了考研，我鞭策自己三年。眼看着就要到终点了，不更应该是期待的嘛。而不是焦虑不安，原因是感觉复习的不好，但是还没走进考场，就代表着全部都是未知的，去努力啊！！别停下来！！\n所以说，把心态从焦虑调整到期待之后，每天都会有收获。有的时候还会看一下鸡汤，虽然很俗，但是有用，这段阶段的自己神经是比较敏感脆弱的，需要的是鼓励。\n希望会有好的结果，一定一定一定！！！\n","description":"","tags":null,"title":"大政的考研 Blog007 —— 再出发","uri":"/life/kaoyan007/"},{"categories":null,"content":"Blog006 —— Iridescent，八月复盘  Il n'ya qu'un héroïsme au monde : c'est de voir le monde tel qu'il est et de l'aimer.\n 一、暑期生活 1.1 一次又一次被自己打败 过得好快啊，感觉什么都没做，暑假就过去了。。。\n每次在放假之前都会高估自己的能力，常常给自己布置一堆任务，而往往完成的也就两三件，甚至一件都做不好。。。是的，这种状态从中学时期就开始出现，但到现在还依然没有改掉。为什么会给自己选择充电呢，从根本来说，我不想成为一个碌碌无为的人，还是有一颗上进的心的，要不然为什么会选择考研呢。。但事实是，完不成任务还是因为自己太懒，自己不够聪明，一个知识点别人学一遍就能记住掌握，自己却只能听个大概，为了不愿承认自己的能力不够，还硬着头皮往下走，结果到头来发现，欺骗的也只有自己。说白了，就是虚荣心作祟。。\n最要命的是，意识到自己的错误，却改不了！！\n之前上半年在学校临近放假的时候，就一直在想，到了暑假就好了，每天的时间都是自己的了，就能有大把时间用于考研复习，从而可以达到一个由量变到质变的过程。可也就停留在了“想”，与实际付出行动来说还是有很大的差距。\n最主要的体现就是心静不下来，明明知道这是一个难熬的过程，却想着可以早点结束，想着这块内容是不是不太可能会考，我是不是就没必要花太多时间在这儿，总想着投机取巧。不肯脚踏实地，一步一个脚印地慢慢走。也许是高估了自己的行动能力，整个暑假给数学的时间最长，以为自己数学学的还行，到了强化阶段，越复习面对一堆难题无从下手，更是一种逃避的态度，久而久之，对数学是越来越讨厌；其实不止数学，英语和专业课不也是的嘛，英语除了背单词，阅读题更是不想做，硬着头皮啃下一篇之后，就匆匆忙忙去对答案，很多题目都不找原因，为什么错，不去弄明白其逻辑关系；专业课更是三天打鱼两天晒网，不知道该看些什么，看着考纲，无能为力；至于政治，更是可笑至极，说着为了空出时间给其余科目，连碰都没碰，连考些啥内容都不知道……\n所以说整个暑假是什么都没做吗？？也不是吧，虽然状态不是很好，每天的学习时间也不是很长，没有达到自己所预期的目标，但完成了其中的一小半吧，具体的复习情况放在复盘内容。\n很多人说，最大的对手是自己本身。克服自己的懒惰，浇灭自己的虚荣心，改掉不良的习惯，加油啊！！要学会独自去面对风风雨雨，独自在知识的苦海中摸索。\n1.2 我在努力 虽然有很多坏习惯，但是我一直在努力改变自己，不求能够有多好，但保证不会越来越差。\n自习室八点半开门，知道晚起毁一上午，但明白早起毁一天，所以一般来说选择七点多起床。尝试过五六点起来背单词，困得不行；也有过睡到八点多再起来，但是到自习室都将近九点半，从而导致一上午背完单词，再做几题高数就中午了，效率太差。慢慢调整选择一个比较适合自己的时间。一开始刚放假，可能是在学校“憋”了太久，看书回来家就比较晚。吃完饭，洗好澡，十点多，就导致家里人的作息都被我打乱。考研是我自己所决定的，虽然说爸爸妈妈都很支持我，但是不能影响他们第二天工作，（主要还是爸妈比较心疼我，）所以就适当的回家早一点，这样一家人可以一起吃一口热乎的饭。\n看书看不下去，想着想哪，一会刷一下朋友圈，一会又看一下小破站。只能硬逼着自己改变，手机屏幕使用时间限时，朋友圈关闭，B 站换成青少年模式，取关不太有意义的博主。不想做题，就看着题目想思路，想不出就看答案，再自己在稿纸上演算一遍，还能怎么办呢？又不能真的不做，做不到主动，只能改变自己从被动的层面吸取知识。英语阅读啃不下来，先翻译，扫清生词和长难句，最起码做到能读懂再说，再根据阅读方法论慢慢梳理题目以及段落之间的逻辑关系，最后再看看讲解视频。没办法，学不下去啊，只能这样了，我也真的无能为力了，我甚至开始怀疑自己并不适合学习，才到这个点就耐不住性子了，开始急了。我也不知到底怎么做是对的，只能敷衍着走，最起码不愿意承认自己停下！\n1.3 折磨？调整？ 说起自己状态开始变差还得从六月底 AirPods Pro 丢了开始说起。说不心疼吧，是假的。至今我还能记起第一次带上降噪耳机的感觉，整个世界都安静了。原来自己每天生活的环境噪声这么大，这么小的机身是如何做到这么强的功能的…… 特别新奇和不可思议是当时的感觉。但随着慢慢习惯降噪之后，那种一开始的新鲜感也早已见，也许是耳机麦克风堵住了，降噪就变菜了。。作为苹果生态的一环，在手机和 iPad 切换也早已习惯。在丢了的那几天，就好像是少了好多东西，哪哪都不舒服，就这样开始不想学习。起初也想过买个华强北的。但是吧，买山寨不是我的习惯，再买个全新的？？感觉不值。暑期教育优惠，换个 MacBook 或者换个 iPad Pro 送耳机？？但是更期待 M2 芯片，自己的 iPad Air3 用起来也不差，就很烦。对这种状态一直环绕着初期。到七月底。每天被这些事情闹心。。。\n后来，慢慢想开了，其实自己或许也不依赖一副耳机，也或许并不一定要用苹果生态下的产品？？为了整个生态，舍弃了自己客制化的习惯，开始对于处理器、芯片、刷新率等不再讲究，音质也不再挑剔，似乎就感觉苹果的生态是最屌的，舍弃点有啥关系呢。就这样变成了韭菜。也就这样，我看上了 Sony WF 1000 XM4，体积不大，续航强，佩戴舒适度属于能接受的范围，没有生态。。。。但这又有啥呢，一再犹豫之后，在 AirPods Pro 丢了两个月之后，还是入手了 XM4。降噪的天花板，也让相信了蓝牙耳机也可以有音质。时隔两个月重新又有了降噪，虽然各方面能力都比 AirPods Pro 好得多，但第一次带上降噪的感觉再也回不来了。\n但我的状态回来了……\n在快对自己失去信心的时候，找回了之前的状态，虽然还没满血复习，但是足够了！！\n对了，顺便提一下，暑假期间我又迷上了变形金刚。这个算是我从小喜欢到大的 IP 了吧。虽然每天看柱子哥模型的评测浪费了不少时间，害……等上岸奖励自己一个，一定。（当时纠结要不要买柱子哥，买了 XM4 之后，就说等等吧，该有的都会有）\n最后再补上，还有奥运会。马龙太帅了，今年好像是在 08 年之后，再一次这么关注奥运会了，看见五星红旗在东京升起，国歌奏响的那一刻，民族自豪感油然而生。我们生活在一个这么好的时代，国家提供了安稳的环境，作为新时代的我们也应该奋发努力，想想再过十年左右社会的中流砥柱就是咱们这代人了！\n 二、八月复盘 很遗憾，暑假的计划并没有完成。。\n① 数学 分别听完了高数和线代的强化课程，但也仅仅是听完了而已。距离消化里面的知识还有一段路需要走。看讲义，做例题，还需要克服自己好高骛远的尿性，不能不懂装懂，还要勤动手，答案是算出来的，而不是看出来的。\n原以为八月能够把高数讲义重新过一遍，但是很遗憾，一遍看讲义然后做严选题和 08 年以前的考研真题，效率是真跟不上，才到第二章结束。但好处是前两章的知识点很牢固，从基本的定义题目（这类题目我感觉是很恶心的）到计算，再往后是压轴的证明题，都可以应付的来，也并不是像自己所想的那样啥思路都没有。坏处是后面的又给忘了，特别是常微分方程和多元微分学，一看就会，会了就忘。还得努力啊！！\n起初，做严选题太难，就转去做宇哥的真题大全解上册，给自己找点求生欲吧。后来一想，考研不会考简单的，要学会迎难而上。啃严选题的时候，给我最大的感受就是，这题我应该会做，但不是那么好做，最后往往会停留在应该上。。给题目做好标记分类。一遍一遍来，反复磨，总会完成的。\n线代的话，因为之前看完基础课的时候，就顺带把讲义过了一遍，这次的复习感觉比听基础课要好得多。但到了后面的章节之后，越来越综合，知识点稍有不牢，就不知这个为什么是这样，这一步是哪来的。课程内容不是很多 5 天，但我花了将近 15 天才全部看完。中间真的不能耽搁，一落下，很难追上。再刷讲义，也比之前有了更多思考，也想的更多，牵涉到的知识点，也算是一种巩固的过程。\n今晚听了武神的直播答疑，说强化阶段是到 10 月底，这无疑是一针强心针，可以告诉自己不要慌，进度并没有落太远。慢慢来，比较快，加油！\n② 英语 英语就有点玄学，除了背单词能记住（其实也不一定记住了）。阅读还是很难有底。做完了之后，站在上帝视角来分析，会觉得确实是那么一回事，但自己做题的时候为什么就想不到呢。知行合一？？只是知道方法论，做不对题目的知道，算是知道吗？\n在月底的时候梳理这两个月做过的阅读，还是挺有成就感的。看着原来白纸黑字的被一片片红笔的注释不成样子（错的不成样子）也确实有点难受的。不能说没有掌握阅读方法论，但就是还缺点什么，不像做数学题目那样，只要是我自己做出的就不会出错。\n小三门之类的也快要提上日程了，英语的时间要要延长点了。\n③ 专业课 七月说专业课每天 1.5 小时起步，还是没做到。\n数据结构结合考纲把知识点提出来了，但问题是不知道考试题目会考到哪种程度，是只考一些定义性质，还是会考代码呢，考这些又会怎么考呢？？\n数据结构就是感觉零碎的知识点好多，做题之前过一遍的话，题目都是会做的但是时间一长就容易忘记。。而且对于数据数据结构考纲比较迷，像栈牵涉到的中缀表达式、图涉及到的求关键路径之类的，王道的书上有，但是考纲上写得比较迷糊的不知道该不该看，以及题目的形式都好迷。。\n数据库，很碎很杂很多，有点像文科但它又不是。。其中像关系代数、元组演算之类的自我感觉不会考（蜜汁自信），因为掌握的不太好。。但是像 SQL 感觉理论上属于必考的，数据库不写 SQL 说不过去吧，至于考得有多难，掌握到什么程度又不知该如何。\n④ 政治 看不下书的时候，看政治打发时间必备~~\n九月份马原\n 三、Iridescent 世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它。\n我知道考研难熬，但我没想到是如此煎熬。暑假的复习状态几乎一直处于复习的低谷。好几次出现了弃考的想法，总想着也许自己就这样了吧，不是块学习的料，不适合学习。起初想考研更多是对高考遗憾的一种弥补，也是怕自己到时候啥都不会找不到工作。\n但现在看来这两样似乎也就那么一回事，那么我考研的意义又在哪里呢？研究生的生活又会想是自己所期望的那样吗？或者说，自己真的有想过读研的生活是哪样的嘛？也许我就是单纯的不知自己该干嘛所做出的一种逃避呢？？\n忽然想起自己以前的博客说过，我也想成为一个闪闪发光的人。\n考研与其说是孤独朝圣，倒不如说是与自己的对话。学习如逆水行舟，学海无涯。面对知识的敬畏，自己的内心到底会怎么做。走下去，卷入无尽深渊，退出，接受自己的平庸无能？？有时候还会想读书有什么用？人活着的目的又在哪？人该追求些什么呢？当今社会的价值观如此畸形，自己的价值观又该如何评判呢？\n好吧，我承认，考研真的很容易胡思乱想。人均哲学家。。。。\n说到底，我想成为一个有能力的人。进一步的话，成为一个有能力影响他人的人。\n Do you feel cold and lost in desperation\nYou build up hope but failure's all you've known\nRemember all the sadness and frustration\nAnd let it go\nLet it go\n ","description":"","tags":null,"title":"大政的考研 Blog006 —— Iridescent","uri":"/life/kaoyan006/"},{"categories":null,"content":"Hadoop 极简入门 零、前言 在 2021 年初的时候，Apache 退休了一些 Hadoop 生态圈的子项目。再加上其 MapReduce 思想最为人诟病，因为不太友好的编写代码方式，需要高昂的维护成本以及较低的运行效率，唱衰 Hadoop 的声音（甚至对于整个大数据生态的质疑声）日益高涨。。\n然而，MapReduce 作为一种编程范式，恐怕并没有那么容易被淘汰。纵使很多人说：你看 Spark 速度又快又稳定，这不是可以淘汰掉 Hadoop 的 MapReduce 吗？但是真的是这样吗？？\n所谓的快和慢都是相对而言的。某些互联网公司每天的离线调度任务动辄数十万起，这么庞大的基于 MapReduce 的离线计算如果要是用 Spark 来替代，与之相对应的是高昂的服务器成本。\n因此，我们可以说原来用 Hadoop MapReduce 能做的事情被更好更快的其他计算引擎来替代了，而不是 MapReduce 被淘汰了。而且后来的计算引擎也大都有借鉴 Map、Reduce 这类的概念！\n 一、长话短说 1.1 Hadoop 是什么？？ Hadoop 是 Apache Software Foundation 开源的，根据 Google 开源的三篇大数据论文设计的，一个能够允许大量数据在计算机集群中，通过使用简单的编程模型进行分布式处理的框架。其设计的规模可从单一的服务器到数千台服务器，每一个均可提供局部运算和存储功能。Hadoop 并不依赖昂贵的硬件以支持高可用性。Hadoop 可以检测并处理应用层上的错误，并可以把错误转移到其他服务器上(让它错误，我在用别的服务器顶上就可以了)，所以 Hadoop 提供一个基于计算机集群的、高效性的服务。\n1.2 主要优势 主要拥有以下优势：\n 高可靠性：Hadoop 底层维护多个数据副本，所以即使 Hadoop 某个计算元素或存储出现故障，也不会导致数据丢失； 高扩展性：在集群间分配任务数据，可方便地扩展数以千计的结点； 高效性：在 MapReduce 的思想下，Hadoop 是并行工作的，以加快任务处理的速度； 高容错性：能够自动将失败任务重新分配。  1.3 发展 经过多年的发展，Hadoop 这个单词的意思也随之发生改变，由之前一个具体项目的名称，到现在提到 Hadoop 大多是指大数据的生态圈，包括许多现在火的一腿的项目，例如 Spark、Hive、HBase 等等。\n如同 Spring 框架有着最基础的几个模块 Context、Bean 和 Core。其余的模块和项目都是基于这些模块构建的。Hadoop 与之大体一样，也有最基础的几个模块：\n Common：支持其它模块的公用工具包； HDFS：一个可高吞吐访问应用数据的分布式文件系统； Yarn：一个管理集群服务资源和任务调度的框架； MapReduce：基于 Yarn 对于大数据集群进行并行计算的系统。  其他的，像 Hbase、Hive 等等都是在这几个模块基础上的高级抽象。Common 模块是 Hadoop 最为基础的模块，负责为其余模块提供了像 I/O、操作文件系统、序列化和远程方法调用等最为基础的实现。（如果想深入了解 Hadoop 具体实现的小朋友，可以挑战自己阅读一下 Common 的源码~~）\n 二、HDFS 基础概念 HDFS 是 “Hadoop Distributed File System”的首字母缩写，是一个分布式文件系统，说简单点就是为了存储文件。但是和其他的文件系统的不同之处是 HDFS 设计为运行在低成本的硬件上（因此在学习 Hadoop 入门的时候，可以使用 Linux 虚拟机搭建一套集群出来玩玩），且提供高可靠性的服务器。HDFS 设计满足大数据量，高吞吐的应用情况。\n为了更好地理解分布式文件系统，咱们先看看下面的这些概念：\n2.1 文件 咦？谈起文件，想必大家都很熟悉，在不同的行业中，文件也有着不同的意思。在计算机科学领域，文件是在存储设备中是 N 个字节序列。而从计算机使用者的角度而言，文件是对所有 I/O 设备的抽象。每个 I/O 设备都可以视为文件，包括磁盘、键盘和网络等等。文件这个简单而精致的概念其内涵是十分丰富的，它向应用程序提供了一个统一的视角，来看待系统中可能含有的各式各样的 I/O 设备。\n2.2 文件系统 那么一台计算机上肯定不止一个文件，成千上万的文件怎么管理呢？因此需要我们需要一种对文件进行管理的东西，即文件系统。文件系统是一种在计算机上存储和组织数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据而不必关心数据实际保存在硬盘的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的那个块地址没有被使用，硬盘上的存储空间管理(分配和释放)功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中即可。\n2.3 分布式文件系统 相对于单机的文件系统而言，分布式文件系统（Distributed file system）。是一种允许文件通过网络在多台主机上分享的文件系统，可让多计算机上的多用户分享文件和存储空间。\n在这样的文件系统中，客户端并非直接访问底层的数据存储区块和磁盘。而是通过网络，基于单机文件系统并借由特定的通信协议的帮助，来实现对于文件系统的读写。\n分布式文件系统需要拥有的最基本的能力是通过畅通网络 I/O 来实现数据的复制与容错。也就是说，一方面一个文件是分为多个数据块分布在多个设备中。另一方面，数据块有多个副本分布在不同的设备上。即使有一小部分的设备出现离线和宕机等情况，整体来说文件系统仍然可以持续运作而不会有数据损失。\n注意：分布式文件系统和分布式数据存储的界线是模糊的，但一般来说，分布式文件系统是被设计用在局域网，比较强调的是传统文件系统概念的延伸，并通过软件方法来达成容错的目的。而分布式数据存储，则是泛指应用分布式运算技术的文件和数据库等提供数据存储服务的系统。\n2.4 HDFS HDFS 正是 Hadoop 中负责分布式文件系统的。HDFS 采用master/slave 架构。一个 HDFS 集群是由一个Namenode（可以理解为资本家老板） 和一定数目的 Datanodes（打工人） 组成。Namenode 是一个中心服务器，负责管理文件系统的命名空间以及文件的访问控制。集群中的 Datanode 一般是一个设备上部署一个，负责管理它所在节点上的存储。HDFS 暴露了文件系统的命名空间，用户能够以文件的形式在上面存储数据。\n实际上，一个文件会被分成一个或多个数据块，这些块存储在一组 Datanode 上。Namenode 执行文件系统的命名空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体 Datanode 设备的映射。Datanode 负责处理文件系统客户端的读写请求。在 Namenode 的统一调度下进行数据块的创建、删除和复制。为了保证文件系统的高可靠，往往需要另一个 Standby 的 Namenode 在 Actived Namenode 出现问题后，立刻接管文件系统。\nHDFS 架构概述  NameNode（nn）：存储文件的 元数据，如文件名、文件目录结构、文件属性（生成时间、副本数、文件权限），以及每个文件的 块列表 和 块所在的 DataNode 等等； DataNode（dn）：在本地文件系统 存储文件块数据。以及 块数据的校验和； SecondaryNameNode（2nn）：每隔一段时间对 NameNode 元数据备份（把 NameNode 当做老板的话，SecondaryNameNode 就相当于小秘，但小秘毕竟是小秘备份的数据肯定没有老板完全，所以在掌握 Zookeeper 之后可以配置 HA，也就是说两个 NameNode 互相备份）。   三、MapReduce 基础概念 MapReduce 是一个使用简单的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上 T 级别的数据集。\n一个 MapReduce 作业(job)通常会把输入的数据集切分为若干独立的数据块，由 map 任务(task)以完全并行的方式处理它们。框架会对 map 的输出先进行排序， 然后把结果输入给 reduce 任务。通常作业的输入和输出都会被存储在文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。\n通常，MapReduce 框架和 HDFS 是运行在一相同的设备集群上的，也就是说，计算设备和存储设备通常在一起。这种配置允许框架在那些已经存好数据的设备上高效地调度任务，这可以使整个集群的网络带宽被非常高效地利用。\nMapReduce 框架由一个单独的 master JobTracker 和每个集群设备一个 slave TaskTracker 共同组成。master 负责调度构成一个作业的所有任务，这些任务分布在不同的 slave 上，master 监控它们的执行，重新执行已经失败的任务。而 slave 仅负责执行由 master 指派的任务。\n用户编写的 MapReduce 应用程序应该指明输入/输出的文件位置(路径)，并通过实现合适的接口或抽象类提供 map 和 reduce 函数。再加上其他作业的参数，就构成了作业配置(job configuration)。然后，job client 提交作业(jar 包/可执行程序等)和配置信息给 JobTracker，后者负责分发这些软件和配置信息给 slave、调度任务并监控它们的执行，同时提供状态和诊断信息给 job-client。\n简单来说，MapReduce 将计算过程分为两个阶段：Map 和 Reduce；\n Map 阶段并行处理数据； Reduce 阶段对 Map 结果进行汇总。  一个 Map 函数就是对一些独立元素组成的概念上的列表的每一个元素进行指定的操作。事实上，每个元素都是被独立操作的，而原始列表没有被更改，因为这里创建了一个新的列表来保存操作结果。这就是说，Map操作是可以高度并行的。而 Reduce 函数指的是对 Map 函数的结果（中间经过洗牌的过程，会把 map 的结果进行分组）分组后多个列表的元素进行适当的归并。\n 四、Yarn 基础概念 YARN(Yet Another Resource Negotiator)是 Hadoop 的设备资源管理器，它是一个通用资源管理系统，MapReduce 和其他上层应用提供统一的资源管理和调度，它为集群在利用率、资源统一管理和数据共享等方面提供了巨大的帮助。\nYarn由ResourceManager、NodeManager、ApplicationMaster 和 Containe 四个概念构成。\n ResourceManager（RM）：整个集群资源（内存、CPU 等）的老大； NodeManager（NM）：单个结点服务器资源老大； ApplicationMaster（AM）：单个任务运行的老大； Container：容器，相当于一台独立的服务器，里面封装了任务运行任务所需要的资源，如内存、CPU、磁盘、网络等。  了解了上面的大致概念之后，再细细分析一下：\n4.1 ResourceManager ResourceManager 是一个全局的资源管理器，负责整个系统的资源管理和分配。它主要由两个组件构成：调度器(Scheduler)和应用程序管理器(Applications Manager)。\n调度器根据容量、队列等限制条件，将系统中的资源分配给各个正在运行的 MapReduce 程序。应用程序管理器负责管理整个系统中所有 MapReduce程序，包括提交、与调度器协商资源以启动 ApplicationMaster、监控 ApplicationMaster 运行状态并在失败时重新启动它等。\n4.2 NodeManager NodeManager 是每个设备上的资源和任务管理器，一方面，它会定时地向 ResourceManager 汇报本设备上的资源使用情况和各个Container 的运行状态；另一方面，它接收并处理来自ApplicationMaster 的 Container 启动/停止等各种请求。\n4.3 ApplicationMaster 用户提交的每个 MapReduce 程序均包含一个 ApplicationMaster，主要功能包括：与 ResourceManager 调度器协商以获取资源(用 Container 表示)；将得到的任务进一步分配给内部的任务(资源的二次分配)；与 NodeManager 通信以启动/停止任务；监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务。\n4.4 Container Container 是 YARN 中的资源抽象，它封装了某个设备上的多维度资源，如内存、CPU、磁盘、网络等，当 AM 向 RM 申请资源时，RM 为AM 返回的资源便是用 Container 表示。\n 五、结束语 本文走马观花的介绍了 Hadoop 相关内容。主要目的是给大家一个对大数据的分布式解决方案的感官印象，为后面的大数据相关文章提供一个基础的理解。\n最后要强调的是，思考大数据方向的问题是一定要记住分布式的概念，因为你的数据并不在一个设备中甚至不再一个集群中，而且计算也是分布的。所以在设计大数据应用程序时，要花时间思考程序和算法在单机应用和分布式应用所产生的不同(e.g. 加权平均值)。\n","description":"","tags":null,"title":"Hadoop001——入门篇","uri":"/tech/bigdata/bigdata_hadoop001/"},{"categories":null,"content":"Blog005 —— 事上炼，七月复盘 一、恍惚 1.1 怂了？？  这才到哪了呢，就怂了！！明明每天给自己布置的任务量不是很大，却还是一次又一次高估自己的执行能力，整个七月份下来，没有几天实际上完成目标的。但是，平均下来给自己每天的任务量确实不是很大啊，但为什么就完成不了呢？？一身的小毛病却不能克服自己，总给自己找各种各样的理由，来推脱学习。王福政啊，你现在的思想和态度都很危险知不知道！！！当你的行动能力和效率无法满足自身的野心的时候，除了抱怨，怨天尤人还能做些什么呢？？\n 以上，大概是这段时间，反反复复对自己说的话。虽然想放弃是真的，但认怂是不可能认怂的！！！\n考研过程中的备考压力远远超出我心里的预期，比我想的要难受的多。这也是为什么想要放弃的原因，似乎放弃了，就退出备考的赛道，可以好好的缓一口气，也就不会面对煎熬，不会面对失败，但也意味着辜负了父母的期望，前期的准备都是为了见证这一刻的放弃，承认自己的软弱。如果放弃，每次遇到点啥磕磕绊绊的象征性的坚持一两下，就会怀疑自己做不到，想逃避，下意识的想退缩。也就这样成为一个懦夫……\n所以说，认怂是不可能认怂的。当时做出准备考研的决定，并不是头脑一热，更多的是因为有自己想做的事情，寻找自己的闪光点，努力成为一个能够影响别人的！！！如果这时候选择了低头，这不就成了别人口中的反面教材了嘛。。多丢人啊，是不！！想放弃也许是多个坚持不下来的瞬间累计导致的，但选择站起来勇敢的直面这些瞬间，是自己能到做出的回应。认怂的话，自己心里说说就好，可别真的怂了哈~~ 坚持下去，一步一个脚印。\n1.2 长跑心态 7 月份，过得是真的快。当时想着放暑假了，没有学校那么多杂七杂八且无意义的事情，总算可以“闭关修炼”了。事实却是，整体上和学校的学习效率差不太多，又一次没达到预期，高估了自己。这也是为啥想放弃的原因，开始质疑自己，甚至有时候感慨自己真的不是学习的料。中高考考得都不咋地，还想考着考研翻身，这是有点痴心妄想嘛，别坚持五六年的努力，你一年就能跟得上？？但是，就这样认输，会有点不甘心。\n现在的世界好处是信息多而广，且好获得。但坏处是干扰信息太多。往往也是这些干扰信息最搞人心态！！！无论是知乎，还是 B 站、公众号之类的平台，凡是可以传播信息的地方都会出现标题党。最让我恶心的就是“考研人一天学习 XX 小时”、“如何保证一天有效学习 XX 小时”之类的文章或视频。给你一种感觉就是：反正我学能学到这么长时间，早上 6 点就能背单词，晚上 11 点还在复盘。如果你达不到这种程度，你自己看着办吧。WDNMD，您可真能学习啊！！！我自己是一个极其懒的人，能早上八点起来绝不起点起来看书的那种，而且注意力也很难集中。每当做一件事的时候，总会控制不住自己想另外一件事情。仔细想想，每天花在考研上的有效时间不超过四个小时每天。但就是在这种情况下，进度还能跟得上。所以我特别想知道那些每天做到学习八小时以上的是学到了什么程度。这也是我之前所提到的 考研在没有上考场的情况下，所有的参照物都是无用的。\n上面扯了那么多，不是想说我摸鱼都能学到这种程度，也不是想吐槽那些“卷王”，只是想说，我天天那么混都觉得好累！！！更何况现在才到备考中期强化阶段，距离考研还有五个月左右的时间该怎么熬啊！！考研不是短距离冲刺，不是说这段时间坚持坚持突击搞一下就行。更像是一场马拉松，虽然知道终点线，但一路上的磕磕绊绊，遇到哪些荆棘都是未知的。一路上没人能够帮你走下去，只有你自己。这也就有了“孤独朝圣”这一说话。更像是一场与自己的修行。但与马拉松不同的是，你还不知道你的对手如何。\n之前总是听考研的过来人说，别开始那么早，战线别拉太长。当时自己想的是，我能坚持，我要变强。也许按照当时的心态是可以坚持的，但随着距离考研越来越近，焦虑感、压迫感就会慢慢左右心态。所以能做到的只能是，调整好自己，给自己足够的弹性空间，在不那么长的学习时间内，保持自己最高的效率来学习。说白了，没有人说学多长时间就一定能够上岸的。干嘛那么折腾自己呢。。。\n1.3 当 代 毕 业 生 生 存 现 状 一个普通青年毕业后的生存故事。虽然距离毕业还有一年，但从小金身上或多或少看到了点自己的影子：从怀着赤子之心，想着要成为一个对社会有用的人，到慢慢遇到很多不情愿的事情，渐渐地磨平自己的棱角，但好在我还是我。正如罗曼·罗兰所说：世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它 。当看到这个视频中小金将视频通话转成语音的时候，破防了。。。似乎，这半年来的心酸、难受都在那一刻哭了出来。就想到自己，这半年来有好几次我妈给我开视频，都被我给转成语音，也不知道是什么原因，至少不想让家里人看到我丧的那一面。成长，也许就是从小时候有什么委屈哇的一声在母亲的怀抱里就能哭出来，到习惯了报喜不报忧，让爸妈少为自己操点心，告诉他们自己过得还不错，我没有止步，还在努力。\n 我不要在孤独失败中死去\n我不要一直活在地下里\n物质的骗局\n匆匆的蚂蚁\n没有文化的人不伤心\n  二、七月复盘 这个月的复盘要严格批评自己，学习效率太差！！！\n① 数学 7.23 完成高数强化阶段的全部课程。本预计还空出一周时间留出来查缺补漏，但事与愿违，可能是真的学倦了，然后台风暴雨刚好给自己一个偷懒的理由，最后一周没有认真学习。八月加油吧！！\n总体上武神的强化课干货上是没得说的，但不幸的是听起来太痛苦，有的章节要是死磕的话需要听好几遍才有点效果。没有听宇哥的课有那么多快乐。强化阶段确实是比较过瘾的，没有基础阶段的苦恼，不用扣定义，更倾向于做题，属于学会即用，所见即所得的感觉，说直白点就是过瘾，当看见讲义上一道道被自己画 pass 的题号越来越多，成就感也是满满。但有时候题目做不出来的挫败感也是十分闹心的……\n高数整个强化下来，对于考试的侧重点有了个了解，题型以及考点之类的啊，不像之前那样啥都抓，往往是哪都不熟悉。高数的盲点少了点吧，难点无非还是证明不太会，盲点的话是定义类的选择题。不熟悉的地方就是定积分的物理应用吧，也不能说是不会只是不熟悉，需要点题目来积累信心。对于基本知识的应用理论来说没什么问题，具体的掌握的好与不好，还得靠之后的题目来检测。\n《严选题》还没开工，之前看有些同学说这本习题册的难度是有的，看来又是一段煎熬时光。\n预计八月十号之后开始线性代数的强化。十五天之内务必完成。这样一来，八月就完成了所有的强化课程。接下来就是刷题。千题百炼，加油吧！！！\n② 英语 英语这个月进度有点拉。除了每天坚持背 45 分钟单词，阅读有点三天打鱼两天晒网，八月需要调整过来，至少两天一篇。\n课程上，重新听了一遍唐叔的阅读方法论和长难句，阅读方面确实有提升，但是长难句越听越混，总体来说阅读能力有所提升。错误率控制在每篇一到两个，能够分别出不同的题目怎么解题，解题不到位的情况大部分还是文章读不太懂，少许是解题方法的错误，易错点：猜测题，无法联系上下文逻辑。比较擅长例证题、作者态度、中心思想之类的题目。实践出真知，好事多磨。\n③ 专业课 专业课则是放慢了脚步，结合考纲（害 终于想起来我们是有考纲的，而不是 408 的 DS）把数据结构的知识点做了个梳理，这一轮下来，对于专业课上，心更静了。不会有种飘飘然的感觉。花了一个月时间都是数据结构，数据库方面还是前三章。对于后面的内容就交给八月份吧。\n底线：每天 1.5 个小时起步，再不花时间，等后期只会干着急，等着哭吧！！！\n④ 政治 这玩意怎么说呢，我书都没带。但是说不着急，心里还是慌的。所以把徐涛的强化课当下饭视频看着玩，给到点心里安慰吧~~\n 三、可以的！ 写到这的时候，我又回头看了看之前的博客，似乎给人的感觉是怨气有点重，就好比是深处深渊，却不甘于此，于是一步一步地前进。用努力去创造属于自己的那一份荣耀。更多是挣扎之后的倔强。虽然好像连续的这几个月都说着好难啊，好累啊的话，但如果我自己都不给自己点鼓励，那么谁还会相信我可以呢？？\n事上炼，谈何容易？？考研与其说是一段备考的经历，更像是一次寻找自己的过程，每当遇到困难的时候，每一次迷茫绝望都是和自己对话的过程。唯有练就强大的内心，才能坚定的向上走，迈向更高的台阶。\n光阴里的每一步都是修行，不知之间早已 自渡''。\n","description":"","tags":null,"title":"大政的考研 Blog005 —— 事上炼","uri":"/life/kaoyan005/"},{"categories":null,"content":"Maven 常见问题处理方法 一、'npm install node-sass --unsafe-perm' failed 报错信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 02:01 min [INFO] Finished at: 2021-07-10 [INFO] ------------------------------------------------------------------------ [ERROR] Failed to execute goal com.github.eirslett:frontend-maven-plugin:1.6:npm (npm install node-sass --unsafe-perm) on project dolphinscheduler-ui: Failed to run task: 'npm install node-sass --unsafe-perm' failed. java.io.IOException: Cannot run program \"dolphinscheduler-dev\\dolphinscheduler-ui\\node\\node.exe\" (in directory \"dolphinscheduler-dev\\dolphinscheduler-ui\"): CreateProcess error=193, %1 不是有效的 Win32 应用程序。 -\u003e [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles: [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException [ERROR] [ERROR] After correcting the problems, you can resume the build with the command [ERROR] mvn \u003cargs\u003e -rf :dolphinscheduler-ui   错误分析：\n当执行 mvn -U install package -Prelease -Dmaven.test.skip=true 的时候，由于前端 Module 的 pom.xml 对于 NodeJs 没有配置对应的镜像，并且有某堵墙的存在，懂的都懂不多说哈，从而导致无法能够成功的拉去对应的资源，因此需要在对应的 pom.xml 文件中添加相关配置即可。\n解决方法：\n1 2 3 4 5 6 7 8 9 10 11 12  \u003cexecution\u003e \u003cid\u003einstall node and npm\u003c/id\u003e \u003cgoals\u003e \u003cgoal\u003einstall-node-and-npm\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003cnodeVersion\u003e${node.version}\u003c/nodeVersion\u003e \u003cnpmVersion\u003e${npm.version}\u003c/npmVersion\u003e \u003cnodeDownloadRoot\u003ehttps://npm.taobao.org/mirrors/node/\u003c/nodeDownloadRoot\u003e \u003cnpmDownloadRoot\u003ehttps://registry.npm.taobao.org/npm/-/\u003c/npmDownloadRoot\u003e \u003c/configuration\u003e \u003c/execution\u003e   注： 其中 nodeDownloadRoot 和 npmDownloadRoot 为添加的淘宝镜像，如果添加该配置还无法解决问题，可以尝试把 node 和 npm 的 version 置换成本机所安装的版本即可。\n 二、Could not transfer artifact org.springframework.boot:spring-boot-starter-parent:pom:2.1.18.RELEASE from/to central 报错信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  Caused by: org.apache.maven.project.ProjectBuildingException: Some problems were encountered while processing the POMs: [ERROR] Non-resolvable import POM: Could not transfer artifact org.springframework.boot:spring-boot-starter-parent:pom:2.1.18.RELEASE from/to central (http://repo.maven.apache.org/maven2): Failed to transfer http://repo.maven.apache.org/maven2/org/springframework/boot/spring-boot-starter-parent/2.1.18.RELEASE/spring-boot-starter-parent-2.1.18.RELEASE.pom. Error code 501, HTTPS Required @ org.apache.dolphinscheduler:dolphinscheduler:1.3.6-SNAPSHOT, D:\\ideaProjects\\dolphinscheduler-dev\\pom.xml, line 165, column 25 at org.apache.maven.project.DefaultProjectBuilder.build(DefaultProjectBuilder.java:176) at org.apache.maven.project.DefaultProjectBuilder.build(DefaultProjectBuilder.java:102) at io.airlift.resolver.ArtifactResolver.getMavenProject(ArtifactResolver.java:177) ... 44 more Caused by: org.apache.maven.model.building.ModelBuildingException: 1 problem was encountered while building the effective model for org.apache.dolphinscheduler:dolphinscheduler-registry-zookeeper:1.3.6-SNAPSHOT [ERROR] Non-resolvable import POM: Could not transfer artifact org.springframework.boot:spring-boot-starter-parent:pom:2.1.18.RELEASE from/to central (http://repo.maven.apache.org/maven2): Failed to transfer http://repo.maven.apache.org/maven2/org/springframework/boot/spring-boot-starter-parent/2.1.18.RELEASE/spring-boot-starter-parent-2.1.18.RELEASE.pom. Error code 501, HTTPS Required @ org.apache.dolphinscheduler:dolphinscheduler:1.3.6-SNAPSHOT, D:\\ideaProjects\\dolphinscheduler-dev\\pom.xml, line 165, column 25 at org.apache.maven.model.building.DefaultModelProblemCollector.newModelBuildingException(DefaultModelProblemCollector.java:195) at org.apache.maven.model.building.DefaultModelBuilder.build(DefaultModelBuilder.java:419) at org.apache.maven.model.building.DefaultModelBuilder.build(DefaultModelBuilder.java:371) at org.apache.maven.model.building.DefaultModelBuilder.build(DefaultModelBuilder.java:362) at org.apache.maven.model.building.DefaultModelBuilder.build(DefaultModelBuilder.java:232) at org.apache.maven.project.DefaultProjectBuilder.build(DefaultProjectBuilder.java:142) ... 46 more Process finished with exit code 1   错误分析：\n在网上拷贝的所有阿里云镜像比如：\n1 2 3 4 5 6  \u003cmirror\u003e \u003cid\u003enexus-aliyun\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003eNexus aliyun\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public\u003c/url\u003e \u003c/mirror\u003e   查看官网之后发现：阿里不再支持http下载，只支持https。\n因此，先将maven镜像配置如下：\n1 2 3 4 5 6  \u003cmirror\u003e \u003cid\u003ealiyunmaven\u003c/id\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003e阿里云公共仓库\u003c/name\u003e \u003curl\u003ehttps://maven.aliyun.com/repository/public\u003c/url\u003e \u003c/mirror\u003e   然后还出现了一个问题，由于使用了HTTPS，存在着 SSL 证书验证的问题，因此需要在 IDEA 中添加了一行配置 Maven —\u003e Importing —\u003e VM options for importer:\n-Dmaven.wagon.http.ssl.allowall=true\n一般到这里问题理论上是可以正常解决了，但是由于 Windows 的环境会出现许多神奇的问题，如果项目还依然报错，可以尝试删除本地包，重新构建。\n","description":"","tags":null,"title":"Maven 配置问题汇总","uri":"/tech/datastructes/question001/"},{"categories":null,"content":"Blog004 —— 拼个世界给自己，六月复盘 一、瓶颈期 1、一条路走到黑 考研就像是在黑屋子里洗衣服，看不见洗到什么程度，也不知道自己和别人差在哪里，自己低头拼命的洗，只有打开灯的时候，拿出自己的衣服，才能知道结果如何，但在这一过程中难免也会有感觉洗不动的时候。\n不知不觉半年过去了，这半年宛如一个人走一条只知道目的地，但是却不知该怎么走的黑路，很多时候感到迷茫，感到困惑，明知道某个点该歇一歇，但就是不敢停下脚步，生怕自己一旦停下，被别人超越，就再也追不回了。考研和高考相比，不清楚自己的竞争对手，也就没有有效的对比，不知道该做到什么程度才算是好，才能达到了某个时间点该有的样子。毫无头绪。\n其实这半年来，每个月总有几天学不下去的时候，还记得当时三月底，怀着急功近利的目的，开始肝《十天搞定考研词汇》，每天一睁眼一闭眼都是单词，甚至有一种看见字母有头晕的感觉。但还好我坚持了下来，说一句鸡汤的话，付出总有回报，啃完单词，再开始刷真题的时候，大部分单词都认识，至少心理上不会太排斥。四月份五月份的时候，专业课还没有正儿八经的开始，就隐隐约约总有一种紧张感，怕时间来不及，怕学不会。现在回头来看，虽然专业课没有认真的看，但把教材和课后习题，在无聊的时候过了一遍，对照考纲，大部分的知识点还是比较熟悉的。再到六月，这个月真的是各种倒霉，倒霉，倒霉！！！这个月估算了一下，只看了二十二天的书，先是知道暑假学校不给留校，然后 AirPods Pro 在图书馆无故丢了，再到期末考试，最后学院还给安排个校内实习？？有意义嘛，唉。所以到现在开始复盘的时候，心里还是五味杂陈，这个世界怎么了嘛，呃，简单来说，阻碍你考研的只有你的学校！！！\n再往后，因为学校不给留校，把之前所有的规划都给打乱，好几天都在愁，暑假，都说是考研过程中，最关键的一个阶段，到底该怎么办？？怕暑假两个月之后，达不到自己所预期的效果，怕因为没有学习环境而学不下去，怕两个月之后，我还在继续怀疑我自己，怀疑自己或许根本不适合读书。在提出这些问题，自己心里也许是有答案的，至于答案具体是什么，得靠自己去探索。别人的回答，在某种程度上也只是想要得到内心的肯定罢了。\n既然知道自己想要的未来是光明的，一路走到黑，又何妨？？\n2、音乐复盘 音乐真的世界上最好的治愈。当无处发泄的时候，音乐便是最好的良药。\n《平凡之路》，是属于三月份的。大学三年下来，熬过了很多黑夜，经历了许多风风雨雨，自己的能力慢慢得到肯定之后，在工作和提升自己之间，经过内心的挣扎之后，还是选择了考研。似乎就好像，冥冥中这是我唯一要走的路。也就这样踏上了一条平凡的勇者之路。\n《一群无知少年的梦想》，四月份有幸在 2050 遇见了许多有梦想有朝气的年青人。带着自己的理想，有梦就去追。梦想在哪里呀？\n《稻香》，五月份的那一天会觉得吃的米也是不容易的。周杰伦的歌可谓是从小听到大的，每当听起这首歌的时候总有一种回到小时候的感觉。但是童年的纸飞机，再也不回来了，农村的稻草人也越来越少了。小时候的梦，早就记不清是什么了。回家吧，回到最初的美好。\n《拼个世界给自己》，六月份的新歌。大一的时候，听见僵尸的《网易云》，似乎找到了共鸣，慢慢他越来越火了，但他的歌还是依旧。黑夜中，看星空，飘着一个个的梦。在最无助的时候，能遇到一首走进内心的歌，是一次不可多得的机会。我都懂，我都懂，我都懂……\n 二、半学期复盘 ①数学 因为数二考得内容比较少，对于数学整体的把握要好得多，学习的知识点也要少一点，从而学习量也就好一点。因为高数开始的比较早，在三月份结束的时候，就差不多结束了，四五月份查缺补漏以及刷题，基础上几乎没有大的盲点。五月份的同时把线代也过了一遍。\n五月中下旬开始高数部分的强化，不得不说，武神是真的强。本以为自己对于高数的知识点已经掌握的炉火陈青，但是听过武神的强化之后，对于考试的整体更通透了。到六月结束，本预计能强化到定积分结束，可是事与愿违，定积分只是开了个头，（如果最后十天能够稳下心来，好好学，估计是能达到预期的）。\n由于基础部分开始的早，结束的早，问题也就来了，像多元函数微分学、二重积分之类的就有些遗忘。本来还打算六月份抽时间再过一遍的，结果也耽误了。愁呀！！\n线代，在五月份整体过完一遍之后，六月份对照着笔记把《线性代数辅导讲义》的内容过了一遍。满分是 10 分的话，刷《线代讲义》的时候给自己打 7 分吧，确实有很多地方缺点思路。而且有些知识点掌握的不牢固。\n暑期目标：\n 跟完强化课程 认真对待《讲义》以及《严选题》 完成以上两点，继续把《880》给整完  ②英语 英语基础部分的长难句和单词，怎么说呢，就属于边看题边巩固的过程，二者之间相互反馈。\n在过完 05 —— 15 年的真题之后，没有着急往下做。先是复盘了一遍，然后闲着无聊把唐迟的《阅读的逻辑》书和课程过了一遍。听课听起来挺舒服的，感觉做英语真题好像也就是那么一回事。但当自己实践的过程中，和方法论存在着不小的差距。\n最后一段时间，因为闲着无聊，把唐叔的《美国历史文化》给看了，下饭必备！！\n暑期目标：\n 回顾阅读方法论以及长难句分析 重做考研真题 背单词是每天必备的  ③专业课 如果说数学和英语有点迷惑，但好歹知道迷惑的点，至于专业课，有点找不着北的感觉，没有真题，考纲也只是罗列出一些简单的标题，虽然问了学长学姐，但心里还是有点不太踏实。\n而且之前看书的时候，大部分都只是在书上勾勾画画，没有做太多笔记，（还是因为找不到重点）。数据结构王道的课后习题过了百分之八十，总体难度是可以接手的。数据库，就很迷，感觉比数据结构要更细一点，从而就导致边边角角都要复习到位。\n暑期目标：\n 再过一遍专业课课本（做思维导图） 对于掌握不透的知识点单独拎出来 刷题？？  ④政治 呃，犹豫了很久，本来打算八月份开始的，但是由于学校不给留校，而我又懒得带那么多书，在纠结之后，九月份开始吧，希望还来得及。\n 三、关于感谢 这半年来，首先感谢我自己选择了这条路。人这一辈子，总要努力一次到两次，那一次是什么时候，我不知道，但是考研肯定算一次。不管能不能上岸，路途中的额外收获都是自己不可多得的一次经历。每当晚上从图书馆回寝室的路上，看着天上的星星，就会想自己也再一次成为了披星戴月的人。有时候反复问自己，我会不会坚持，我会不会坚持，我会不会坚持。会！！！\n这个月来，我慢慢（暂时）退出了开源社，也很感谢伙伴们的理解，因为我自己是个完美主义，每件事必须全部到位，这样就会很多事挂在心上，没办法全身心的投入学习。想了很久，最终还是决定暂时退出一段时间。很感谢居居，当时找到她的时候，对她说了，直接回复 OK，来接我这个烂摊子，说起来确实有点惭愧。各位小朋友，等我回来。\n再有就是，给予我帮助的各位学长学姐们，可能一次又一次的打扰到你们，问一些确实很无聊的问题，真的很感谢你们能抽出时间为我解答疑惑，也就不至于让我无从下手。也是你们，看见你们上岸之后，或者读研的经历，让我有了走下去的动力，我也想一年之后和你们一样！\n还有就是我的爸爸妈妈。像我爸妈虽然学历不太高，但却一直鼓励姐姐和我能够多学点知识，多读点书，以后不至于因为自己的知识面匮乏而感到不足。像我们老家周围的同龄人，几乎早早的都辍学打工，很多家里人都认为挣钱比学习重要，在这么个氛围中，也很感谢老王和老袁支持我继续读书。在学习方面，他俩就没说过一次“不”字，哈哈哈哈。。对了，还有大园，也在一直鼓励着我。\n最后，对坚持下来的自己说一声不容易。感谢去年怀着一腔热血想抗击疫情，为社会做点事的自己；感谢那个遇见开源，并勇于探索的自己；感谢那个因为疫情耽误，在家自己啃 JDK 源码的自己，感谢一直坚持下来的我。\n有时候，很多情况下，不经意做出的决定往往会带来意想不到的结果。也许这就是生活吧。加油啊，冲吧大政！\n怀感恩之心，行正义之事\n","description":"","tags":null,"title":"大政的考研 Blog004 —— 拼个世界给自己","uri":"/life/kaoyan004/"},{"categories":null,"content":"Blog003 —— 五月天，五月复盘 一、逆水行舟 1.1 疲倦期 好快啊！三个月过去了。五月份，没有三月时的不知所措，四月时的激情也慢慢消散，剩下的更多的是不知为啥的坚持。。。\n起初一直感觉自己的进度都是有条不紊的走在前面，整个复习进度也就比较佛系，在闲暇时间还去学学玩玩新的技术，因为比起正儿八经的学习，我更喜欢“瞎倒腾”着玩儿。但是慢慢一个月又一个月的时间过去了，紧迫感也就随之而来。如果说之前的一段时间是兴奋期的话，现在应该可以定义为疲倦期。整个人就有点学不下的感觉，但也不是学不下，而是不知道下一步该学些什么。\n把所有的课（包含专业课，除去政治）基础知识都过了一遍之后，忽然感觉就不想看书了，这种感觉很难受，忽然间就失去了目标。。。到现在写这篇博客的时候，整个人都是佛的。这样一折腾，和之前相比，每天的任务量也减轻了很多。停止是不可能停止的，现在每天能做到的也只能是在保持一定的题目量的过程中，查缺补漏吧。我怕自己一旦决定休息一天，就会在第二天想着：昨天没看书，今天天气那么热，明天再好好看书。说白了，给自己找退路有各种各样的借口，但是走下去的理由也只有那一个！！！\n我很讨厌去逼着自己做一些不情愿的事情，在自己有了一定的选择能力之后，能够去选择做某一件事的时候，都会给自己找到合适的理由，但我没想到的是这条路，这么难熬啊！！！就算不情愿也得走啊，因为还有许多事情没有做没有能力去实现呢。我也一定能够成为我想成为的那个人。一定！！！\n1.2 悟学习 在备考过程中，不仅仅是学习或者说是巩固知识的过程，让我获得比较多的应该是多给自己留几个问号？ 学这个有什么用？为什么要学这个知识？？这个点和之前学的或者之后要学的有什么关联？这种思考方式放在其它学科能用么？？为什么要……？？为什么……？为什……？？？\n这大概我这三个月来，在脑子里反复的最多的几句话。我们学习往往的不是一个一个零碎的知识点，而是一个整体，一个生态。就好比：在学高数的时候，牵涉到微分中值定理的证明题时，往往需要构造函数，这个时候除了用一些常见的套路之外，还可用后面章节的微分方程来构造；原函数、导数和积分之间的关系又可以建立起彼此之间的联系。还有在数据结构中会有求时间复杂度，就又可以和求极限作类比。所以从我自身学习的角度来看待备考过程的话：与其说是为了考试而去学知识，倒不如说是为了教会我们学习而学习。\n忽然想到，还没几天就要高考了，三年，多美的一个字眼，而三年前现在的我，或许还在犹豫，在焦虑。中学时候，各科老师都喜欢按照他们自己的经验来做题，从而稀里糊涂的就给出一套方法来，用心听课、认真学习的同学再课后刷题就能取得高分。但是很遗憾我不属于这类的人。但我也不会为此而感到惋惜，也正是因为这样，才有了现在的我。有些时候，一个人的状态或者说是机遇，很可能是 求而不得，往往不求而得。\n在这段学习过程中，比较让我头疼的应该就是线性代数。就是比较玄乎。第一次听永乐爷爷的课时，一个头有三个头大；咬着牙一遍过下来，对于里面很多的知识点有了大致的印象，具体要是让我像高数那样说出个一二三来，是做不到的。。拿到题目也能摸索着做出来，就是为什么这么做，还是不太懂，只能说我知道这样做就是对的。。。。呃，就是差了点火候，对于学习来说还点再悟，给我的整体感觉就是隔层纱，没有戳破。\n 二、五月复盘 五月天气逐渐热了起来，晚上可以听见青蛙叫，天上的星星也更亮了些。\n①数学 都说偶数年数学难，而高数更是难中之最？？所以在四月的基础上，进一步查缺补漏，把之前写得笔记、做的题目又拉出来过了一遍，对于各个章节的知识点，做到纲举目张，从而再统一串起来。\n到此，自我感觉良好，于是去做《李林880》，基础篇还是能手撕的，当做的综合篇的时候，直呼好家伙，题目有点意思哈，再啃啃，我自闭了了了。。。对不起，是我不配了，我迷了，不应该，我咋那么菜呢？？？我高数复习了个 der啊？？带着这种心情，我又低下头去刷《1800》了，也意识到是时候进入强化阶段了。\n然后就线代，由于四月份就已经前四章过了一遍，但是总体感觉是模模糊糊的，就又重新过了一遍，学习还得要做到温故知新的嘛！带着疑惑去学习，确实要比一开始好好得多，但是在完整学完之后，就像前面所提到的，还是很迷的。。\n我也说不清为啥，题目会做，很多定理却不知所云。如果再让我安排一次的话，我会选择把线代的复习进度再往后放一放，不开始那么早，直接就基础过完开始强化。可能吧。\n在复习线代的时候，对于高数花的时间自然而然就少了，从而就导致一些题目做起来有些生疏。\n②英语 单词！！！单词！！！单词！！！\n由于使用的是墨墨背单词，每天 220+，看了下每天背单词的总时长大概在 100 分钟左右。再加上中间有可能做点其它的时间，综合下来，每天背单词大约需要两个小时左右的时间。感觉有点多了吧！！！但好在这些时间没有白费，其最之间的体现就是在做真题上。\n阅读进度：每天一篇阅读：看题干、做题目、翻译、再看题目、对答案，最后找原因。一天的时间在一个小时十分钟到一个半小时之间，这个还是可以接受的。做完一张试卷之后，复盘，做总结下一张。然后就刷到了 2013 年了。在做阅读的时候，就好像把自己又带回了之前的那个年代，也算是一种额外的收获吧。\n每天干饭的时候，看了唐叔的《美国背景文化》，确实挺下饭的，哈哈哈哈！\n③专业课 上个月立的 flag，也算做到了，最起码勾勾画画把书本过了一遍。但是吧，在看完之后，我就感觉看得有点太早了，以后肯定会忘。。。。。。（不愧是我，23333）\n再来吐槽一下数据结构，问了下师哥师姐大部分都在夸王道的书好，好吗？？好？？吗？？？或许从应付考试来说还不错，但是从剖析数据结构来说，无论是知识点的讲解，还是给的代码，从我来看都是不合格的。就是有点浅显，在看王道的书的时候，我还把之前《大话数据结构》和《算法4》，无论是从通俗易懂还是硬核知识来说，都被吊打，而且吧，课后习题给的方法，先抛出代码质量来说，有时候边界值都没考虑到。。。。 吐槽结束。\n数据库，根据考纲把知识点过了一遍，也列了个思维导图。在看关系演算的时候，我又迷了。。。其余的还行，整体上保持在预期之内。后期还得花时间啊！！！\n 三、低欲望 其实说实在的，最近才发现自己是属于低欲望却有着野心的那类人。这就导致很多人，拼命去奋斗、去争取的东西，比如成绩排名、个人荣誉、证书啊之类的，我往往都是不屑一顾的。就是感觉很没必要这样做的吧，或者说是很搞笑。就这样，慢慢的，慢慢的，逐渐对周围很多的事情失去了兴趣，生活也就过得越来越简单。也可能是因为我比较懒吧，懒到所有的事情，在无关紧要的情况下，能离远一点就远一点。就像前面所说的，我找不到去做这类事情的理由，对我来说就是在浪费时间。\n再接着就是有时候甚至会对生活失去兴趣，读书学习到底是为了什么呢？？追求学历文凭，只是为了找一份工作，然后结婚生子、养家糊口？？？我对我现在所坚持的事情产生了怀疑，就好比感觉自己所做的努力只是为了像一个普通人一样，仅仅是为了活着而已！！也许读书也就是为了让我们能够变成一个普通人，但是我总感觉，作为当代青年，一个知识分子，能够做的事情有很多，人应该是有理想。自幼读书开始，就想着上了大学就自由了，但后面的挑战也是接踵而至，反观现在无聊的时候，玩玩悠悠球，睡前听歌也只是消磨时光，每天过得生活就像是一个带着情感的机器人。有的时候想要逃离又不敢逃，怕一退缩，迎面而来的是各种咒骂与唾弃。\n人活着的意义是什么呢？？在大部分情况下，我们的明天和今天并没有什么太大的区别。活在当下，也许是最优解。但那是饿了找东西吃，困了就睡的的动物才会做的事情，人之所以为人，那是因为人会幻想未来。那么我想追求的是什么呢？？我的野心又想体现在哪呢？？技术与文明 ，这或许也是我喜欢开源文化、黑客文化的原因之一，只有看过更广阔的对的世界，接触到更前沿的技术，才会感叹自己的渺小与无知，才会明白自己还有很长的路要走，还有梦和理想值得自己为之去努力，去流汗，去坚持，并心甘情愿的为之而受尽煎熬！！！\n最后想用当时曾国藩的一句话送给走在路上的朋友们：千秋邈矣独留我，百战归来再读书 ！！！\n加油！！！\n","description":"","tags":null,"title":"大政的考研 Blog003 —— 五月天","uri":"/life/kaoyan003/"},{"categories":null,"content":"Blog002 —— 阳光正好，四月复盘 一、要命！！！ 经过三月份的折磨，似乎更能明白与花时间熬学习相比，调整好自己，适当的减压，注重学习效率是更重要的。于是我就做减法，做到了什么程度呢？？貌似减得有点多，就导致有点飘，完全有点静不下心来，踏踏实实地学习！！！\n要命！！！\n其实说实话，如果这个月抛去学习不谈，过得还是挺开心的。就先简单聊点这个月我到底干了啥吧。\n1.1 浪潮之巅 看完了吴军博士写得《浪潮之巅》，（都说考研期间不要看课外书，但是考研的课本真的太无聊了了了了。。。。）之前或许是自己，或许是周围的同学总能听到些抱怨：我们出生晚了，最好的时代已经离我们而去了 。但是在看《浪潮之巅》的时候，给我更多的感受是我们现在的时代正是处于互联网的“浪潮之巅”，云原生、5G 时代的到来，将会对于过去的网络再次产生翻天覆地的改变。当下的我们要做的是不怨天尤人，而是把握自己，逆风奔跑，向阳而生！\n生在这个时代最大的幸运就是可以看到商业和科学技术完美结合不断的改变这个世界的面貌，不断的改变我们的生活方式。 吴军博士不断的说能赶上科技发展的浪潮便不枉此生。因此生活在这个时代的我们是幸运的，因为年青，就有资本去学习自己想学的，去追求自己所想追求的。\n1.2 参与 DolphinScheduler 在三月的复盘中有提到，开始转型学习大数据，于是在一次偶然的机会接触到 DS 这个项目。有人说：万物始于 Hello World，但对于我来说参与开源的第一步应该是从 Markdown 开始。首先文档类的任务，与代码层面相比要简单的多，不至于像代码那样牵一发而动全身，而且提交 PR 之后，通过检测的机会也要大的多，可以说门槛是要小一点的。于是参与 DS 的第一份 PR 就是写文档，哈哈哈哈。当自己的 PR 被 merge 的时候，那份满足感是任何事情都替代不了的，特别还是参与 Apache 的顶级项目。\n感受到社区的友好之后，按照我的习惯肯定要撸源码玩玩，徒手撕源码才是真男人嘛！在阅读源码的时候，看看测试案例对于理解和使用来说都是不可缺少的。当时看见了有些类的测试案例还没写，就尝试自己写了一份，结果是显而易见的，PR 没通过检测，然后就导致周末去杭州得背电脑了。。。。。起初最初的问题是代码规范，这个还是比较好改的（与后面遇见的问题相比确实啥都不算），但问题是解决了一个问题，随之而来的是下一个问题，虽然社区的导师给予帮助，但还是很头大。在遇见问题的过程中，最重要的是学会自己动手去解决问题，这个时候就要吹爆 StackOverflow ，以及慢慢体验到 issue 和邮件列表的好处，因为可以从之前的记录中找到类似的问题，解决起来就要好得多。最后看见 LGTM 的时候，感觉一切都值了，所以说还是热爱开源的，还是想写代码的。\n1.3 2050 如果你问我年青人做什么最酷？？ 那一定是参与 2050 大会（也就是因为这个，决定去参加的时候，每天肾上腺激素分泌过多，肯定静不下心学习）。三天下来，有遗憾，有欢笑，也有收获。\n周五到杭州的时候，因为有点晚，遗憾的是错过了“开源人团聚”，但是从博悟馆出来的时候，看见了王坚博士，这何尝不是一种收获呢。这也是我的一种态度：求而不得，往往不求而得。起初见到博士的时候，是先听见他的声音（*之前了解到2050是王坚博士以个人名义发起的时候，就临时补课看了很多博士的视频~~*），这声音好熟悉，抬头一看，我天呐！！！那穿格子衫的可不就是博士嘛！！！这也是我第一次在现实生活中，见到互联网中大神级别的人物。但说到底，还是有点亏的吧。。。。\n第二天，比较开心的应该是遇见了道哥——吴翰清！！！对，没错，就是段子中传说黑进阿里的大神。只不过感觉有点可惜的是道哥再回到阿里之后，不再做开发，而是产品经理。在听完分享之后，不得不承认，到阅历或者说是知识体系到达一定高度之后，看世界的角度真的会发生改变。我们还在为了生活而感到焦虑的时候，有的人都已经在尝试模拟甚至创造生活。然后还有比较开心的就是看见了赵生宇学长，上次见面还是 2020 开源年会，一别就是几个月。当和学长谈到开源的时候，眼里是有光的。能够更深入的探讨一些问题，也是弥补了昨天的遗憾吧。\n五点半的闹钟，早起，六公里的约定 —— 逐日晨跑。还有什么比这更酷的事情吗？？ 虽然说一开始参与晨跑是为了获得 T 恤，但当一路坚持下来的时候，再想想还有什么是自己不敢挑战的呢？路途中，拿起奠基石，为 2050 添砖加瓦；还看见了一路一直坚持下来的小朋友，他们都未停止脚步，二十出头的我们，不更应该起到带头作用嚒。当回到终点，收到奖牌的时候，感觉这一切都足了！\n快乐的时光总是短暂的，奋斗的路还很长，杭州这座城市去的次数，虽然不是很多，但却是去一次爱一次。（回到合肥之后的感觉，就好比用惯了 IDEA 回到了 Eclipse。。。。）\n 四月复盘 说真的，四月给我的感受就好像是什么都没做。。。。\n①数学 四月初，把三月份高数的盲点又花了一周左右的时间整理了一下。这应该可说是零死角了吧。哈哈哈。原本准备这个月把线性代数看完，但是实现往往是高估了我自己的能力和自觉性。\n线代怎么说呢，给我的感觉不像是高数那样，学完一个章节，就能做对应的题目，它更多是对于整个知识体系的融会贯通。再加上李永乐爷爷年级大了，听起来确实不太清楚，还不知汤汤的南京话有个性呢。。。。然后就磕磕巴巴把线代的前四章啃完了。\n高数方面开始二刷 1800，不得不说确实有必要二刷，第一遍做的时候，可能更偏向于基础知识的应用。到了二刷，在之前的基础上再加上一定的技巧，不管是做题速度、正确率方面，还是对于题目对的理解方面，都有了质的飞越。再想起之前还在为选哪本习题册而感到困惑的时候，现在感觉更多的是市场上主流的习题册都各有优缺点，认真啃透一本，再加以补充，我相信问题应该不大。\n②英语 英语重要的就是单词不能停！！说实话，背单词是真的那个痛苦啊，苦不堪言中，还有无聊。。。但哪又能咋办，硬着头皮走下去。长难句方面，看了唐叔的（主要是因为时间较短，一开始是当段子看的）发现，按他那么来玩确实有点意思，就认真又听了一遍，结合真题来，走向正轨。\n搜英语的经验贴，都说上真题，于是这个月把从 2005~2009 所有真题中的阅读精翻了一遍，做前两套试卷的时候，还有比较痛苦的，积累的越多，就稍微好点，每做完一套就复盘一套，会发现从一开始满是红笔的标注慢慢过渡到只标注难点的句子和不认识的单词，红色越少，进步越多，哈哈哈！五月再接再厉！！！\n③专业课 emmmmmmm。。。。从五月开始一定好好准备专业课。我感觉我把准备专业的时间，都用来学习新的知识去了，惭愧！！！\n数据结构，我感觉考得也不是很难嘛、、、、\n 三、谈谈愧疚感 人在不努力或者说觉得自己还不够努力的时候，总会感觉到自己有点愧疚感，甚至是罪恶感。这到底是为什么呢？？每天为了努力而去努力，不是我想要的，也不是我所追求的。带着这样的情绪强迫自己去学习、去工作，是比较难受的。\n明知道这种状态不对、这种状态不好，为何不能及时调整自己呢？？可能是因为贪心太大，我们追求的有太多太多了，这个世界也是太丰富多彩了，以至于给人一种错觉，我不努力，就没资格去享受这个世界所给的一切，于是就陷入了这种状态。\n接受自己的不足，接受自己的不完美。对的，在继续往下走之前，应该先想想自己的能力，所处的环境以及自身的状态等客观因素，因为这些种种都是会影响一个人的主观感受。在图书馆中经常能看见有些同学早上七点之前就在图书馆背单词，晚上也一直到十点多。从我的角度来说，我这种状态我做不到，就算做到了也坚持不了多久，甚至可能会把自己的身体搞垮。\n记得之前问过自己一个问题：是逼自己一把，还是放自己一马？ 一开始想的是逼自己一把，因为一直在给自己找更高的任务，说白了就是和自己杠到底。但更多的时候却发现，具体在执行的时候反而变得更佛，更像是在逼自己一把的同时，在有限的空间给自己偷个懒。\n有的时候接受自己的不足，往往不是为了向生活妥协，反而是为了跑得更远，跳得更高！！就像开头所说的这个月如果不谈学习，我们还是好朋友。\n","description":"","tags":null,"title":"大政的考研 Blog002 —— 阳光正好","uri":"/life/kaoyan002/"},{"categories":null,"content":"Blog001——在路上,三月复盘 一、浮躁 我们生活在一个贩卖焦虑的时代，“小镇做题家”、“读书无用论”、“内卷”等等言论充斥这我们的生活。而这个社会中也往往有些人喜欢制造焦虑，什么你已经被你的同龄人所抛弃，你已经被你所处的社会所抛弃等等。我们时常会感叹道：我才二十刚出头，为何活着的这么累啊！！\n是啊，我们为何会这样想呢？？遵循自己的内心，按照自己喜欢的方式走下去不好嘛？？但是真的好难，在这个信息爆炸的时代，几乎无一人能幸免，一方面在享受科技带给我们的便利，另一方面却又被信息所左右，这个时代的我们太浮躁，心也很难静下来，也就很难能坐得住冷板凳，一天能做到、两天能做到那不叫坚持，真正的坚持往往是带着一种煎熬！！\n考研路上，怎一个“卷”字了得！！看看 2021 的考研成绩，出现四百分似乎一点都不觉得稀奇，往年比较好考的院校，也都成了热门，计算机专业更是把内卷体现到了极致。考研就是一座黑暗森林，每个考研人都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都必须小心翼翼：他必须小心，因为林中到处都有与他一样潜行的考研人，如果他发现了别的考研人，能做的只有一件事：开枪消灭之。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己目前选择的稍微好考的院校都将很快被无数考研人群起冲之，这就是考研的常态？？\n 二、心情状态 三月份回到学校，考研的路途也算是真正的拉开序幕，一开始的时候，充满干劲，却也一脸茫然，找不到方向，不知该如何是好。然后慢慢的找到适合自己的方法，说实话还是挺享受这种过程的，苦吗累吗？？有点吧，但是真的很舒服，每天的付出的都能看得见，能得到正向的反馈就很舒服。而且每天晚上带着一点点疲倦感回到宿舍之后，简单洗漱之后，还有点自己的时间，写写代码，看看杂书，练练球，这也是我当时所理想的状态，我原以为能一直这样下去，结果人绷紧了，还是会出问题的\n在这个月快结束的时候，突然间，整个人不知怎么的就不好了。。。。可能是累了，也可能是倦了。当时几乎是把高数基础又重新过了一遍，汤汤 1800 的基础部分 也做了百分之八十左右，专业课的书本也过了一遍，然后突然间就失去了目标，书不想看，题也只能是机械式的刷，当感觉到的时候，也就意识到自己的状态需要调整。这也是第一次出现心情上的波动，因为离目标太远，不知道到底能否做得到！！怕付出到最后不是自己想要的结果！！！\n忽然想起了高三激励自己的一句话：我不去想能否成功，既然选择了远方便只能风雨兼程！ 现在回过头来看，不免是有点中二的，但也就是这股劲，push 着一步一步走啊，走啊。那到底什么是成功呢？？考上大学算是成功吧，也许在当时看来是的，从宏观角度上看，我们往往把成功定义的太狭隘、太片面。所谓的成功，也许是就是一道坎，跨过去一个，下一个更高。简单来说，慢慢走吧，也许漫无目的，也许有目标，但是请别停下！！\n 三、三月份学习复盘 ①数学 因为之前数学书本已经过了一遍，在看了一些经验贴之后，意识到基础的重要性，所以又花了半个月的时间，结合汤汤的复习全书、基础三十讲以及课本，整理了一份高数基础笔记，把其中的定理能证的都证明了一遍，一些经典例题也都有添加，当看见打印出来的时候，心里还是有点小激动的，哈哈哈。\n因为之前《基础 30 讲》降价，就入手了一本，总结完基础之后，就开始配合宇哥的课程，开始刷 1800。从我的个人角度来说，宇哥的课如果基础不牢固的话，听起来真的有点飘，全程很难 get 到他想表达的点，而且笔记还不太好记。如果基础还行，跟下来，做题技巧确实能学到不少，然后就去 1800 虐菜。再简单说说 1800，题量是真的大！！！ 虽然题目不是很难，还记得当时第一次翻开习题册，第一面极限，磕磕巴巴只能做五六题，从课本过渡到考研的基础阶段，还是要磨的，还好过渡的比较平滑，到现在二刷前面的基础题，极限也几乎可以做到口算，提高篇的内容暂且不谈，因为还没做。\n如果说高数部分哪里还有盲点的话，大概是 多元微分学 以及 常微分方程部分，因为是最后复习的部分，花的时间没有前几章那么多，所以还得抽时间再看看，知识体系不能出现漏洞嘛。\n②英语 英语咋说呢，有一种不太踏实的感觉，起初可能我高估英语的难度了，觉得考研真题就一定很难，不看语法长难句就一定读不懂文章，带着这种想法，看了刘晓燕的长难句课程，再看真题的感受，大概是我好像不看长难句的课程也能把文章的大意读懂，翻译句子我还是喜欢按照自己的语感来，也不怎么分析句子成分，做题效果比自己当时想的要好。但是吧，我不能说长难句的课程就没必要看，因为自己是看了之后才做题目的，虽然这课程真的有点鸡肋的感觉，不看总觉得少了点什么，不太放心，看的话又有点浪费时间。。。。\n单词方面，尝试了一下“作死”的行为，可能是有点急功近利，就开始肝《十天搞定考研词汇》，到了第五天第六天的时候，整个人都快被单词折磨疯了，哦对，这或许也是我考研状态出现波动的原因吧。真的很折磨人，仅仅是背单词几乎占用了一天大部分时间，感觉有点不值得吧。。。。还好肝完了，单词不能说全到熟稔于心吧，但是看真题是够的了。所以我感觉单词还是很重要的吧。\n真题的话，目前只做了阅读部分，进度为 一天一篇：做题、翻译、分析题目。不知是我飘了，还是做的题目有点老（从 05 年开始做的），感觉考研阅读的难度似乎和六级差不多？？？？在有了上面的基础，大约是从 18 号开始正式做真题的，比预期要好！\n③专业课 如果有最不受程序员欢迎的编程语言排行榜的话，我一定给 C\\C++ 投上一票，甚至在开始学 C++ 的时候，我就在想为啥考研还指定编程语言啊，23333~ 大一初学编程的时候，就是因为 C语言 给我一种我不配写代码的感觉，玄学指针！！！当时被支配的恐惧，现在也是时候和它正面刚了，再逃下去就真的没路咯。。。\n数据结构方面，不算太难吧？？ （人言否。。）也可能是之前看过 JDK 源码以及经常刷题的缘故吧，只不过是换了一种语言实现罢了。所以上手还是比较快的。当让静下心来学 C++ 的时候，还是有点收获的，也让我感觉到为何 C++ 更适合刷题。\n但是中国的应试给我的感觉就是，一样东西变成了考试的内容，与实际使用来说，就变味了。。。。\n 四、谈谈备考的生活 整体的感觉是疲惫且充实，启动备考的一个月也在忙碌中结束了。在这期间，对于编程方面做出了一个决定，从后端跨到大数据，目前抽空学完了 Hadoop。问我原因的话，大概是寒假的时候玩了玩 Flink，真的太有意思了，并且看了一些前沿的技术框架，想想还是转吧，哈哈。\n因为当时心情的波动，有想过好久没买悠悠球了，逛了一圈闲鱼，没有太想收的，就把准备买球的钱，买书了，现在我想说，亲 咱能退款不？？。。。。。 有一点点后悔吧。但是多看点书还是好的。\n开源组织这边，也转移到了以开源社为主，毕竟当了组长，还是要干活的呀，带头作用要有。也从一开始几乎把任务都揽到一个人头人，到慢慢学会分配出去，再到招募新的小朋友加入进来，再想想去年自己似乎也是在这个时候接触到开源的吧，真好！\n有人说，你不是准备考研吗，怎么天天还做这些，不怕耽误你自己么？？ ，先说句谢谢您哈！可是我想说，如果把这十个月左右的时间全部用在考研上，就算到时候上岸了，我会开心吗，也许吧。但我更想在这有限的时间里做点自己喜欢的事情，不做一个只读“死书”的考研狗。\n 五、写在之后 之前一直在想，要不要把自己的考研历程给录下来，但是又嫌后期处理麻烦，索性就用博客来记录吧。而且在写之前，还在想，如果到时候没有上岸，是不是太丢人了吧，是啊，那可真拉胯，但我还是想把这一段时间用文字给记录下啦。\n考研的基础阶段，就好比是编程语言的基本语法，算作基本功；一些常用的结论、定理 有点想数据结构和设计模式，可以定义为内功了吧；再看看做题技巧，对应的是常用的框架？？也就是某种定义上的武功秘籍了吧，哈哈。所以说学习是有相通性的，作为一名学生，不能为了学习而学习，而是要学会学习而学习。\n与学习编程相比，考研学的内容可能真的不算太多，但是考研是有一个时间界限的，比的是在规定时间内，谁玩得好。这就很烦。在准备考研之前，我还在问我自己，到底为什么要考研，现在的答案是 我有我所想追求的，现在的身份、圈子，无法得到我想要的状态 ，所以要走下去！\n最后，从我个人的角度来说，还是想读书的，但我并不喜欢学校要求实践、学分、发论文的这种教育，我还没到 21 岁，我还有时间按照我所想的去“浪费”！\n","description":"","tags":null,"title":"大政的考研 Blog001 —— 在路上","uri":"/life/kaoyan001/"},{"categories":null,"content":"图——DFS和BFS 一、前言 在上一篇博客中，我们了解了有关图的基本概念，以及如何去创建图。与之前一对一的线性结构或者一对多的树状结构相比，图的遍历无疑是增加了些许难度。所以我们本节来说一下图的两种遍历方式，深度优先遍历和广度优先遍历。\n 二、基本知识 1、深度优先遍历 ①深度优先遍历介绍 它的思想: 假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n显然，深度优先搜索是一个递归的过程。\n②深度优先遍历图解 无向图的深度优先搜索\n下面以\"无向图\"为例，来对深度优先搜索进行演示。\n对上面的图G1进行深度优先遍历，从顶点A开始。\n第1步: 访问A。\n第2步: 访问(A的邻接点)C。 在第1步访问A之后，接下来应该访问的是A的邻接点，即\"C,D,F\"中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在\"D和F\"的前面，因此，先访问C。\n第3步: 访问(C的邻接点)B。 在第2步访问C之后，接下来应该访问C的邻接点，即\"B和D\"中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。\n第4步: 访问(C的邻接点)D。 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。\n第5步: 访问(A的邻接点)F。 前面已经访问了A，并且访问完了\"A的邻接点B的所有邻接点(包括递归的邻接点在内)\"；因此，此时返回到访问A的另一个邻接点F。\n第6步: 访问(F的邻接点)G。\n第7步: 访问(G的邻接点)E。\n因此访问顺序是: A -\u003e C -\u003e B -\u003e D -\u003e F -\u003e G -\u003e E\n有向图的深度优先遍历\n下面以\"有向图\"为例，来对深度优先搜索进行演示。\n对上面的图G2进行深度优先遍历，从顶点A开始。\n第1步: 访问A。\n第2步: 访问B。 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。\n第3步: 访问C。 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。\n第4步: 访问E。 接下来访问C的出边的另一个顶点，即顶点E。\n第5步: 访问D。 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。\n第6步: 访问F。 接下应该回溯\"访问A的出边的另一个顶点F\"。\n第7步: 访问G。\n因此访问顺序是: A -\u003e B -\u003e C -\u003e E -\u003e D -\u003e F -\u003e G\n2、广度优先遍历 ①广度优先搜索介绍 广度优先搜索算法(Breadth First Search)，又称为\"宽度优先搜索\"或\"横向优先搜索\"，简称BFS。\n它的思想是: 从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。\n②广度优先搜索图解 无向图的广度优先遍历\n下面以\"无向图\"为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。\n第1步: 访问A。\n第2步: 依次访问C,D,F。 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在\"D和F\"的前面，因此，先访问C。再访问完C之后，再依次访问D,F。\n第3步: 依次访问B,G。 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。\n第4步: 访问E。 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。\n因此访问顺序是: A -\u003e C -\u003e D -\u003e F -\u003e B -\u003e G -\u003e E\n 三、算法实现 1、相关基本方法 ①返回结点对应的数据 还记得我们定义 vertexList 的时候，使用的是ArrayList类型么，所以直接使用其中的get() 方法即可。\n代码实现如下：\n1 2 3 4  // 返回结点 i（下标）对应的数据 0-\u003e\"A\" 1-\u003e\"B\" 2-\u003e\"C\"  public String getValueByIndex(int i) { return vertexList.get(i); }   ②得到第一个邻接结点的下标 我们在遍历的过程中，需要找到离当前结点最近的一个结点下标。并且判断其是否存在，如果存在就返回对应的下标，否则返回-1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /** * 得到第一个邻接结点的下标 * * @param index 当前结点的索引 * @return 如果存在就返回对应的下标，否则返回-1 */ public int getFirstNeighbor(int index) { for (int j = 0; j \u003c vertexList.size(); j++) { if (edges[index][j] \u003e 0) { return j; } } return -1; }   ③获取下一个邻接结点 根据前一个结点的下标来获取下一个邻接结点。使用for循环来遍历vertexList这个二维数组，如果当前结点的下一个结点的下标大于0，则表示找到。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 根绝前一个邻接结点的下标来获取下一个邻接结点  public int getNextNeighbor(int v1, int v2) { for (int j = v2 + 1; j \u003c vertexList.size(); j++) { if (edges[v1][j] \u003e 0) { return j; } } return -1; }   2、深度优先遍历算法 ①深度优先遍历基本思想 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问结点的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。\n我们以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问，显然，深度优先搜索是一个递归的过程。\n②深度优先遍历算法步骤 1）访问初始结点v,并标记结点v为已访问；\n2）查找结点v的第一个邻接结点w；\n3）若w存在，则继续执行4），如果w不存在，则返回第1步，将从v的下一个结点继续；\n4）若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）；\n5）查找结点v的w邻接结点的下一个邻接结点，转到步骤3。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  /** * 深度优先遍历算法 * * @param isVisited 用于标记结点是否被访问 * @param i 第一次就是0 */ private void dfs(boolean[] isVisited, int i) { // 首先访问该结点  System.out.print(getValueByIndex(i) + \"-\u003e\"); // 将结点设置为已经访问  isVisited[i] = true; // 得到下一个邻接结点的坐标  int w = getFirstNeighbor(i); while (w != -1) { if (!isVisited[w]) { dfs(isVisited, w); } // 如果w结点已经被访问过  w = getNextNeighbor(i, w); } } // 重载dfs()，遍历所有的结点，并进行dfs  public void dfs() { isVisited = new boolean[vertexList.size()]; // 遍历所有的结点，并进行dfs【回溯】  for (int i = 0; i \u003c getNumOfVertex(); i++) { if (!isVisited[i]) { dfs(isVisited, i); } } }   3、广度优先遍历 ①广度优先遍历基本思想 图的广度优先搜索，类似于分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点顺序，以便这个顺序来访问这些结点的邻接结点。\n②广度优先遍历算法步骤 1）访问初始结点v并标记结点v为已访问；\n2）结点v入队列；\n3）当队列非空时，继续执行，否则算法结束；\n4）出队列，取得队列头结点u；\n5）查找结点u的第一个邻接结点w；\n6）若结点u的邻接结点w不存在，则转到步骤3，否则循环以下三个步骤：\n6.1 若结点w尚未被访问，则访问结点w并标记为已访问；\n6.2 结点w入队列；\n6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // 对一个结点进行广度优先遍历的方法  private void bfs(boolean[] isVisited, int i) { int u;// 表示队列的头结点对应的下标  int w;// 邻接结点w  // 队列，用于记录结点的访问顺序  LinkedList\u003cInteger\u003e queue = new LinkedList\u003cInteger\u003e(); // 访问结点，输出结点信息  System.out.print(getValueByIndex(i) + \"-\u003e\"); // 标记为已访问  isVisited[i] = true; // 将结点加入到队列  queue.addLast(i); while (!queue.isEmpty()) { // 取出队列头结点的下标  u = (Integer) queue.removeFirst(); // 得到第一个邻接结点的下标w  w = getFirstNeighbor(u); while (w != -1) { // 是否访问过  if (!isVisited[w]) { System.out.print(getValueByIndex(w) + \"-\u003e\"); // 标记为已经访问  isVisited[w] = true; // 入队  queue.addLast(w); } // 以u为前序点，为w后面的下一个邻接点  w = getNextNeighbor(u, w); } } } // 重载bfs，遍历所有的结点，都进行广度优先遍历  public void bfs() { isVisited = new boolean[vertexList.size()]; for (int i = 0; i \u003c getNumOfVertex(); i++) { if (!isVisited[i]) { bfs(isVisited, i); } } }    四、结束语 到此为止，我想说数据结构系列博客应该是完结咯。至于最小生成树之类的问题，我感觉属于算法类来说更为合适，停停停！！！ 不抛新坑了。后序可能会对这个之前的博客进行一些简单的优化，更好地处理细节相关的问题。\n源码地址 ——\u003e 图——BFS和DFS\n","description":"","tags":null,"title":"图——DFS和BFS","uri":"/tech/datastructes/graph02/"},{"categories":null,"content":"图 在前面我们了解了线性表和树的相关知识，知道了线性表局限于一个直接前驱和一个直接后继的关系，而树也只能有一个直接前驱也就是父结点。当我们需要表示多多对多的关系时，这里我们就用到了图。\n一、前言 1、图的基本概念 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。\n图 1 图存储结构示意图\n图 1 所示为存储 V1、V2、V3、V4 的图结构，从图中可以清楚的看出数据之间具有的\"多对多\"关系。例如，V1 与 V4 和 V2 建立着联系，V4 与 V1 和 V3 建立着联系，以此类推。与链表不同，图中存储的各个数据元素被称为顶点（而不是节点）。拿图 1 来说，该图中含有 4 个顶点，分别为顶点 V1、V2、V3 和 V4。图存储结构中，习惯上用 Vi 表示图中的顶点，且所有顶点构成的集合通常用 V 表示，如图 1 中顶点的集合为 V={V1,V2,V3,V4}。注意，图 1 中的图仅是图存储结构的其中一种，数据之间 \"多对多\" 的关系还可能用如图 2 所示的图结构表示：\n图 2 有向图示意图\n可以看到，各个顶点之间的关系并不是\"双向\"的。比如，V4 只与 V1 存在联系（从 V4 可直接找到 V1），而与 V3 没有直接联系；同样，V3 只与 V4 存在联系（从 V3 可直接找到 V4），而与 V1 没有直接联系，以此类推。\n因此，图存储结构可细分两种表现类型，分别为无向图（图 1）和有向图（图 2）。\n2、图的基本常识 ①弧头和弧尾 有向图中，无箭头一端的顶点通常被称为\"初始点\"或\"弧尾\"，箭头直线的顶点被称为\"终端点\"或\"弧头\"。\n②入度和出度 对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V 的出度（OutDegree，记为OD(V)）。拿图 2 中的顶点 V1来说，该顶点的入度为 1，出度为 2（该顶点的度为 3）。\n④(V1,V2) 和 \u003cV1,V2\u003e 的区别 无向图中描述两顶点（V1 和 V2）之间的关系可以用 (V1,V2) 来表示，而有向图中描述从 V1 到 V2 的\"单向\"关系用 \u003cV1,V2\u003e 来表示。\n由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2) 还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，\u003cV1,V2\u003e 也可用来表示有向图中从 V1 到 V2 带方向的线，又称为弧。\n⑤集合 VR 的含义 并且，图中习惯用 VR 表示图中所有顶点之间关系的集合。例如，图 1 中无向图的集合 VR={(v1,v2),(v1,v4),(v1,v3),(v3,v4)}，图 2 中有向图的集合 VR={\u003cv1,v2\u003e,\u003cv1,v3\u003e,\u003cv3,v4\u003e,\u003cv4,v1\u003e}。\n⑥路径和回路 无论是无向图还是有向图，从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为\"回路\"（或\"环\"）。\n并且，若路径中各顶点都不重复，此路径又被称为\"简单路径\"；同样，若回路中的顶点互不重复，此回路被称为\"简单回路\"（或简单环）。\n拿图 1 来说，从 V1 存在一条路径还可以回到 V1，此路径为 {V1,V3,V4,V1}，这是一个回路（环），而且还是一个简单回路（简单环）。\n在有向图中，每条路径或回路都是有方向的。\n⑦权和网的含义 在某些实际场景中，图中的每条边（或弧）会赋予一个实数来表示一定的含义，这种与边（或弧）相匹配的实数被称为\"权\"，而带权的图通常称为网。如图 3 所示，就是一个网结构：\n) 图 3 带权的图存储结构\n子图：指的是由图中一部分顶点和边构成的图，称为原图的子图。\n3、图存储结构的分类 根据不同的特征，图又可分为完全图，连通图、稀疏图和稠密图：\n  完全图：若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为\n完全图\n（如图 4a)）。同时，满足此条件的有向图则称为\n有向完全图\n（图 4b)）。\n图 4 完全图示意图\n具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。\n  稀疏图和稠密图：这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为\"稀疏图\"；反之，则称此图为\"稠密图\"。\n稀疏和稠密的判断条件是：e\u003cnlogn，其中 e 表示图中边（或弧）的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。\n  4、图的表示方式 图的表示方式有两种：二维数组表示（邻接矩阵），链表表示（邻接表）。\n①邻接矩阵 邻接矩阵是表示图中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是row和col表示的是1……n个点。\n②邻接表 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在的，从而会造成空间上的一定损失；邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成。\n 二、算法实现 这里我们使用二维数组来创建一个简单的图。以及相关的实现方法，留着下节使用。\n1、定义基本变量 没啥好说的，直接看代码，与以前一样，使用构造器，哈哈哈哈。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Graph { private ArrayList\u003cString\u003e vertexList;// 存储顶点集合  private int[][] edges;// 存储图对应的邻接矩阵  private int numOfEdges;// 表示边的数目  // 构造器  public Graph(int n) { // 初始化矩阵和vertexList  edges = new int[n][n]; vertexList = new ArrayList\u003cString\u003e(n); numOfEdges = 0; } }   2、常见方法 ①返回顶点的个数 因为我们使用的是ArrayList定义的顶点，所以可以直接用于其中的 size()，来表示顶点的个数即可。\n代码实现如下：\n1 2 3  public int getNumOfVertex() { return vertexList.size(); }   ②返回边的数目 这个就更简单的了，直接一个return完事。\n代码实现如下：\n1 2 3  public int getNumOfEdges() { return numOfEdges; }   ③返回边的权值 每个顶点是由两条边 v1 和 v2共同组成的，所以直接对应的边数组元素即可。\n代码实现如下：\n1 2 3  public int getWeight(int v1, int v2) { return edges[v1][v2]; }   ④显示对应的矩阵 使用for…each循环遍历edges数组即可。\n代码实现如下：\n1 2 3 4 5  public void showGraph() { for (int[] edge : edges) { System.out.println(Arrays.toString(edge)); } }   3、构造邻接矩阵 这个就是重点咯！！！\n首先我们要明白一个小学一年级就掌握了的基本常识，那就是 任意一个线段，有两个端点。别小瞧这个哈，我们想想图不正是各个顶点由线段链接起来的嘛，所以我们需要保证两个顶点的权值一样，也就是来回路径保持一致，则证明这条边是通的，最后边数+1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  /** * 添加边的方法 * * @param v1 表示点的下标即第几个顶点 * @param v2 表示第二个顶点的下标 * @param weight 表示权值 */ public void insertEdge(int v1, int v2, int weight) { // 保证来回路径的权值一样  edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++;// 边的条数 +1  }    三、结束语 有了上述的方法，再使用一个主函数即可创建出一个图了，也不是很难吧。\n有关深度优先遍历和广度优先遍历，我们下一篇博客见。\n源码 ——\u003e 图\n","description":"","tags":null,"title":"图——基本概念以及相关方法","uri":"/tech/datastructes/graph01/"},{"categories":null,"content":"赫夫曼树 一、前言 1、基本介绍  给定 n 个权值作为 n 个叶子结点，构造一颗二叉树，若该树的带权路径（wpl）达到最小 ，称这样的二叉树为最优二叉树，也称为赫夫曼树（Huffman Tree）； 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。  2、重要概念  路径和路径长度： 在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径；通路中分支的数目称为路径的长度；若规定根结点的层数为1，则从根结点到第L层结点的路径长度为 L - 1； 结点的权以及带权路径的长度： 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权；结点的带权路径的长度为：从根结点到该结点之间的路径长度与该结点的权的乘积； 树的带权路径长度： 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL（weighted path length），权值越大的结点离根结点越近的二叉树才是最优二叉树； WPL最小的就是赫夫曼树。   二、案例分析 要求： 给一个数列{13, 7, 8, 3, 29, 6, 1}，转成一颗赫夫曼树。\n1、思路分析 1）从小到大进行排序，将每一个数据（每个数据就是一个结点），每个结点都可以看成是一颗最简单的二叉树；\n2）取出根结点权值最小的两颗二叉树；\n3）组成一颗新的二叉树，该新的二叉树的根结点的权值是前面两颗二叉树根结点权值的和；\n4）再将这颗新的二叉树，以根结点的权值大小，依次排序，不断重复 1-2-3-4步骤，直到所有数据都被处理，就得到一颗赫夫曼树。\n2、图解 其中蓝色的结点表示数列中需要调整的结点，绿色表示新生成的结点\n 三、代码实现 1、结点类Node ①定义基础变量及说明 该类用于定义结点属性，以及相关实现方法。由于需要对Node结点进行排序，这里引入 Collections 集合排序，实现 Comparable。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 创建类结点 // 为了让Node对象持续排序 Collections 集合排序，实现 Comparable 接口 class Node implements Comparable\u003cNode\u003e { int value;// 结点权值  Node left;// 指向左子结点  Node right;// 指向右子结点  // 构造器  public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } }   ②前序遍历方法 这里我们使用前序遍历输出赫夫曼树。\n根据前序遍历的框架，首先输出当前结点，然后判断左子结点是否为空，如果不为空则递归输出；最后判断右子结点是否为空，如果不为空，递归输出即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 前序遍历  public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } }   ③compareTo函数 利用 compareTo函数 对结点进行排序，按照从小到大进行排序。\n1 2 3 4 5  @Override public int compareTo(Node node) { // 表示从小到大排序  return this.value - node.value; }   2、HuffmanTree类（主类） ①重载前序遍历方法 重载Node结点类的 preOrder()方法 ，加上判断条件，如果为空，则输出相关信息即可。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 编写一个前序遍历的方法  public static void preOrder(Node root) { if (root != null) { root.preOrder(); } else { System.out.println(\"是空树，无法完成遍历~~~\"); } }   ②创建赫夫曼树方法 该方法也是本次内容的重点了，接下来，我们细细分析。先说明：需要一个创建赫夫曼树的数组，创建好赫夫曼树之后，以root结点进行返回。\n拿到数组之后，我们需要做的第一件事就是，遍历arr数组，将arr的每个元素构成一个Node，最后将Node放入到ArrayList中。\n1 2 3 4  ArrayList\u003cNode\u003e nodes = new ArrayList\u003c\u003e(); for (int value : arr) { nodes.add(new Node(value)); }   经过上述处理之后，我们就得到了一个nodes，紧接着对此进行展开操作。前面提到，我们需要对数组进行从小到大的排序，所以Collections.sort(nodes);\n形成赫夫曼树的操作：\n1）取出权值最小的结点（二叉树），因为经过排序，所以下标为0的结点就是最小的；\n2）取出权值第二小的结点（二叉树）；\n3）构建一棵新的二叉树，新二叉树的权值为左子结点和右子结点的权值之和；\n4）从ArrayList删除处理过的二叉树，直接使用remove方法即可；\n5）将parent结点加入到nodes中。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  /** * 创建哈夫曼树的方法 * * @param arr 需要创建哈夫曼树的数组 * @return 创建好后的哈夫曼树的root结点 */ public static Node createHuffmanTree(int[] arr) { /** * 1、遍历arr数组； * 2、将arr的每个元素构成一个Node * 3、将Node放入到ArrayList中 */ ArrayList\u003cNode\u003e nodes = new ArrayList\u003c\u003e(); for (int value : arr) { nodes.add(new Node(value)); } // 进行循环处理  while (nodes.size() \u003e 1) { // 排序 从小到大  Collections.sort(nodes); System.out.println(\"nodes = \" + nodes); // 取出根结点权值最小的两棵二叉树  // 1、取出权值最小的结点（二叉树）  Node leftNode = nodes.get(0); // 2、取出权值第二小的结点（二叉树）  Node rightNode = nodes.get(1); // 3、构建一颗新的二叉树  Node parent = new Node(leftNode.value + rightNode.value); parent.left = leftNode; parent.right = rightNode; // 4、从ArrayList删除处理过的二叉树  nodes.remove(leftNode); nodes.remove(rightNode); // 5、将parent结点加入到nodes中  nodes.add(parent); } // 返回哈夫曼树的root结点  return nodes.get(0); }    四、结束语 经过以上的操作，我们就完成了一棵赫夫曼树，根据赫夫曼的特点，有一种编码叫做赫夫曼编码，这个因为牵涉到的代码量较大，我们就有时间再说。\n此外，对于赫夫曼树的测试主方法，并没有说明，小朋友们可以自行完善。\n源码地址 ——\u003e HuffmanTree\n","description":"","tags":null,"title":"数据结构——赫夫曼树","uri":"/tech/datastructes/huffmantree/"},{"categories":null,"content":" 如果可以的话，我想看看明年这个时候的自己是什么状态，或者 回到三年前，对那个时候的自己说一声：其实也没啥大不了，你一定可以成为你想成为的那个人。\n 疫情还没结束，但 2020 就要过去了，似乎这一年过得有点无语、有点匪夷所思，一种说不清道不明的感觉。记得小学的时候，老师让写作文，关于未来，就想着 2020 年的生活怎么样，记得当时有一点是：可以在家上学，没想到的是，我们在这样一种环境实现了在家上学。\n今年过的好嘛？？还行吧，虽然和自己想的完全是两个样子，但是做了一些值得去做的事，认识了一些有趣的人，这就够了。\n如果说 2019 年是我沉淀的一年，那么我想用厚积薄发来形容今年的自己。19 年八月底，发了一个朋友圈。给我三年，\n现在回过头来想想，不免觉得有点中二，哈哈哈哈。但也正是这股中二的动力，一直 push 着我向前走。但其实事实是：说这句话，当时所想的奋斗目标，和自己的现在的样子完全是两个样子。 当时的目标，无外乎就是学习啊、证书啊、名次啊…… 这些世俗的东西，但同样是避免不了的。如果不世俗，又怎么能真正做到不世俗呢？？幸好，在寻找的过程中，找到了目前的自己想做的事情，也是我想真正坚持下去的事情。\n絮絮叨叨说了一堆没啥用的，而且还是关于 2019 的事情，其实关于今年，没啥好说的。就像是一场梦，还没醒来，就结束了。那就说说，今年对我影响比较大的三本书吧。\n《百年独孤》看完这本书是四月份。可能也是和当时自己的处境有关，感觉自己一个人总是孤立的、没人懂我。这本书也是我硬着头皮看完的，里面的人名可以说直接就劝退。为什么这本书对我的影响比较大呢？？当一个人能感受到孤独的时候，才能做到静下心来。就像马尔克斯在书中所写的一样：所有人都显得很寂寞，用自己的方式想尽办法排遣寂寞，事实上仍是延续自己的寂寞。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。 刚好那个时候，对于Java特别感兴趣，也就是在这种孤独感的环境下，能够让我有足够的耐心去读 JDK 和 JVM 源码，从而可以有效的提高自己的编程水平和技巧，随着越深入的了解和学习，也就对写代码越来越着迷。（其实源码并未完全读完，着迷之后，就在各地找项目练手，刚好那个时候接触到开源，也就有了读一些顶级项目源码的机会，增加查克拉，哈哈哈哈）\n第二本书，我想说的是《人间简史：从动物到上帝》，这本书在书架上已经有一年多了，但是因为标题写得太大，我一向不是不喜欢读这类书籍的，总感觉有点空洞。当时看了一段作者 尤瓦尔·赫拉利的一期关于如何看待疫情的视频，便开始下手准备读下去。这本书，可谓不读不知道，从一个绝对想不到的宏观角度来阐述人类的发展。也正是受到这种宏观角度的影响，从而培养出了我一个良好的思考问题的习惯，可以出圈的来想问题，也就这样，使得我的思维能够超脱出现在的处境，能够找到自己，找到自己想要的时候，找到如何在自己有限的能力之下，做一些有意义的事情。\n最后我想说的是大刘的《三体》，这本书高中的时候就听说过，但一直拖到今年暑期才看完，《三体》除了是一部科幻作品之外，更重要的是关于人性的描绘，有人说，大刘在里面是不是过分的把人类描述的太丑陋了，但脱离人类的身份来思考这个问题，相信每个人都会得到一份属于自己的答案。也是这本书，让我找到活着的意义所在：人，在能够解决自身的基本需求之后，更重要的是要留下些东西。\n这些书都是上半年读的，至于下半年，读得更多的都是一些文言文，我绝对不会想到现在的自己，会“佛”到这种程度，哈哈哈哈哈。\n今年最大的收获就是接触到了开源，这是从我接触的悠悠球之后，重新找到能让我为之付出努力的事情，而且还和我的专业有关，如果说今年有啥值得吹得事情，那就是把自己的第一份 pr，提交给了 Apache 项目。\n最后，我想说，从做得到，到今天已经做到了。\n","description":"","tags":null,"title":"关于 2020_我想说","uri":"/life/about_2020/"},{"categories":null,"content":"第二章：面向对象 面向对象是学习编程过程中一个非常重要的思想，但是它却被很多人理解成了一个比较难，比较深奥的问题，其实不然。其实面向对象在理解之后还是很简单的，简而言之就是程序之中所有的操作都需要通过对象来完成。\n 举例来说：  操作浏览器要使用window对象 操作网页要使用document对象 操作控制台要使用console对象    一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。\n在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。\n1、类（class） 要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。\n  定义类：\n  1 2 3 4 5 6 7 8 9 10 11 12  class 类名 { 属性名: 类型; constructor(参数: 类型){ this.属性名 = 参数; } 方法名(){ .... } }       示例：\n  1 2 3 4 5 6 7 8 9 10 11 12 13  class Person{ name: string; age: number; constructor(name: string, age: number){ this.name = name; this.age = age; } sayHello(){ console.log(`大家好，我是${this.name}`); } }       使用类：\n  1 2  const p = new Person('孙悟空', 18); p.sayHello();       2、面向对象的特点   封装\n  对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装\n  默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置\n  只读属性（readonly）：\n 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改    TS中属性具有三种修饰符：\n public（默认值），可以在类、子类和对象中修改 protected ，可以在类、子类中修改 private ，可以在类中修改    示例：\n  public\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Person{ public name: string; // 写或什么都不写都是public  public age: number; constructor(name: string, age: number){ this.name = name; // 可以在类中修改  this.age = age; } sayHello(){ console.log(`大家好，我是${this.name}`); } } class Employee extends Person{ constructor(name: string, age: number){ super(name, age); this.name = name; //子类中可以修改  } } const p = new Person('孙悟空', 18); p.name = '猪八戒';// 可以通过对象修改       protected\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Person{ protected name: string; protected age: number; constructor(name: string, age: number){ this.name = name; // 可以修改  this.age = age; } sayHello(){ console.log(`大家好，我是${this.name}`); } } class Employee extends Person{ constructor(name: string, age: number){ super(name, age); this.name = name; //子类中可以修改  } } const p = new Person('孙悟空', 18); p.name = '猪八戒';// 不能修改       private\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Person{ private name: string; private age: number; constructor(name: string, age: number){ this.name = name; // 可以修改  this.age = age; } sayHello(){ console.log(`大家好，我是${this.name}`); } } class Employee extends Person{ constructor(name: string, age: number){ super(name, age); this.name = name; //子类中不能修改  } } const p = new Person('孙悟空', 18); p.name = '猪八戒';// 不能修改         属性存取器\n  对于一些不希望被任意修改的属性，可以将其设置为private\n  直接将其设置为private将导致无法再通过对象修改其中的属性\n  我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器\n  读取属性的方法叫做setter方法，设置属性的方法叫做getter方法\n  示例：\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Person{ private _name: string; constructor(name: string){ this._name = name; } get name(){ return this._name; } set name(name: string){ this._name = name; } } const p1 = new Person('孙悟空'); console.log(p1.name); // 通过getter读取name属性  p1.name = '猪八戒'; // 通过setter修改name属性         静态属性\n  静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用\n  静态属性（方法）使用static开头\n  示例：\n  1 2 3 4 5 6 7 8 9 10  class Tools{ static PI = 3.1415926; static sum(num1: number, num2: number){ return num1 + num2 } } console.log(Tools.PI); console.log(Tools.sum(123, 456));         this\n 在类中，使用this表示当前对象      继承\n  继承时面向对象中的又一个特性\n  通过继承可以将其他类中的属性和方法引入到当前类中\n  示例：\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Animal{ name: string; age: number; constructor(name: string, age: number){ this.name = name; this.age = age; } } class Dog extends Animal{ bark(){ console.log(`${this.name}在汪汪叫！`); } } const dog = new Dog('旺财', 4); dog.bark();         通过继承可以在不修改类的情况下完成对类的扩展\n  重写\n  发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写\n  示例：\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Animal{ name: string; age: number; constructor(name: string, age: number){ this.name = name; this.age = age; } run(){ console.log(`父类中的run方法！`); } } class Dog extends Animal{ bark(){ console.log(`${this.name}在汪汪叫！`); } run(){ console.log(`子类中的run方法，会重写父类中的run方法！`); } } const dog = new Dog('旺财', 4); dog.bark();     在子类中可以使用super来完成对父类的引用\n      抽象类（abstract class）\n  抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例\n  1 2 3 4 5 6 7 8 9 10 11 12  abstract class Animal{ abstract run(): void; bark(){ console.log('动物在叫~'); } } class Dog extends Animals{ run(){ console.log('狗在跑~'); } }     使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现\n      3、接口（Interface） 接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。\n  示例（检查对象类型）：\n  1 2 3 4 5 6 7 8 9 10 11  interface Person{ name: string; sayHello():void; } function fn(per: Person){ per.sayHello(); } fn({name:'孙悟空', sayHello() {console.log(`Hello, 我是 ${this.name}`)}});       示例（实现）\n  1 2 3 4 5 6 7 8 9 10 11 12 13  interface Person{ name: string; sayHello():void; } class Student implements Person{ constructor(public name: string) { } sayHello() { console.log('大家好，我是'+this.name); } }        4、泛型（Generic） 定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。\n  举个例子：\n  1 2 3  function test(arg: any): any{ return arg; }     上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型\n  使用泛型：\n  1 2 3  function test\u003cT\u003e(arg: T): T{ return arg; }     这里的\u003cT\u003e就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。\n  那么如何使用上边的函数呢？\n  方式一（直接使用）：\n  1  test(10)     使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式\n    方式二（指定类型）：\n  1  test\u003cnumber\u003e(10)     也可以在函数后手动指定泛型\n      可以同时指定多个泛型，泛型间使用逗号隔开：\n  1 2 3 4 5  function test\u003cT, K\u003e(a: T, b: K): K{ return b; } test\u003cnumber, string\u003e(10, \"hello\");     使用泛型时，完全可以将泛型当成是一个普通的类去使用\n    类中同样可以使用泛型：\n  1 2 3 4 5 6 7  class MyClass\u003cT\u003e{ prop: T; constructor(prop: T){ this.prop = prop; } }       除此之外，也可以对泛型的范围进行约束\n  1 2 3 4 5 6 7  interface MyInter{ length: number; } function test\u003cT extends MyInter\u003e(arg: T): number{ return arg.length; }     使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。\n      ","description":"","tags":null,"title":"TypeScript学习笔记02","uri":"/tech/typescript02/"},{"categories":null,"content":"第一章 快速入门 0、TypeScript简介  TypeScript是JavaScript的超集。 它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。 TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。 TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。 相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。  1、TypeScript 开发环境搭建   下载Node.js\n 64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi 32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi    安装Node.js\n  使用npm全局安装typescript\n 进入命令行 输入：npm i -g typescript    创建一个ts文件\n  使用tsc对ts文件进行编译\n  进入命令行\n  进入ts文件所在目录\n  执行命令：tsc xxx.ts\n    2、基本类型   类型声明\n  类型声明是TS非常重要的一个特点\n  通过类型声明可以指定TS中变量（参数、形参）的类型\n  指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错\n  简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值\n  语法：\n  1 2 3 4 5 6 7  let 变量: 类型; let 变量: 类型 = 值; function fn(参数: 类型, 参数: 类型): 类型{ ... }         自动类型判断\n TS拥有自动的类型判断机制 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明    类型：\n   类型 例子 描述     number 1, -33, 2.5 任意数字   string 'hi', \"hi\", hi 任意字符串   boolean true、false 布尔值true或false   字面量 其本身 限制变量的值就是该字面量的值   any * 任意类型   unknown * 类型安全的any   void 空值（undefined） 没有值（或undefined）   never 没有值 不能是任何值   object {name:'孙悟空'} 任意的JS对象   array [1,2,3] 任意JS数组   tuple [4,5] 元素，TS新增类型，固定长度数组   enum enum{A, B} 枚举，TS中新增类型      number\n  1 2 3 4 5  let decimal: number = 6; let hex: number = 0xf00d; let binary: number = 0b1010; let octal: number = 0o744; let big: bigint = 100n;       boolean\n  1  let isDone: boolean = false;       string\n  1 2 3 4 5 6 7 8  let color: string = \"blue\"; color = 'red'; let fullName: string = `Bob Bobbington`; let age: number = 37; let sentence: string = `Hello, my name is ${fullName}. I'll be ${age + 1}years old next month.`;       字面量\n  也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围\n  1 2  let color: 'red' | 'blue' | 'black'; let num: 1 | 2 | 3 | 4 | 5;       any\n  1 2 3  let d: any = 4; d = 'hello'; d = true;       unknown\n  1 2  let notSure: unknown = 4; notSure = 'hello';       void\n  1  let unusable: void = undefined;       never\n  1 2 3  function error(message: string): never { throw new Error(message); }       object（没啥用）\n  1  let obj: object = {};       array\n  1 2  let list: number[] = [1, 2, 3]; let list: Array\u003cnumber\u003e = [1, 2, 3];       tuple\n  1 2  let x: [string, number]; x = [\"hello\", 10];       enum\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  enum Color { Red, Green, Blue, } let c: Color = Color.Green; enum Color { Red = 1, Green, Blue, } let c: Color = Color.Green; enum Color { Red = 1, Green = 2, Blue = 4, } let c: Color = Color.Green;       类型断言\n  有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：\n  第一种\n  1 2  let someValue: unknown = \"this is a string\"; let strLength: number = (someValue as string).length;       第二种\n  1 2  let someValue: unknown = \"this is a string\"; let strLength: number = (\u003cstring\u003esomeValue).length;           3、编译选项   自动编译文件\n  编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。\n  示例：\n  1  tsc xxx.ts -w         自动编译整个项目\n  如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。\n  但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json\n  tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译\n  配置选项：\n  include\n  定义希望被编译文件所在的目录\n  默认值：[\"**/*\"]\n  示例：\n  1  \"include\":[\"src/**/*\", \"tests/**/*\"]     上述示例中，所有src目录和tests目录下的文件都会被编译\n      exclude\n  定义需要排除在外的目录\n  默认值：[\"node_modules\", \"bower_components\", \"jspm_packages\"]\n  示例：\n  1  \"exclude\": [\"./src/hello/**/*\"]     上述示例中，src下hello目录下的文件都不会被编译\n      extends\n  定义被继承的配置文件\n  示例：\n  1  \"extends\": \"./configs/base\"     上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息\n      files\n  指定被编译文件的列表，只有需要编译的文件少时才会用到\n  示例：\n  1 2 3 4 5 6 7 8 9 10 11  \"files\": [ \"core.ts\", \"sys.ts\", \"types.ts\", \"scanner.ts\", \"parser.ts\", \"utilities.ts\", \"binder.ts\", \"checker.ts\", \"tsc.ts\" ]     列表中的文件都会被TS编译器所编译\n    compilerOptions\n  编译选项是配置文件中非常重要也比较复杂的配置选项\n  在compilerOptions中包含多个子选项，用来完成对编译的配置\n  项目选项\n  target\n  设置ts代码编译的目标版本\n  可选值：\n ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext    示例：\n  1 2 3  \"compilerOptions\": { \"target\": \"ES6\" }     如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码\n      lib\n  指定代码运行时所包含的库（宿主环境）\n  可选值：\n ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......    示例：\n  1 2 3 4 5 6  \"compilerOptions\": { \"target\": \"ES6\", \"lib\": [\"ES6\", \"DOM\"], \"outDir\": \"dist\", \"outFile\": \"dist/aa.js\" }         module\n  设置编译后代码使用的模块化系统\n  可选值：\n CommonJS、UMD、AMD、System、ES2020、ESNext、None    示例：\n  1 2 3  \"compilerOptions\": { \"module\": \"CommonJS\" }         outDir\n  编译后文件的所在目录\n  默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置\n  示例：\n  1 2 3  \"compilerOptions\": { \"outDir\": \"dist\" }     设置后编译后的js文件将会生成到dist目录\n      outFile\n  将所有的文件编译为一个js文件\n  默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中\n  示例：\n  1 2 3  \"compilerOptions\": { \"outFile\": \"dist/app.js\" }         rootDir\n  指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录\n  示例：\n  1 2 3  \"compilerOptions\": { \"rootDir\": \"./src\" }         allowJs\n 是否对js文件编译    checkJs\n  是否对js文件进行检查\n  示例：\n  1 2 3 4  \"compilerOptions\": { \"allowJs\": true, \"checkJs\": true }         removeComments\n 是否删除注释 默认值：false    noEmit\n 不对代码进行编译 默认值：false    sourceMap\n 是否生成sourceMap 默认值：false      严格检查\n strict  启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查   alwaysStrict  总是以严格模式对代码进行编译   noImplicitAny  禁止隐式的any类型   noImplicitThis  禁止类型不明确的this   strictBindCallApply  严格检查bind、call和apply的参数列表   strictFunctionTypes  严格检查函数的类型   strictNullChecks  严格的空值检查   strictPropertyInitialization  严格检查属性是否初始化      额外检查\n noFallthroughCasesInSwitch  检查switch语句包含正确的break   noImplicitReturns  检查函数没有隐式的返回值   noUnusedLocals  检查未使用的局部变量   noUnusedParameters  检查未使用的参数      高级\n allowUnreachableCode  检查不可达代码 可选值：  true，忽略不可达代码 false，不可达代码将引起错误     noEmitOnError  有错误的情况下不进行编译 默认值：false                4、webpack   通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。\n  步骤：\n  初始化项目\n 进入项目根目录，执行命令  npm init -y  主要作用：创建package.json文件      下载构建工具\n npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin  共安装了7个包  webpack  构建工具webpack   webpack-cli  webpack的命令行工具   webpack-dev-server  webpack的开发服务器   typescript  ts编译器   ts-loader  ts加载器，用于在webpack中编译ts文件   html-webpack-plugin  webpack中html插件，用来自动创建html文件   clean-webpack-plugin  webpack中的清除插件，每次构建都会先清除目录          根目录下创建webpack的配置文件webpack.config.js\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const { CleanWebpackPlugin } = require(\"clean-webpack-plugin\"); module.exports = { optimization:{ minimize: false // 关闭代码压缩，可选  }, entry: \"./src/index.ts\", devtool: \"inline-source-map\", devServer: { contentBase: './dist' }, output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\", environment: { arrowFunction: false // 关闭webpack的箭头函数，可选  } }, resolve: { extensions: [\".ts\", \".js\"] }, module: { rules: [ { test: /\\.ts$/, use: { loader: \"ts-loader\" }, exclude: /node_modules/ } ] }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ title:'TS测试' }), ] }       根目录下创建tsconfig.json，配置可以根据自己需要\n  1 2 3 4 5 6 7  { \"compilerOptions\": { \"target\": \"ES2015\", \"module\": \"ES2015\", \"strict\": true } }       修改package.json添加如下配置\n  1 2 3 4 5 6 7 8 9  { ...略... \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"build\": \"webpack\", \"start\": \"webpack serve --open chrome.exe\" }, ...略... }       在src下创建ts文件，并在并命令行执行npm run build对代码进行编译，或者执行npm start来启动开发服务器\n    5、Babel   经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。\n  安装依赖包：\n npm i -D @babel/core @babel/preset-env babel-loader core-js 共安装了4个包，分别是：  @babel/core  babel的核心工具   @babel/preset-env  babel的预定义环境   @babel-loader  babel在webpack中的加载器   core-js  core-js用来使老版本的浏览器支持新版ES语法        修改webpack.config.js配置文件\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  ...略... module: { rules: [ { test: /\\.ts$/, use: [ { loader: \"babel-loader\", options:{ presets: [ [ \"@babel/preset-env\", { \"targets\":{ \"chrome\": \"58\", \"ie\": \"11\" }, \"corejs\":\"3\", \"useBuiltIns\": \"usage\" } ] ] } }, { loader: \"ts-loader\", } ], exclude: /node_modules/ } ] } ...略...     如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。\n      ","description":"","tags":null,"title":"Typescript 学习笔记01","uri":"/tech/typescript01/"},{"categories":null,"content":"二叉平衡树 一、前言 1、案例分析 现在有一个数列 {1, 2, 3, 4, 5, 6}，要求创建一颗二叉排序树，并分析问题所在。\n左边BST存在的问题分析：\n 左子树全部为空，从形式上看，更像是一个单链表； 插入速度没影响； 查询速度明显降低（因为需要依次比较），不能发挥BST的优势，因为每次还需要比较左子树，导致其查询速度比单链表还慢。  如下图：\n所以根据以上出现的问题，也就有了我们今天的主角：平衡二叉树。\n2、基本介绍 平衡二叉树，也叫平衡二叉搜索树，又被称为 AVL树，可以保证有较高的查询效率。同时具有以下特点：它是一棵空树 或 它的左右两个子树的高度差的绝对值不超过1，并且 左右两个子树都是一棵平衡二叉树。\n平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。\n下面我们将结合具体的实例，来一探平衡二叉树的究竟！！！\n二、案例分析 1、应用案例——左旋转 1）要求：给你一个数列，创建出对应的平衡二叉树，数列{4, 3, 6, 5, 7, 8}\n2）思路分析：\n问题：当插入 8 时， rightHeight() - leftHeigth() \u003e 1  成立，此时，不再是一颗AVL树了，因此我们需要怎么处理才能达到想要的效果呢？ ——\u003e 左旋转\n 创建一个新的结点 newNode （以4这个值创建），值等于当前根结点的值； 把新结点的左子树设置成当前结点的左子树，newNode.left = left; 把新结点的右子树设置为当前结点的右子树的左子树，newNode.right = right.left; 把当前结点的值换为右子结点的值，value = right.value; 把当前结点的右子树设置成右子树的右子树，right = right.right; 把当前结点的左子树设置为新结点，left = newNode;  好了，完成了以上的操作，这时就已经成为了一颗AVL树，但是相信很多小伙伴读到这里，肯定很迷，不急不急请看下图：\n2、应用案例——右旋转 相信结合左旋转的代码和图片，大家已经可以完成了该操作。接下来我们来看看右旋转，其实说白了就是把左旋转 \"反过来\" 。\n1）要求：给你一个数列，创建出对应的平衡二叉树，数列{10, 12, 8, 9, 7, 6}\n2）思路分析：\n问题：当插入 6 时， leftHeight() - rightHeigth() \u003e 1  成立，此时，不再是一颗AVL树了，因此我们需要怎么处理才能达到想要的效果呢？ ——\u003e 右旋转\n 创建一个新的结点 newNode （以4这个值创建），值等于当前根结点的值； 把新结点的右子树设置成当前结点的右子树，newNode.right = right; 把新结点的左子树设置为当前结点的左子树的右子树，newNode.left = left.right; 把当前结点的值换为左子结点的值，value = left.value; 把当前结点的左子树设置成左子树的左子树，left = left.left; 把当前结点的右子树设置为新结点，right = newNode;  3、应用案例——双旋转 你以为到这就结束了，想的太简单点了吧，还有一种情况就是只使用一次左旋转或者右旋转是达不到效果的，那就得进行双旋转咯。比如数列：int[] arr = {10, 11, 7, 6, 8, 9}; 运行原来的代码可以看见，并没有转成AVL树。这时我们就需要对问题进行剖析了：\n解决思路：\n 当符合右旋转的条件时 如果它的左子树的右子树高度大于它的左子树的高度 先对当前这个结点的左结点进行左旋转 再对当前结点进行右旋转的操作即可。   三、代码实现 1、返回以该结点为根结点树的高度 在比较两个结点的左右子树的差值的时候，我们首先需要获取当前根结点的高度。\n使用Java内置的Math类库的max方法，从而返回较大的数值。这里我们对于左子树进行说明，（右子树也是同理），left == null ? 0 : left.height() 使用三目运算符，先判断left是否为空，如果为空，直接返回null，否则递归的遍历左子树。\n1 2 3 4  // 返回以该结点为根结点树的高度  public int height() { return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; }   2、返回左子树的高度 先判断左子树是否为空 if(left == null)，如果为空直接返回为0，否则调用height() 方法。\n1 2 3 4 5 6 7  // 返回左子树的高度  public int leftHeight() { if (left == null) { return 0; } return left.height(); }   3、返回右子树的高度 和左子树同理。\n1 2 3 4 5 6 7  // 返回右子树的高度  public int rightHeight() { if (right == null) { return 0; } return right.height(); }   4、左右旋转方法 在案例分析中，已经阐述了该方法的原理，这里就不做过多的赘述，直接上代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // 左旋转方法  private void leftRotate() { // 创建新的结点，以当前根结点的值  Node newNode = new Node(value); // 把新的结点的左子树设置成当前结点的左子树  newNode.left = left; // 把新的结点的右子树设置成当前结点的右子树的左子树  newNode.right = right.left; // 把当前结点的值替换成右子结点的值  value = right.value; // 把当前面结点的右子树设置成当前结点右子树的右子树  right = right.right; // 把当前结点的左子树（左子结点）设置成新的结点  left = newNode; } // 右旋转方法  private void rightRotate() { // 创建新的结点，以当前根结点的值  Node newNode = new Node(value); // 把新的结点的右子树设置成当前结点的右子树  newNode.right = right; // 把新的结点的左子树设置成当前结点的左子树的右子树  newNode.left = left.right; // 把当前结点的值替换成左子结点的值  value = left.value; // 把当前结点的左子树设置成当前结点的左子树的左子树  left = left.left; // 把当前结点的右子树（右子结点）设置成新结点  right = newNode; }   5、添加结点 我们关于旋转方法的使用，是在添加结点的方法中实现。添加结点方法是基于二叉排序树的基础上完善的，如果还不了解的小伙伴可以去看上一篇博客。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // 添加结点  public void add(Node node) { if (node == null) { return; } // 判断传入结点的值和当前子树根结点值的关系  if (node.value \u003c this.value) { // 如果当前结点的左子结点为null  if (this.left == null) { this.left = node; } else { // 递归的向左子树添加  this.left.add(node); } } else {// 传入结点的值大于当前结点  if (this.right == null) { this.right = node; } else { // 递归的向右子树添加  this.right.add(node); } } // 当添加一个结点后，如果：（右子树的高度 - 左子树的高度）\u003e 1，左旋转  if (rightHeight() - leftHeight() \u003e 1) { // 如果它的右子树的左子树的高度大于它右子树的右子树高度  if (right != null \u0026\u0026 right.leftHeight() \u003e right.rightHeight()) { // 先对右子树进行旋转  right.rightRotate(); // 然后再对当前结点进行左旋转  leftRotate();// 左旋转  } else { // 直接进行左旋转  leftRotate(); } return;// 必须要！！！  } // 当添加完一个结点后，如果（左子树的高度 - 右子树的高度）\u003e 1，右旋转  if (leftHeight() - rightHeight() \u003e 1) { // 如果它的左子树的右子树的高度大于它的左子树的左子树的高度  if (left != null \u0026\u0026 left.rightHeight() \u003e left.leftHeight()) { // 先对左子结点进行右旋转  left.leftRotate(); // 然后再对当前结点进行右旋转  rightRotate(); } else { // 直接进行右旋转  rightRotate(); } } }    四、结束语 到此，关于AVL树的相关操作我们已经完成，但对于遍历、输出等函数这里并没有进行相关说明，因为这些方法在前面已经说过很多类似的了，所以就把内容更侧重于关于具体问题算法的实现。\n说实话，有的时候不push自己，可能永远不会继续写下去\n源码地址 ——\u003eAVLTree\n","description":"","tags":null,"title":"AVLTree","uri":"/tech/datastructes/avltree/"},{"categories":null,"content":"二叉排序树 一、前言 1、引子 假设现在有一个数组{7, 3, 10, 12, 5, 1, 9} ，现在要求能够高效的完成对数据的添加、删除以及查询操作。\n根据我们之前所学过得内容，假设查找的数据集是普通的顺序存储，那么插入操作就是将记录放在表的末端，给表记录数加一即可，删除操作可以是删除后，后面的记录向前移，也可以是要删除的元素与最后一个元素互换，表记录数减一，反正整个数据集也没有固定的顺序，进行这样的操作的话，效率也还说得过去。准确来说，应该是，插入和删除对于顺序存储结构来说，效率还是可以接受的，但这样的表由于无序会造成查找的效率很低。\n如果需要查找的是一个有序线性表，并且是顺序是线性存储的，查找的话就可以使用折半、插值、斐波那契 等等查找算法来实现，可惜的是，因为是有序，在插入和删除操作上就不太方便，可能需要一移动大量的数据，耗费大量的时间。\n那么，有没有一种既可以使得插入和删除效率不错，又可以比较高效率地实现茶轴的算法呢？？这也就是我们今天所要说的二叉排序树(BinarySortTree) 。\n2、二叉排序树介绍 二叉排序树(Binary Sort Tree) ： 又称为二叉查找树。它或者是一棵空树，或者具有下列性质的二叉树：\n 若它的左子树不空，则左子树上所有的结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有的结点的值均小于它的根结点的值； 它的左、右子树也分别为二叉排序树。  特别说明：如果有相同的值，可以将该结点放在左结点或者右结点\n比如针对前面的数据{7, 3, 10, 12, 5, 1, 9} ，我们再另外插入一个结点 2，对应的二叉树如下：\n从二叉排序树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方法，另外，它的结点之间满足一定的次序关系，左子树结点一定比其双亲结点小，右子结点一定比其双亲结点大。\n构造一棵二叉树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。\n二、算法实现 由于考虑到BST算法的复杂性，所以使用两个类来完成操作，class Node 用于表示结点以及完成一些有关的基本方法，比如：添加结点、遍历等方法；class BinarySortTree 用于封装 Node 类中的方法，以及更具体的完成相关方法体的操作。\n1、声明基本变量 在 Node 类中，我们需要声明所需的基本变量 int value; 表示结点中所存储的值、Node left; 、 Node right; 二叉排序树的左子结点和右子结点，以及 toString 方法用于打印输出相关结点的信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 创建Node结点 class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } }   在 BinarySortTree 这个类中，定义一个 Node root 用于完成后续各种方法体中的使用， 可以理解成根结点 。以及返回root结点的方法。\n代码实现如下：\n1 2 3 4 5 6 7 8  class BinarySortTree { private Node root; public Node getRoot() { return root; } }   2、添加结点方法 在Node类中，完成对于添加结点方法的编写。\n在这里以递归的形式添加结点。首先我们通过方法体传入一个需要添加的结点 node 。然后判断该结点是否为空，如果为空，则无法添加直接返回即可。\n根据二叉排序树的性质，可知，如果传入的结点的值小于当前子树的根结点的值node.value \u003c this.value ，放到左子树，否则放到右子树。但是如何放置呢？这里以左子树举例，（右子同理）如果当前子树的左子结点为空this.left == null，直接把当前结点添加到左子树就好this.keft = node;；否则的话，递归的向左子树添加结点 this.left.add(node);\nNode类中代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 添加结点的方法，以递归的形式添加结点  public void add(Node node) { if (node == null) { return; } // 判断传入结点的值，和当前子树的根结点的值的关系  if (node.value \u003c this.value) { // 如果当前结点的左子结点为null  if (this.left == null) { this.left = node; } else { // 递归的向左子树添加  this.left.add(node); } } else {// 添加的结点的值大于当前结点的值  if (this.right == null) { this.right = node; } else { // 递归的向右子树添加结点  this.right.add(node); } } }   好了，到此为止，在Node类中完成了对于添加结点的方法操作，现在直接在BinarySortTree中封装一下，就可以使用了。\n还是一样，先传入一个结点node，然后判断需要添加子树的根结点是否是为空root == null，如果为空，直接让root指向node即可，root = node; 若不为空，直接调用Node类中的添加结点的方法即可。root.add(node);\nBinarySortTree类中代码实现如下：\n1 2 3 4 5 6 7 8  // 添加结点的方法  public void add(Node node) { if (root == null) { root = node;// 如果root为空，则直接让root指向node  } else { root.add(node); } }   3、中序遍历 在完成添加结点的方法之后，也就是创建二叉排序树，下面我们来使用中序遍历，完成对其的输出。\n说到中序遍历，想必大家已经都非常熟悉，所以也就没什么好说的了，输出顺序为：左子结点、根结点、右子结点 。所以我们按照这个顺序使用递归的方式完成即可，输出结点信息之前，需要先确认当前结点是否为空，如果不为空则开始递归遍历。\nNode类中代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 中序遍历  public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } }   在 BinarySortTree 类中，封装一下中序遍历方法。如果根结点不为空 root != null ，则开始遍历 root.infixOrder(); ，如果为空，则给出相对应的信息即可。\nBinarySortTree类中代码实现如下：\n1 2 3 4 5 6 7 8  // 中序遍历  public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"二叉排序树为空，不能遍历~~~\"); } }   4、查找要删除结点的结点及其父结点 在这里，我们要根据所给的需要删除结点的值 value，分别完成找到需要删除的结点以及其父结点的操作。\n①查找需要删除的结点 如果 value == this.value ，巧了，刚好找到，就是当前结点，执行 return this; 如果查找的值小于当前结点的值 value \u003c this.value ，向左子树递归查找，如果左子树为空 this.left == null ，return null; 否则，递归的向左子树查找 return this.left.search(value); 如果查找的值不小于当前结点的值，向右子树递归查找，具体操作与左子树相同，这里不做过多的赘述，直接上代码。\nNode类中代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /** * 查找需要删除的结点 * * @param value 需要删除的结点的值 * @return 如果找到就返回该结点，否则返回null */ public Node search(int value) { if (value == this.value) {// 找到，就是当前结点  return this; } else if (value \u003c this.value) {// 如果查找的值小于当前结点的值，向左子树递归查找  // 如果左子树为空  if (this.left == null) { return null; } return this.left.search(value); } else {// 如果查找的值不小于当前结点的值，向右子树递归查找  // 如果右子树为空  if (this.right == null) { return null; } return this.right.search(value); } }   在Node类中完成了对于查找要删除结点的方法操作，现在直接在BinarySortTree中封装一下，就可以使用了。\n先传入一个结点的值value，然后判断根结点是否是为空root == null，如果为空，直接返回null，return null; 若不为空，直接调用Node类中的查找删除结点的方法即可。return root.search(value);\n②查找要删除结点的父结点 接下来，我们完成一下对于 查找要删除结点的父结点的操作。还是和上面一样，先传入一个需要查找结点的值value ，返回的是需要删除结点的父结点，如果没有就返回null。\n如果当前结点就是需要删除结点的父结点(this.left != null \u0026\u0026 this.left.value == value) || (this.right != null \u0026\u0026 this.right.value == value)，直接返回即可 return this; 否则的话，根据二叉排序树的特点，完成以下操作：如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空 value \u003c this.value \u0026\u0026 this.left != null，开始递归向左子树进行查找 return this.left.searchParent(value); 如果要查找的值大于等于当前的值，并且当前结点的右子结点不为空 value \u003e= this.value \u0026\u0026 this.right != null，开始递归的向右子树查找 eturn this.right.searchParent(value); 如果进行上述两种操作之后，还是没找到的话，那么直接 return null;\nNode类中代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /** * 查找要删除结点的父结点 * * @param value 需要查找结点的值 * @return 返回的是需要删除结点的父结点，如果没有就返回null */ public Node searchParent(int value) { // 如果当前结点就是需要删除的结点的父结点，直接返回即可  if ((this.left != null \u0026\u0026 this.left.value == value) || (this.right != null \u0026\u0026 this.right.value == value)) { return this; } else { // 如果要查找的值小于当前结点的值，并且当前结点的左子结点不为空  if (value \u003c this.value \u0026\u0026 this.left != null) { return this.left.searchParent(value); } else if (value \u003e= this.value \u0026\u0026 this.right != null) { return this.right.searchParent(value); } else { return null;// 没有找到父结点  } } }   在Node类中完成了对于查找要删除结点的父结点方法的操作，现在直接在BinarySortTree中封装一下，就可以使用了。\n老规矩，先传入一个结点的值value，然后判断根结点是否是为空root == null，如果为空，直接返回null，return null; 若不为空，直接调用Node类中的查找删除结点的方法即可。return root.searchParent(value);\nBinarySortTree类中代码实现如下：\n1 2 3 4 5 6 7 8  // 查找父结点  public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } }   5、删除结点 俗话说 “请神容易送神难“ ，这不，正应了这句话。对于二叉排序树的删除，就不是那么容易了，我们不能因为删除了某个结点，就让这棵树变得不满足二叉排序树的特性，所以删除需要考虑多种情况。\n主要有以下三种情况：\n 删除 叶子节点 （比如：2,5,9,12） 删除 只有一颗子树的结点 （比如：1） 删除 有两棵子树的结点 （比如：7,3,10）  下面我们就对于以上的情况，进行具体的操作分析：\n①准备工作 在删除一个结点之前，我们需要保证删除的结点是有效的，然后再执行具体的删除方法。\n如果 root == null 也就是说，root为空，则直接 return即可。如果不为空，开始执行以下的操作：\n 1.需要先找到要删除的结点 targetNode Node targetNode = search(value);  如果没有找到要删除的结点 targetNode == null ,则直接return   2.如果当前的这棵二叉排序树只有一个结点，直接置空； 3.去找到TargetNode的父结点 Node parent = searchParent(value);  BinarySortTree类中代码实现如下：\n（这里我们直接把删除方法放在BinarySortTree类中完成）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  if (root == null) { return; } else { // 1、需要先找到要删除的结点 targetNode  Node targetNode = search(value); // 如果没有找到要删除的结点  if (targetNode == null) { return; } // 2、如果当前这颗二叉排序树只有一个结点  if (root.left == null \u0026\u0026 root.right == null) { root = null; return; } // 3 、去找到targetNode的父结点  Node parent = searchParent(value); }   ②删除叶子结点 对于要删除结点是叶子结点的情况，相对而言是比较容易的。因为是叶子结点，所以它没有左右子树，所以直接把它抹了即可。但是呢，它本身是无法完成删除操作的，需要先去找到要删除的结点 targetNode ,然后再去找到 targetNode 的父结点 parent ，接下就是需要确定 targetNode 是 parent的左子结点，还是右子结点，根据对应的情况进行删除即可。\n 如果是左子结点，将父结点的左子树置空，即 parent.left == null 如果是右子结点，将父结点的右子树置空，即 parent.right == null  BinarySortTree类中代码实现如下：\n1 2 3 4 5 6 7 8 9  // 4、如果要删除的节点是叶子结点  if (targetNode.left == null \u0026\u0026 targetNode.right == null) { // 判断targetNode是父结点的左子结点还是右子结点  if (parent.left != null \u0026\u0026 parent.left.value == value) {// 是左子结点  parent.left = null; } else if (parent.right != null \u0026\u0026 parent.right.value == value) {// 是右子结点  parent.right = null; } }   ③删除两棵子树的结点 为什么我们先说删除有两棵子树的结点呢？？那么因为语言描述只有一棵子树的结点，相比而言是要难一点的，所以直接把这种情况放在最后，用一个 else 来概括即可。\n删除是有两棵子树的结点 targetNode.left != null \u0026\u0026 targetNode.right != null ,因为它有两棵子树，那么它一旦被删除了，是谁来接班呢？？就好比如何选取一个合适的人选来继承家产呢，并且还满足二叉排序的特点。这样一来，问题也就随之而来了，该如何选出这个合适的继承人呢？？\n假设现在需要删除的结点是7，也就是该二叉排序树的根结点，现在仔细观察一下里面的元素，是否可以从其左右子树中找到适合的结点呢？？果然，5或9都可以代替7，此时删除7后，整个二叉排序树的结构并没有发生本质的改变。\n思考一下，为什么选择5或9这两个结点呢？？对的，它们刚好是二叉排序树中比它小或比它大的最接近7的两个数。也就是说，我们对当前这棵而排序树进行中序遍历，1, 2, 3, 5, 7, 9, 10, 12，它们刚好是7的前驱和后继。所以说现在的问题转化为如何知道需要删除结点的前驱结点或者后继结点。根据二叉排序树的特点，以需要删除的结点为根结点，那么它的右子树中最小的结点或者左子树中最大的结点，就是可以删除它后，从而代替它的结点。\n这里以右子树最小的结点为例，编写一个具体的方法来进行讲解。某颗子树最小的结点一定是左子树的最后一个结点，所以直接循环地查找左子结点，就会找到最小的值。找到最小的这个结点之后，先别激动，需要把它给删除，因为它即将代替需要删除的结点，再找个临时变量来保存它，这里我们先直接返回它，在具体的删除方法中再取出即可。\nBinarySortTree类中代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * 编写方法： * 1、返回的是以node为根结点的二叉排序树的最小结点的值 * 2、删除node为根结点的二叉排序树的最小结点 * * @param node 传入的结点（当做二叉排序树的根结点） * @return 返回的 以node为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; // 循环的查找左子结点，就会找到最小的值  while (target.left != null) { target = target.left; } // 这时target就指向了最小结点  // 删除最小结点  delNode(target.value); return target.value; }   哈哈哈哈，找到了继承人，接下来的工作，相对而言就要简单的多了，先找一个临时变量minVal 来保存从delRightTreeMin(targetNode.right) 返回的值，然后再把这个值重新赋值给需要删除的结点即可。\nBinarySortTree类中代码实现如下：\n1 2 3 4  else if (targetNode.left != null \u0026\u0026 targetNode.right != null) {// 删除的是有两棵子树的结点  int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; }   ④删除只有一颗子树的结点 对于要删除的结点只有左子树或只有右子树的情况，相对也是比较容易解决的。那就是结点删除后，将它的左子树或右子树整个移动到删除结点的位置即可，说直白点，可以理解为独自继承父业呗，哈哈哈哈。下面我们来看下具体的实现方法：\n既然是要删除它，那么毫无疑问，得先找到要删除的结点 targetNode，再接着找到其父结点 parent，然后 接下来的内容可能会有点绕，会有点傻傻的左右分不清，可以自己画图来尝试理解 ，确定targetNode的子结点是左子结点还是右子结点，以及 需要删除对的结点 targetNode 是其父结点 parent的左子结点还是右子结点。分成如下操作：\n  如果需要删除结点的左子树不为空 targetNode.left != null （并且 parent != null）\n 如果targetNode是parent的左子结点 parent.left.value == targetNode.value - 将其父结点的左索引指向其左子结点 parent.left = targetNode.left; 否则targetNode是parent的右子结点  将其父结点的右索引指向其左子结点 parent.right = targetNode.left;      否则（如果parent为空），直接 root == targetNode.left;即可。\n  如果需要删除结点的右子树不为空（并且 parent != null）\n 如果targetNode是parent的左子结点 parent.left.value == targetNode.value  将其父结点的左索引指向其右子结点 parent.left = targetNode.right;   否则targetNode是parent的右子结点  将其父结点的右索引指向其右子结点 parent.right = targetNode.right;      否则（如果parent为空），直接 root == targetNode.right;即可。\n  BinarySortTree类中代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  else {// 删除只有一颗子树的结点  // 如果要删除的节点有左子结点  if (targetNode.left != null) { if (parent != null) { // 如果targetNode是parent的左子结点  if (parent.left.value == targetNode.value) { parent.left = targetNode.left; } else {//targetNode是parent的右子结点  parent.right = targetNode.left; } } else { root = targetNode.left; } } else {// 如果需要删除的结点有右子结点  if (parent != null) { // 如果targetNode是parent的左子结点  if (parent.left.value == targetNode.value) { parent.left = targetNode.right; } else {// 如果targetNode是parent的右子结点  parent.right = targetNode.right; } } else { root = targetNode.right; } } }   到此为止，我们完成了对于一个结点的删除工作，由此可见是相当的麻烦啊！！！\n 三、结束语 该死的二叉排序树终于写完了，十一月份只写了一半，忙（懒）成狗。。。。\n二叉排序树是链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点。只要找到合适的插入和删除位置后，仅需修改链接指针即可。对于查找而言，走的就是从根结点到要查找结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。因为篇幅优先，查找算法可以结合之前所更新的博客自行完成即可。\n源码地址 ——\u003e 二叉排序树\n","description":"","tags":null,"title":"二叉排序树","uri":"/tech/datastructes/bst/"},{"categories":null,"content":"堆排序 一、前言 0、牢骚话 说实话，有点惭愧，十月份真的咕咕了好久。。。可能是因为真的比较忙，忙着参加比赛，忙着开源年会，其实这都是借口、要是想更，时间总是可挤得出来的。也许是越往后，牵涉到的内容也就越多，可能是知识点掌握的不太牢固，就一直懒得水文章（其实前面几篇文章已经暴露这个问题，只不过还是硬着头皮在做）。针对以上出现的问题，我就毅然决然的选择先缓，静下心来，再好好琢磨琢磨。\n1、堆的基本介绍 说到堆排序，大家可能会想到“堆”，为什么叫堆排序呢？其实不难不理解，我们都见过“堆”型的东西，比如金字塔。。那么这个和排序有什么关系呢？？下面我们来看一下关于堆的定义：\n 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：\n 对吧，是不是堆形的。其实我们利用上一节说过线索化二叉树，将其存放在数组中进行操作，如下：\n这个数组从逻辑上说就是一个堆的结构，经过前人的总结，我们可以使用简单的公式描述一下堆：\n  大顶堆：arr[i] \u003e= arr[2i+1] \u0026\u0026 arr[i] \u003e= arr[2i+2]\n  小顶堆：arr[i] \u003c= arr[2i+1] \u0026\u0026 arr[i] \u003c= arr[2i+2]\n  说到这儿，想必大家对于堆这种结构已经有了简单的了解，接下来我们来一探究竟，看看如何来实现排序的。\n3、堆排序的基本思想 注：一般升序采用大顶堆，降序采用小顶堆。\n **堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列 **\n ①步骤一：构造初始堆 将给定无序序列构造成一个大顶堆\na.假设给定无序序列结构如下： b.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。 c.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。 d.这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。 此时，如此反复通过上述步骤，我们就将一个无序序列构建成了一个大顶堆。\n②步骤二：将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 a.将堆顶元素9和末尾元素4进行交换 b.重新调整结构，使其继续满足堆定义 c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8. d.后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序 ③小结 再简单总结下堆排序的基本思路：\n　a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;\n　b.将堆顶元素与末尾元素交换，将最大元素\"沉\"到数组末端;\n　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。\n 二、算法实现 经过上述的介绍，大致对于堆排序都有了一个简单的了解，但是具体一点，可能还是比较迷，最起码应该知道两个步骤：①构建一个大顶堆（或小顶堆）；②进行排序。下面我们上手代码，通过代码和图解效果可能会好点。\n1、构建大顶堆 将一个数组（二叉树），调整成一个大顶堆。（功能：完成将以i对应对的非叶子结点的树，调整成大顶堆）这里我们对传入的数组进行升序操作，所以采用大顶堆，反之使用小顶堆即可。\n首先需要有传入的待排序数组int[] arr、非叶子结点在数组中的索引int i 、对应多少个元素进行调整int length，我们需要注意的是随着构建的过程length是在逐渐减少的。好了，知道了应该传入哪些变量之后，我们开始动工！！！（可能比较难理解，我会尽量按照我理解的思路来阐述）\n我们知道i表示的是一个非叶子结点，所以先把这个结点的值取出临时保存在一个临时变量中（后期有用的）int temp = arr[i]; 然后我们依次遍历该结点的左右子结点并比较其大小，选出较大的一个与当前i对应的结点进行比较，最后把最大的值放在顶部，注意哦这里是局部顶部，因为对应的是该非叶子结点的一颗树。\n这时，我们知道了无非就是比较一个非叶子结点的左右子树与该结点的大小，然后选出一个最大的放在顶部嘛，但是具体一点该怎么操作呢？？看下去咯。。\n这里使用for循环来遍历其该结点的左右子树，for(int k = i * 2 + 1; k \u003c length; k = k * 2 + 1) 。k通过执行 k = i * 2 + 1之后，这是的k指向的是i结点的左子结点。然后比较其与右子树的大小arr[k] \u003c arr[k + 1]，这时我们将k指向较大的一颗子树即可，通过k++来实现，（因为右子树的下标比左子树大一）。这是我们已经选取了左右子树中较大的一个，然后将其与i结点所在的元素比较。然后子结点大于父结点arr[k] \u003e temp ，把较大的值赋给当前结点arr[i] arr[k]，别忘了还要将i指向ki = k ，继续循环比较；如果父结点最大，我们直接break即可。因为是从左至右，从下至上调整的，所以不会出现漏判的情况。当for循环结束后，已经将i为父结点的树的最大值，放在了最顶（局部）。这时我们还需要把temp临时保存的值放置到调整后的位置arr[i] = temp 。如此反复就能成功构建出一个大顶堆。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * 将一个数组（二叉树），调整成一个大顶堆 * 功能：完成将以i对应的非叶子结点的树，调整成大顶堆 * * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中的索引 * @param length 表示对应多少个元素进行调整，length是在逐渐的减少 */ public static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i];// 先取出当前元素的值，保存在临时变量  // 说明：k = i * 2 + 1 k是i结点的左子结点  for (int k = i * 2 + 1; k \u003c length; k = k * 2 + 1) { if (k + 1 \u003c length \u0026\u0026 arr[k] \u003c arr[k + 1]) { k++;// k指向右子结点  } if (arr[k] \u003e temp) {// 如果子结点大于父结点  arr[i] = arr[k];// 把较大的值赋给当前结点  i = k;// i指向k，继续循环比较  } else { break; } } // 当for循环结束后，已经将i为父结点的树的最大值，放在了最顶（局部）  arr[i] = temp;// 将temp值放到调整后的位置  }   2、堆排序的方法 根据上文提到的堆排序的思想有：\n①将无序序列构建成一个堆 1 2 3  for (int i = arr.length / 2 - 1; i \u003e= 0; i--) { adjustHeap(arr, i, arr.length); }   根据线索化二叉树可知，该树中非叶子结点的位置在arr.length / 2 - 1 的位置，调用adjustHeap(arr, i, arr.length); 即可。\n②将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端 ③重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整，直到整个序列有序 1 2 3 4 5 6 7  for (int j = arr.length - 1; j \u003e 0; j--) { // 交换  temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); }   在完成上述操作之后，我们也就有了一个完成的有序序列。\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 编写一个堆排序的方法  public static void heapSort(int[] arr) { int temp = 0; // 1、将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆  for (int i = arr.length / 2 - 1; i \u003e= 0; i--) { adjustHeap(arr, i, arr.length); } // 2、将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端  // 3、重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整，直到整个序列有序  for (int j = arr.length - 1; j \u003e 0; j--) { // 交换  temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } }    三、结束语 堆排序确实有点难度，但其本质还是以二叉树的形式存储的数组，如果有不理解的地方可以debug然后结合画图来理解，文字描述确实太难了。。。。\n源码地址 ——\u003e 堆排序\n","description":"","tags":null,"title":"排序——堆排序","uri":"/tech/datastructes/heapsort/"},{"categories":null,"content":"我与开源的那些事儿。  很幸运！！！是的，很幸运，除了幸运，我不知道该怎么形容我和 开源 的缘分。感觉就好像在冥冥之中，肯定会走上这条道路一样。\n 缘起 2020注定是特别的一年，年初，谁也没想到，一场疫情把我们牢牢的困在家里，哪也去不了。。说实话，或多或少有点抱怨吧。但伴随而来的，是一场灾难。那个时候每天一早醒来，看见手机屏幕刷新的数据，冰冷的可怕，红线一直在升。。。当时就在想，为什么我不是学医的，待在家里什么都做不了，似乎捐钱变成了最可悲的方式。\n偶然一次，在知乎上看见关于开发者抗疫的活动——“Wuhan2020”。本身就是学计算机专业的我，对于技术方面的文章也比较感兴趣，就随手点了进去。（ 其实当时内心所想的是，可能有是一个营销号在做文章 ）。在大致了解了Wuhan2020整个项目之后，便开始搜集更多的与之相关的信息。最后偶然在一个公众号中，看见了“黑客松活动”。就水群，进去了，，哈哈哈哈。但当时还是个技术小白，啥都不懂，可以理解成比会写“hello world“强那么一点点。在那之后，也找到了Wuhan2020的官方公众号。那时，想着尽自己的一份力，但是无论是对于开源文化上还是技术上都感到了很大的局限性，说俗点，大概就是心有余而力不足吧。随后大约在四月份（ 精确点是4月4号，因为那一天整个世界都是灰色的 ），看见了Wuhan2020公众号招人，我想了想自己对于做图剪视频之类的，还算是比较擅长的，就去试试水。进入了设计组。这也算是我第一次真正接触到开源吧。\n 幸运 说实话，除了幸运我不知道该怎么来形容这段经历。当时在设计组群里，几乎什么都没做，就发了一份作品＋自我介绍，然后有一位华师大的学姐，就加我为好友，说是带我一起和一位大佬做Apache相关的推广。哈？？Apache是什么？？当时的我是一脸问号。。。。然后就抱着试一试的心态跟着去了。。。（ 现在想想当时真的是有趣，如果我说我什么都不了解，甚至拒绝的话还会有现在的我么。。而且群里那么多人咋就单单选中了我呢，哈哈哈哈）然后和Apache的姜宁老师简单聊了一下，说到hugo啥的。我心里想hugo？？雨果还搞开源？？随后查了一下，是一款搭建静态博客的框架，这也是我正式使用github的起点吧，更新博客。学了点东西总要找点事情做的，要不然时间一长，不就那也记不住了，哈哈哈。\n慢慢的跟着学姐运营ALC-Beijing和Wuhan2020的公众号，也一起了解到更多有关开源的文化。习惯也由之前的天天逛CSDN、知乎变成Github、掘金之类的。成功搭建博客，给我学习新的知识也树立了信心。似乎一切都好了起来，那个时候武汉已经宣布解封。\n 当时接触开源之前，总感觉自己怀才不遇，明明会的不少，懂得知识也挺多的，为什么就还只是一个普普通通的大学生呢？？还是做不到出圈，每天混学分，做着毫无疑义的事情。但当皓月姐姐加我好友的那一刻开始，就感觉那份属于我的运气该来了，还撞的特别准。\n 随后也加入了开源社，慢慢认识了更多的小伙伴，一群人不认识也不了解，分布在各个地方，做着一件共同的事情，可能这就是我当时所理解的开源吧。\n 受阻 当时想着为一些顶级的开源项目做贡献，就开始学会主动去吸取知识，那种学习给我的感觉是由心而发的，主动的。如果问我那时为什么想参与开源，大概是开源本身就具有向善的属性，也认为那是一种体现自己价值的方式。\n当五月份学校宣布返校的时候，回头学校之后，就开始感觉自己有出圈的能力了，也有出圈的想法，可能是技术层面，学校没有需要学习的，也可能是真正意识到现在的自己可以做一些更有意义的事情了。就逐渐向周围的同学唠叨着自己接触开源的事情，很多人的情况和我一样，一开始都是一脸懵圈，但遗憾的是懵圈之后，就什么都没了。这就好比一个主动跳入坑里的人，很难再拉下一个人主动入坑。其实准确点来说，都感觉开源离自身太远。从学生角度来思考，学好文化课，在课余时间参加活动、比赛之类的，赚学分，才是本职工作。至于开源，第一是不了解（不直接和自己的利益挂钩），第二是技术层面达不到。可以发现github上面的顶级项目几乎大多数都不适合学生来做，而且更多的是面向求职者或者说是已经工作了的，这样一来，即使有一腔热血，但是也被挡在门外。（回头想想自己，能想到把blog部署到github上，这样一来，几乎就和github捆绑在一起了，也就是这样能有更多的机会接触更多的项目。）带着这样的问题，我就在思考如何才能让身边的人参与开源，其实参与开源也不一定是技术层面，是不是？？\nCOSCon‘20 期盼已久的开源年会终于来了，尤其是今年年会的主题——“开源向善“ 。这可能也是我接触到开源的初衷。当时去之前，就在脑子里构想了很多有关开源的问题，在自身深入了解开源之后，总感觉没有自己想的那么简单，说大点可以是一种哲学，甚至是一种信仰。这是开源带给我最直观的感受。\n年会现场，也可谓是大型的网友见面会，虽然每个人都不一样，学着不同的专业、不同的城市、不同的年龄段，但是却都可以在彼此身上找到各自的影子，有时候有些事确实挺奇妙的。在第二天，无论是和庄表伟老师的聊天学习，还是和王伟老师的沟通交流，都刷新了我对于开源的认识，就好像是打破之前的定义，更深入的思考，对，这次是思考，不再是了解。如果说皓月姐姐是我接触开源的引路人，这大概就是遇见了自己的伯乐。\n天下没有不散的宴席，虽然很不舍，但是离别是必然的，愿下次再遇见，那个时候的自己更优秀。\n","description":"","tags":null,"title":"我与开源的那些事儿","uri":"/life/coscon/"},{"categories":null,"content":"线索化二叉树 一、前言 1、问题引入 现如今我们在生活上都提倡节约环保，所以对于我们的所写的代码也不例外，能节省时间或空间，我们就应该去考虑节省。我们来思考一下二叉树的结构：\n二叉树的中序遍历结果为HDIBJEAFCG，可以得知A的前驱结点为E，后继结点为F。但是，这种关系的获得是建立在完成遍历后得到的，那么可不可以在建立二叉树时就记录下前驱后继的关系呢，那么在后续寻找前驱结点和后继结点时将大大提升效率。\n还有就是我们可以观察到，EFGHIJ等结点都存在空的指针域，这样的话会造成空间上的浪费，所以该如何做，才能有效的处理这些问题呢？？\n那也就是我们今天的重点内容—— 线索化二叉树 。\n2、线索化二叉树基本介绍  n个结点的二叉链表含有 n + 1 个空指针域。利用二叉链表中的空指针域存放指向该结点在某种遍历次序下的前驱和后继结点的指针，这种附加的指针称为“线索”； 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索化二叉树，根据线索性质不同，可以分为：前序线索二叉树、中序线索二叉树（ 我们这里使用中序进行讲解 ）以及后序线索二叉树三种； 一个结点的前一个结点，称为 前序结点 ； 一个结点的后一个结点，称为 后继结点 。  3、线索化规则 现将某结点的空指针域指向该结点的前驱后继，定义规则如下：\n 若结点的左子树为空，则该结点的做孩子指针指向其前驱结点；\n若结点的右子树为空，则该结点的右孩子指针指向其后继结点。\n 根据这个规则，我们将上图线索化之后，如下：\n图中黑色虚线为指向后继的线索，紫色虚线为指向前序的线索。可以看出通过线索化，即解决了空间浪费问题，又解决了前驱后继的记录问题。\n 二、算法实现 1、创建结点 既然我们需要实现线索化二叉树，所以需要先创建一个HeroNode类表示结点，包含的属性有：int no;// 表示编号 、String name;// 表示姓名、HeroNode left;// 表示左子结点，默认为null 、HeroNode right;// 表示右子结点，默认为null 。\n除了上述的基本变量之外，我们还要定义两个类型变量，用于判断指向的是左子树（右子树）还是前驱（后继）结点。我们在这里规定0表示指向树，1表示指向结点。\n定义好上述变量之后，还有就是相关的get以及set方法，外加一个toString方法用于显示信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  // 创建HeroNode结点 class HeroNode { private int no; private String name; private HeroNode left;// 默认为null  private HeroNode right;// 默认为null  /* 说明： 1、如果leftType == 0 表示指向的是左子树，如果1则表示是前驱结点 2、如果rightType == 0 表示指向的是右子树，如果1则表示指向后继结点 */ private int leftType; private int rightType; // 构造器  public HeroNode(int no, String name) { this.no = no; this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public int getLeftType() { return leftType; } public void setLeftType(int leftType) { this.leftType = leftType; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } public int getRightType() { return rightType; } public void setRightType(int rightType) { this.rightType = rightType; } @Override public String toString() { return \"HeroNode{\" + \" name='\" + name + '\\'' + \", no=\" + no + '}'; } }   2、实现线索化 为了实现线索化，我们首先需要创建一个指向当前结点的前驱结点的指针pre（默认为null），这样从而使得，在递归进行线索化的时候，pre总是保留前一个结点。以及定义一个根结点root。\n下面开始执行线索化方法体threadedNodes：先判断传入的结点是否为空，如果为空，则无法进行线索化；由于中序遍历的顺序为：左、中、右。所以我们按照这个顺序编写代码，使用递归的方式。\n①线索化左子树 ：threadedNodes(node.getLeft());\n②线索化当前结点 ：这个是重中之重，也是难点所在。先处理当前结点的前驱结点（ 先将当前结点的左指针设置为pre，然后再修改左指针的类型，指向前驱结点 ），接着处理后继结点（ 先将当前结点的右指针指向当前结点，然后再修改右指针的类型 ），在完成以上步骤之后，也就处理完成一个结点，然后让当前结点指向下一个结点的前驱结点 pre = node；\n③线索化右子树 ：threadedNodes(node.getRight()); 。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 定义ThreadedBinaryTree class ThreadedBinaryTree { private HeroNode root; // 为了实现线索化，需要创建要给指向当前结点的前驱结点的指针  // 在递归进行线索化时，pre总是保留前一个结点  private HeroNode pre = null; public void setRoot(HeroNode root) { this.root = root; } //重载threadNodes方法  public void threadedNodes() { this.threadedNodes(root); } public void threadedNodes(HeroNode node) { // 如果node == null 不能线索化  if (node == null) { return; } // （一）先线索化左子树  threadedNodes(node.getLeft()); // （二）线索化当前结点【难点】  // 处理当前结点的前驱结点  if (node.getLeft() == null) { // 当前结点的左指针  node.setLeft(pre); // 修改当前结点的左指针的类型，指向前驱结点  node.setLeftType(1); } // 处理后继结点  if (pre != null \u0026\u0026 pre.getRight() == null) { // 让前驱结点的右指针指向当前结点  pre.setRight(node); // 修改前驱结点的右指针类型  node.setRightType(1); } // ！！！每处理一个结点后。让当前结点指向下一个结点的前驱结点  pre = node; // （三）再线索化右子树  threadedNodes(node.getRight()); } }    三、结束语 从上面的分析我们可以看出，由于它充分利用空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着省了时间）。所以在实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前序和后继，那么采用线索化二叉树就是一个非常不错的选择咯！\n源码 ——\u003e线索化二叉树\n","description":"","tags":null,"title":"树——线索化二叉树","uri":"/tech/datastructes/threadedbinarytree/"},{"categories":null,"content":"大三了，二夕回来了？？ 转眼间，大学生活已经过去两年了，一切总感觉一切都还早，一切都不用那么着急，反正很多事情也不是着急的事。这学期临近开学，忽然不知怎么就有了一种无形的压迫感。这种压迫感似乎在怒斥着自己，你前两年都学了些什么？？ 仔细想想，好像什么都没有。。。。\n是的，什么都没有！代码写得还是一如既往的差劲，缺少能够独立思考的能力、做不到举一反三，一切的一切都只会按部就班。在台上依旧会紧张，更少了刚踏入大学门时的斗志。失败吧？？确实挺失败的。\n一开始一直想着考研，感觉打着考研的口号，就能贴上好学生的标签，就不会变得浑浑噩噩，但是环境的影响是必然的，因为自身所处的氛围，从而间接的决定了你所看到的上限。很多人，在大学阶段都在乎名利、奖学金啊之类的，说实话，当时我的也是。恨不得把所有的荣誉都贴在身上。随着时间的推移，慢慢接触了更多的大佬，了解到上一个层面，才知道这一切是多么可笑的事情。从我现在的自己看着两年前的自己，说成降维打击也不为过。当时忙来忙去的，说好听点叫做锻炼自己，实际上谁还不是为了那点可笑的学分呢？？学分有用嘛？？也许有吧，没用怎么才能拿奖学金呢？？那么问题来了，奖学金有用吗？？似乎没吧，能写到简历上吗？？搞笑的嘛？？所以现在回头来看，似乎才知道当时的自己做了许多毫无意义还徒添烦恼的事情。上了大学，很少有人为了学习烦心过，更多的在于这些组织关系的一些杂七杂八的事情，毫无意义且浪费时间。所以从大三开始，我要撕去前两年亲手为自己贴上的标签，做个简简单单的普通大学生。\n但是想撕标签，说的简单，做的时候还是顶着很大的压力，等于摧毁以前苦心营造出来的一个人设，再树立一个与之不同甚至相反的，周围人怎么看？？重新树立的我 还是我吗？？谁知道呢？？往下走就完事了。这也算是对于两年的自己一个交代。\n高三的高考失利，就注定在心里埋下考研的萌芽。当时看着各个高校的专业排名，最中意的是华东师范大学，其次是我喜欢上海这个城市。但是呢，上了大学之后，周围的人都在告诉你，像文达这种学校能考个安大就不错了。。。是呀，安大还是211呢，你稀罕嘛？？反正我可不想。随着最近的忧虑，我恍惚和当时的自己进行了一次对话。大政笑二夕多么的颓废，而二夕却在感叹当时的大政多么心高气傲。如果可以，我更想做回以前的自己。那个做出一点点成绩，就引以为傲的大政。那个血气方刚的中二少年。\n现在，我 回 来 了！！！先从目标开始，考研目标： 华东师范大学 ，说难听点，窝窝囊囊从中学到大学上的都是垃圾学校，考研再不翻身更待何时！！！ 我想把高三时候陪伴大政的一句话，送给现在的二夕： 我不去想是否能够成功，既然选择了远方，便只能风雨兼程。\n现在回答开头提出的问题：我回来了吗？？是的，一个全新的我回来了。\n","description":"","tags":null,"title":"我回来了？？","uri":"/life/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/"},{"categories":null,"content":"顺序存储二叉树遍历 一、前言 1、顺序存储二叉树的概念 ①基本说明 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即 数组可以转换成数。数也可以转换成数组 ，如下图：\n②要求  上图的二叉树的结点，要求以数组的方式来存放，arr = [1,2,3,4,5,6,7]； 要求在遍历数组arr时，仍然可以使用前序遍历、中序遍历和后序遍历的方式完成结点的遍历。  2、顺序存储二叉树的特点  顺序二叉树通常只考虑完全二叉树； 第n个元素的左子结点为 2*n + 1； 第n个元素的右子结点为 2*n + 2； 第n个元素的父结点为 (n - 1) / 2； n：表示二叉树中的第几个元素（按0开始编号如上图）。   二、算法实现 1、顺序存储二叉树的前序遍历 首先，我们需要判断所给的数组是否符合条件，如果 数组为空 则，无法完成遍历，并给出相关提示；接下来，我们就按照前序遍历的法则，先输出当前这个元素，再向左递归遍历，最后向右递归遍历即可。\n需要注意的是：在向左和向右遍历的时候需要先判断索引所在的位置，是否在数组之内，如果是数组之外，就无法完成遍历；其次就是需要注意递归时候开始的索引。根据顺序存储二叉树的特点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /** * 编写一个方法，实现顺序存储二叉树的前序遍历 * * @param index 数组的下标 */ public void preOrder(int index) { // 先判断数组是否为空  if (arr == null || arr.length == 0) { System.out.println(\"数组为空，无法完成相关遍历\"); } // 输出当前这个元素  System.out.println(arr[index]); // 向左递归遍历  if ((index * 2 + 1) \u003c arr.length) { preOrder(index * 2 + 1); } // 向右递归遍历  if ((index * 2 + 2) \u003c arr.length) { preOrder(2 * index + 2); } }   2、顺序存储二叉树的中序遍历 和前序遍历相类似，只不过在进行输出和递归时候的位置发生交换。先进行左递归，然后输出当前结点，最后向右递归遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 顺序存储二叉树的中序遍历  public void infixOrder(int index) { // 先判断数组是否为空  if (arr == null || arr.length == 0) { System.out.println(\"数组为空，无法完成相关遍历\"); } // 向左递归遍历  if ((index * 2 + 1) \u003c arr.length) { infixOrder(index * 2 + 1); } // 输出当前这个元素  System.out.println(arr[index]); // 向右递归遍历  if ((index * 2 + 2) \u003c arr.length) { infixOrder(index * 2 + 2); } }   3、顺序存储二叉树的中序遍历 和前序、中序遍历一样，顺序更改为：先向左递归遍历，然后向右递归遍历，最后输出当前结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 顺序存储二叉树的后序遍历  public void postOrder(int index) { // 先判断数组是否为空  if (arr == null || arr.length == 0) { System.out.println(\"数组为空，无法完成相关遍历\"); } // 向左递归遍历  if ((index * 2 + 1) \u003c arr.length) { postOrder(index * 2 + 1); } // 向右递归遍历  if ((index * 2 + 2) \u003c arr.length) { postOrder(index * 2 + 2); } // 输出当前这个元素  System.out.println(arr[index]); }    三、结束语 利用数组的顺序存储来实现二叉树，其遍历方法和普通的二叉树来说，并无差别需要注意的就是索引的起始位置。，牢记顺序存储二叉树的特点即可。\n源码 ——\u003e 顺序存储二叉树\n","description":"","tags":null,"title":"树——顺序存储二叉树遍历","uri":"/tech/datastructes/arraybinarytree/"},{"categories":null,"content":"二叉树查找以及删除结点 一、前言 在上一篇blog中，我们了解了有关二叉树遍历的实现方法，其实，二叉树还可以用于查找关键字，和遍历一样，同样分成前中后三种方法查找。\n本次内容除了介绍二叉树的遍历查找算法之外，考虑到由于篇幅不是很多，所以又增加了在二叉树中删除结点的方法。\n 二、算法实现 1、前序查找 思路：首先判断当前结点的关键字是否等于要查找的；如果是相等的，则返回当前结点，该结点，也就是我们所要查找的结点；如果不等， 则判断当前结点的左子结点是否为空 ，如果不为空，则递归前序查找；如果左递归前序查找，找到结点，则返回，否则继续判断，当前结点的右子结点是否为空，如果不为空，则继续向右递归前序查找。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /** * 前序遍历查找 * * @param no 查找no * @return 如果找到就返回该Node，如果没有找到返回null */ public HeroNode preOrderSearch(int no) { // 比较当前结点是不是  if (this.no == no) { return this; } // 1、判断当前结点的左子结点是否为空，如果不为空，则递归前序查找  // 2、如果做递归前序查找，找到结点，则返回  HeroNode resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } if (resNode != null) {// 说明左子树找到  return resNode; } // 3、左递归前序查找，找到结点，则返回，否则继续判断  // 4、当前结点的右子结点是否为空，如果不空，则继续向右递归前序查找  if (this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; }   2、中序查找 思路：判断当前结点的左子结点是否为空，如果不为空，则递归中序查找；如果找到，则返回。如果没有找到。就和当前结点比较，如果是则返回当前结点，否则继续进行右递归的中序查找；如果右递归中序查找，找到返回该结点，否则返回null。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 中序遍历查找  public HeroNode infixOrderSearch(int no) { // 判断当前结点的左子结点是否为空，如果不为空，则递归中序查找  HeroNode resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } if (resNode != null) { return resNode; } // 如果找到，则返回，如果没有找到就和当前结点比较，如果是则返回当前结点  if (this.no == no) { return this; } // 否则继续进行右递归的中序查找  if (this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; }   3、后序查找 思路：判读当前结点的左子结点是否为空，如果不为空，则递归后序查找；如果找到，就返回，如果没有找到，就判断当前结点的右子结点是否为空，如果不为空，则右递归进行后序查找，如果找到，就返回；否则 就和当前结点进行比较，如果是则返回该结点，否则返回null。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 后序遍历查找  public HeroNode postOrderSearch(int no) { HeroNode resNode = null; // 判断当前结点的左子结点是否为空，如果不为空，则递归后序查找  if (this.left != null) { resNode = this.left.postOrderSearch(no); } if (resNode != null) {// 说明左子树找到  return resNode; } // 如果左子树没有找到，则向右子树递归进行后序遍历查找  if (this.right != null) { resNode = this.right.preOrderSearch(no); } if (resNode != null) { return resNode; } // 如果左右子树都没有找到，就比较当前结点是不是  if (this.no == no) { return this; } return resNode; }   4、删除结点 分析：\n在删除之前，我们要思考一个问题，那就是所需要删除的结点时叶子结点还是非叶子结点，如果是叶子结点，则直接删除即可；对于非叶子结点我们在这里做如下处理：那就是删除连同该结点的一棵树。\n思路：\n①因为该二叉树是单向的，所以判断的是当前结点的子结点是否为需要删除的结点，而不是直接判断需要删除的当前结点（如果直接判断需要删除的当前结点，那么当指针指向该结点的时候，由于是单向的二叉树，则已经错过了删除的机会。）\n②如果当前结点的左子结点不为空，并且左子结点就是需要删除的结点，就将 this.left = null 并且返回（结束递归删除）；\n③如果当前结点的右子结点不为空，并且右子结点就是需要删除的结点，就将 this.right = null 并且返回（结束递归删除）；\n④如果第2和第3步没有删除结点，那么就需要向左子树进行递归删除；\n⑤如果第4步也没有删除结点，则应当向右子树进行递归删除。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public void delNode(int no) { if (this.left != null \u0026\u0026 this.left.no == no) { this.left = null; return; } if (this.right != null \u0026\u0026 this.right.no == no) { this.right = null; return; } if (this.left != null) { this.left.delNode(no); } if (this.right != null) { this.right.delNode(no); } }    三、结束语 利用递归来实现二叉树查找关键字，总体上来说，还是比较便于理解的。在查找的基础上新加了删除结点的方法。\n源码 ——\u003e 二叉树查找\n","description":"","tags":null,"title":"树——二叉树查找以及删除结点","uri":"/tech/datastructes/binarytreesearch/"},{"categories":null,"content":"遍历二叉树 一、前言 在上一篇blog中，我们了解了有关树的基础知识，特别的是重点介绍了一下二叉树。这里，我们就来探究一下关于二叉树的遍历方法。\n二叉树的遍历方法有三种，分别是：\n 前序遍历：先输出父结点，在遍历左子树和右子树； 中序遍历：先遍历左子树，再输出父结点，再遍历右子树； 后序遍历：先遍历左子树，再遍历左子树 ，再输出父结点。  小结：看输出父结点的顺序，就确定是前序，中序还是后序。\n 二、算法实现 1、前序遍历  先输出当前结点（初始的时候是根节点）； 如果左子结点不为空，则递归继续前序遍历； 如果右子结点不为空，则递归继续前序遍历。  代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 编写前序遍历的方法  public void preOrder() { System.out.println(this);// 先输出父结点  // 递归向左子树前序遍历  if (this.left != null) { this.left.preOrder(); } // 向右子树前序遍历  if (this.right != null) { this.right.preOrder(); } }   2、中序遍历  如果当前结点的左子结点不为空，则递归中序遍历； 输出当前结点； 如果当前结点的右子结点不为空，则递归中序遍历。  代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 中序遍历  public void infixOrder() { // 递归向左子树中序遍历  if (this.left != null) { this.left.infixOrder(); } // 输出父结点  System.out.println(this); // 递归向右子树中序遍历  if (this.right != null) { this.right.infixOrder(); } }   3、后序遍历  如果当前结点的左子结点不为空，则递归后序遍历； 如果当前节点的右子结点不为空，则递归中序遍历； 输出当前结点。  代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 后序遍历  public void postOrder() { if (this.left != null) { this.left.postOrder(); } if (this.right != null) { this.right.postOrder(); } System.out.println(this); }    三、结束语 其实遍历二叉树，可以进行利用递归和非递归两种方式来处理，我们这里使用的是递归的方式，个人感觉，在明白递归机制之后，递归实现更容易理解点吧。\n源码 ——\u003e二叉树\n","description":"","tags":null,"title":"树——二叉树遍历","uri":"/tech/datastructes/binarytree01/"},{"categories":null,"content":"可能自己就是天生比较丧的原因，当第一次僵尸的《网易云》就入了坑，这几天，听见了他的《淹没》，就开始单曲循环。\n其实，说到底，rapper也好，yoer也罢，都是小众文化，想要的到大众的认可，谈何容易。但往往就是这种小众的圈子，入圈的人更能找到共鸣，因为有些话，只有小众人才能明白。\n以下内容是根据歌词所想所写：\n 想去冒险，结果一直没有真正的去实践过。我也曾一个人做地铁坐公交到底站，带上耳机的惆怅感只有自己能懂。喝酒吗？？我不喝酒，喝酒伤身体，多喝点奶。有时自己的抑郁的时候，通常是手机开飞行模式，不想遭到任何事情打扰，关上房门，带上耳机，拿起悠悠，就进入另外一个世界了。\n你高考了没？？学习成绩怎么样啊？？对于自己的未来有想法嘛？？考不上大学是不是打算直接就去打工啊？？ 反正谁知道呢，走一步看一步就好。\n我是个yoer，但不是火力少年王那种，电视上面的都是基础招，都是垃圾，哎哟、好吧，其实大家玩的都差不多吧。反正你们也不懂，只是看看热闹罢了。玩的也就一般嘛 在圈子算低端吧。从来没指望这玩意能够赚钱，还不是因为自己喜欢啊。家里啊、家里人一开始最多认为我是三天的新鲜劲，过去就没了，支持嘛？？说不上吧，你想想你儿子整天玩个悠悠球，难不成你还供着他啊……至于现在，不反对就好。\n有时候，就很烦，玩悠悠球毕竟不是未来，鸡汤现在都烂大街咯，成功一定会来，就**放屁。我会不会坚持？？不知道，反正我没想过放弃。\n  凌晨的卧室它会变成汪洋 在每晚一点半准时的重逢\n手机屏散发出微弱的光芒 抵抗这无形中巨浪的重重\n连秒针都变得肆意而猖狂 嘲弄他理想的荒唐\n苦笑的祭奠那逝去的张扬 还有他已不知去向的从容\n我想做到给他们看见 我想成为他们口中特例\n我想做到给他们看见 吐出这口憋了无数年的恶气\n失魂落魄的那个人啊，这个世界又何曾让他选\n一开始就只有这一条路给他走，死不悔改的丧家犬\n暴风雨并不会让人绝望，杀人的不是狂风\n遍体鳞伤的人 绝不会倒在最艰苦的长征\n积压的情绪爆发后 突入其来的平静让人惊讶\n生的了结最可能出现在某个无限美的黄昏\n嘴里说我知道我明白我会照做，心里说死也不要\n他们总逼着你喝下去有一种名字叫为了你好的毒药\n成功竟然比存在本身还重要 他们指着那些伟人\n时至今日我发现哪里有人群 入眼处尽是鬼魂\n 愿世界没有歧视，小众文化forever！\n","description":"","tags":null,"title":"听姜云升——《反抗》","uri":"/life/%E5%90%AC%E5%A7%9C%E4%BA%91%E5%8D%87%E5%8F%8D%E6%8A%97/"},{"categories":null,"content":"树 一、树的相关概念 1、引入 之前我们所提到的数组也好、链表也罢，其实都是一对一的线性结构，但是在日常生活当中还存在许多一对多的非线性结构 —— “树”。\n 树（Tree） ：是n （n≥0）个结点的有限集。n=0时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根，root的结点；（2）当 n\u003e1时，其余结点可分为m（m\u003e0）个互相不相交的有限集T1、T2……Tm,其中每一个集合本身又是一棵树，并且称为根的子树。\n 如下图所示：\n2、树的结点 结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，上图中，数据元素 A 就是一个结点；\n父结点（双亲结点）、子结点和兄弟结点：对于上图中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。\n树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。上图中，结点A就是整棵树的根结点。\n树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。\n叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。例如上图中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。\n3、子树和空树 子树：如上图中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且结点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。\n 注意：单个结点也是一棵树，只不过根结点就是它本身。上图中，结点 K、L、F 等都是树，且都是整棵树的子树。\n 知道了子树的概念后，树也可以这样定义：树是由根结点和若干棵子树构成的。\n空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。\n补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，上图中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。\n4、结点的度和层次 对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，上图中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。\n一棵树的度是树内各结点的度的最大值。上图表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。\n结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于上图来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。\n一棵树的深度（高度）是树中结点所在的最大的层次。上图树的深度为 4。\n如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，上图中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。\n5、有序树和无序树 如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。\n在有序树中，一个结点最左边的子树称为\"第一个孩子\"，最右边的称为\"最后一个孩子\"。\n拿上图来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。\n6、森林 由 m（m \u003e= 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。\n前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：\nTree =（root,F）\n其中，root 表示树的根结点，F 表示由 m（m \u003e= 0）棵树组成的森林。\n 二、二叉树 在上文，我们简单的了解了一下关于树的基本内容，那么在以上的概念继续细化，也就得到了二叉树。\n 简单地理解，满足以下两个条件的树就是二叉树：   本身是有序树； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；   例如，下图a) 就是一棵二叉树，而图 b) 则不是。\n2、二叉树的性质 经过前人的总结，二叉树具有以下几个性质：\n 二叉树中，第 i 层最多有 2i-1 个结点。 如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。   性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。 同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2*n2+1。 两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。   3、满二叉树 二叉树还可以继续分类，衍生出满二叉树和完全二叉树。\n 如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。\n 满二叉树除了满足普通二叉树的性质，还具有以下性质：\n 满二叉树中第 i 层的节点数为 2n-1 个。 深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。 具有 n 个节点的满二叉树的深度为 log2(n+1)。  4、完全二叉树  如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n 上图 所示是一棵完全二叉树，图中由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。\n完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。\n⌊ log2n ⌋ 表示取小于 log2n 的最大整数。例如，⌊log2 4⌋ = 2，而 ⌊log2 5⌋ 结果也是 2。\n对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：\n 当 i\u003e1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点） 如果 2i\u003en（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2i 。 如果 2i+1\u003en ，则结点 i 肯定没有右孩子；否则右孩子是结点 2i+1 。  5、总结 本节介绍了什么是二叉树，以及二叉树的性质，同时还介绍了满二叉树和完全二叉树以及各自所特有的性质，初学者需理解并牢记这些性质，才能更熟练地使用二叉树解决实际问题。\n","description":"","tags":null,"title":"树及其相关概念","uri":"/tech/datastructes/abouttree/"},{"categories":null,"content":"哈希表 待更新……\n源码地址 ——\u003e 哈希表\n","description":"","tags":null,"title":"数据结构——哈希表","uri":"/tech/datastructes/hashtab/"},{"categories":null,"content":"源码测试案例失败，求助大佬！！！\nissue ——\u003e 斐波那契查找\n","description":"","tags":null,"title":"查找——斐波那契查找","uri":"/tech/datastructes/fibonaccisearch/"},{"categories":null,"content":"插值查找 一、前言 1、问题引入 在了解过折半查找 之后，可能有些人会有些疑问，为什么选择的是1/2，而不是 1/3 、1/4 呢？？或者说折更多呢？？\n举个例子，比如说我们在26个英文字母中寻找A，你还会选择折半么，从中间开始向左边部分进行递归？？还是直接从头开始查找、 在这种情况下，折半查找就显得不是那么的好用咯，还存在可以优化的地方。\n2、基本介绍 我们来看一下折半查找的中间值 mid = (left + right) / 2; 通过我们小学一年级学过的数学知识，可以得出 =\u003e mid = left + (right - left) / 2; 也就是mid等于最底下标left加上最高下标right与left差的一半。然后再次利用小学一年级的知识，对于这个 1/2 进行优化，得出 mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);\n将 1/2 改成 (findVal - arr[left]) / (arr[right] - arr[left]) 有什么好处呢？？假设arr[10] = {1, 2, 3, 4 ,5 6, 7, 8, 9}，则left = 0、right = 8、arr[left] = 1、arr[right] = 9。需要查找关键字1，代入上述公式可得 mid = 0，那么就说明只需要一次，感兴趣的可以自己使用折半查找计算一下， 从而可以发现在这种情况下，还是插值查找好使。\n 插值查找： 是根据要查找的关键字findVal与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的计算公式 (findVal - arr[left]) / (arr[right] - arr[left])。\n  二、算法实现 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * 说明：差债查找算法，也要求数组是有序的 * * @param arr 数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 查找值 * @return 如果找到，就返回对应的下标，如果没有找到就返回-1 */ public static int insertValueSearch(int[] arr, int left, int right, int findVal) { //注意：findVal \u003c arr[0] 和 findVal \u003e arr[arr.length - 1]必须需要，否则得到的mid可能会越界  if (left \u003e right || findVal \u003c arr[0] || findVal \u003e arr[arr.length - 1]) { return -1; } // 求出mid  int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal \u003e midVal) { return insertValueSearch(arr, mid + 1, right, findVal); } else if (findVal \u003c midVal) { return insertValueSearch(arr, left, mid - 1, findVal); } else { return mid; } }    三、结束语 插值查找一般适用于表长较大的，而且关键字分布又比较均匀的查找表来说，插值查找算法的平均性能是优于折半查找的，但如果是表长较小的情况、或者关键字分布不均与的情况，再使用插值查找或许就不是那么合适的了。\n源码 ——\u003e 插值查找\n","description":"","tags":null,"title":"查找——插值查找","uri":"/tech/datastructes/insertvaluesearch/"},{"categories":null,"content":"折半查找 一、前言 1、基本介绍 折半查找（BinarySearch）： 又称二分查找。它的前提是线性表的记录必须是关键码有效（通常从小到大有序），线性表必须采用顺序存储。\n基本思想 ：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。\n2、举栗子 现在有一个有序数组 {1，8，10，89，100，123}，假设我们需要寻找数字8这个数，步骤如下：\n  首先确定该数组的中间值的下标，即 mid = (left + right) / 2;\n  然后让需要查找的数findVal和arr[mid]比较；\n 1）findVal \u003e arr[mid] 说明要查找的数在mid的右边，因此需要递归的向右查找； 2）findVal \u003c arr[mid] 说明要查找的数在mid的左边，因此需要递归的向左查找； 3）findVal == arr[mid] 说明找到，就返回下标    3、思考 什么时候需要结束递归呢？？\n 找到就结束递归； 遍历完整个数组，仍然没有找到findVal，也需要结束递归，结束条件为： 左边的索引 大于 右边的索引，即 left \u003e right 。   二、算法实现 1、非递归实现 折半查找既可以使用递归，也可以使用非递归来实现，这里我们先来了解一下非递归。left表示左边的索引，初始位置为数组的第一个元素；right表示右边的索引，初始位置为数组的最后一个元素。然后利用while循环进行遍历。当左边的索引大于右边的索引的时候，表示查找结束，没有查找到关键字，则返回-1，否则，返回该元素所在的下标。\n中间值 mid初始值为 mid = (left + right) / 2; 若查找值比中值小，则最高下标调整到中位下标小一位；若查找值比中值大，则最高下标调整到中位下标大一位；依次类推。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 非递归实现折半查找  public static int binarySearch03(int[] arr, int left, int right, int findVal) { int mid = 0; int midVal = arr[mid]; while (left \u003c= right) { mid = (left + right) / 2; if (findVal \u003c midVal) { right = mid - 1; } else if (findVal \u003e midVal) { left = mid + 1; } else { return -1; } } return mid; }   2、递归实现 与非递归实现想类似，即根据关键字与中间值的大小，然后做出相应的判断，再分别向左或者向右进行递归。需要注意的是，要避免出现“死龟”的情况，也就是没有查找到所需要的关键字，但仍没有结束递归。因此，当左边的索引大于右边的索引时，即 left \u003e right表示递归完整个数组，需要结束递归。还有就是需要注意每次递归的起始位置的变化。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /** * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 需要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回-1 */ public static int binarySearch01(int[] arr, int left, int right, int findVal) { // 当 left \u003e right 时，说明递归完整个数组，但是没有找到  if (left \u003e right) { return -1; } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal \u003e midVal) {// 向右递归  return binarySearch01(arr, mid + 1, right, findVal); } else if (findVal \u003c midVal) {// 向左递归  return binarySearch01(arr, left, mid - 1, findVal); } else { return mid; } }   3、完善版折半查找 假设，需要查找的关键字，在数组中有多个相同数值时， 在上述两个方法中，都是查找到一个关键字就返回，如何才能够将所有的数值都查找到呢？？\n思路分析：\n 当查找到mid索引值时，先不要立刻返回； 向mid索引值的左边扫描，将所有满足元素的下标，加入到集合ArrayList； 向mid索引值的右边扫描，将所有满足元素的下标，加入到集合ArrayList； 最后将ArrayList返回即可。  代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  public static List\u003cInteger\u003e binarySearch02(int[] arr, int left, int right, int findVal) { if (left \u003e right) { return new ArrayList\u003cInteger\u003e(); } int mid = (right + left) / 2; int midVal = arr[mid]; if (findVal \u003e arr[mid]) { return binarySearch02(arr, mid + 1, right, findVal); } else if (findVal \u003c arr[mid]) { return binarySearch02(arr, left, mid - 1, findVal); } else { List\u003cInteger\u003e resIndexList = new ArrayList\u003c\u003e(); // 向mid索引值左边扫描，将所有满足元素的下标，加入到集合ArrayList中  int temp = mid - 1; while (true) { if (temp \u003c 0 || arr[temp] != findVal) {// 没有找到，退出  break; } // 否则，将temp放入到resIndexList中  resIndexList.add(temp); temp--;// temp左移  } resIndexList.add(mid); // 向mid索引值右边扫描，将所有满足元素的下标，加入到集合ArrayList中  temp = mid + 1; while (true) { if (temp \u003e arr.length - 1 || arr[temp] != findVal) { break; } resIndexList.add(temp); temp++;// temp右移  } return resIndexList; } }    三、结束语 折半查找的前提条件是需要有序顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。但是对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，就不建议使用咯。\n源码 ——\u003e 折半查找\n","description":"","tags":null,"title":"查找——折半查找","uri":"/tech/datastructes/binarysearch/"},{"categories":null,"content":"线性查找 一、前言 假设我们需要在一个毫无顺序摆放的书架上，寻找一本书。但是由于书籍并没有分类，因此我们要找书只能从头到尾一本一本的对照书名，进行查找，直到找到或者全部查找完为止。实际上，这一个过程就是我们今天所要讲的线性查找。\n 线性查找（Sequential Search） ：又叫顺序查找，是最基本的查找技术，它的查找过程是：从表中第一个（ 或最后一个 ）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果知道最后一个（ 或第一个 ）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。\n  二、算法实现 线性查找较为简单，我们直接从数组的第一个元素依次开始遍历，然后与需要查找的关键字进行比较相同即可，如果比较成功，返回该元素所在的下标；否则，返回-1，表示遍历完也没有查找到该关键字。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 这里实现的线性查找是找到一个满足条件的值，就返回  public static int seqSearch(int[] arr, int value) { // 线性查找是注意逐一比对，发现有相同值，就返回下标  for (int i = 0; i \u003c arr.length; i++) { if (arr[i] == value) { return i; } } return -1; }    三、结束语 阅读完代码，大致感觉上没有什么问题，但是呢，如果一个数组有多个相同的关键字呢，返回的就是第一个查找到的关键字，就结束了查找。 因此我们可以定义一个集合用于存放查找结果，然后遍历完整个数组即可。\n源码 ——\u003e 线性查找\n","description":"","tags":null,"title":"查找——线性查找","uri":"/tech/datastructes/seqsearch/"},{"categories":null,"content":"基数排序 一、前言 1、基本介绍  基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort），顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用； 基数排序是属于稳定性的排序，基数排序法的是效率高的 稳定性 排序法； 基数排序是桶排序的扩展； 基数排序是1887年赫尔曼·何乐礼发明的。实现如下：将整数按位数切割成不同的数字，然后按每个对应的位数进行分别比较。  2、基本思想 将所有待排序数值统一为同样数位长度（ 以最高位为主，位数短的数前面补零 ），然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数组就变成一个有序序列。\n3、图文说明 可能看到这里，大部分读者还是挺懵的，下面我们结合一个动态图来进行理解。\n因为这里所使用的数组元素都是两位数的，即个位和十位，首先先根据个位数的大小进行排序，依次放入对应的位置（ 也就是我们所讲的桶 ），然后根据放入的位置取出，然后再根据十位数的大小进行存放，这个顺序也就是排序之后的顺序。\n 二、算法实现 1、得到最高位数 根据基数排序的思想可知，是根据最大数的位数多少进行比较的，也就是说我们需要先找到最高位数，\n先假设最大数就是数组的第一个元素，然后使用for循环遍历整个数组，依次进行比较即可。然后再根据最大数，得到它是几位数，即可。\n1 2 3 4 5 6 7 8 9  // 得到数组中最大的数的位数  int max = arr[0];// 假设第一位数就是最大数  for (int i = 1; i \u003c arr.length; i++) { if (arr[i] \u003e max) { max = arr[i]; } } // 得到的最大数就是几位数  int maxLength = (max + \"\").length();   2、定义相关变量 我们需要一个二维数组，来表示10个桶，每个桶就是一个一维数组。这10个桶分别表示从0~9 这十个数，大小为待排序数组的大小（ 有可能会出现极端情况，即某个对应位数的数值是一样大的，就考虑取最大，也就是数组的大小 ）。int[][] bucket = new int[10][arr.length];\n再定义一个一维数组来记录各个桶的每次放入数据的个数，int[] bucketElementsCounts = new int[10];\n3、排序 ①放入对应的桶中 首先，我们要根据最大数的位数是多少进行排序，然后还要取出各个位数的对应的值，考虑使用for循环实现，同时增加一个变量n，表示步长，for(int i = 0, n = 1; i \u003c maxLength; i++, n *= 10) 再嵌套一个for循环用于取出元素，然后放入到对应的桶中。\n1 2 3 4 5 6 7  for (int j = 0; j \u003c arr.length; j++) { // 取出每个元素对应位的值  int digitOfElement = arr[j] / n % 10; // 放入对应的桶中  bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; }   bucket[] 数组 表示的意思如下：\n  比如：53和3 这两个数，所对应的就是bucket[3][2]表示的意思就是 个位数字为3的桶中有两个数；\n  其中digitOfElement对应的是3（个位数字），bucketElementCounts[digitOfElement]用于记录对应桶中的个数\n  ②按照桶进行排序 根据一维数组的下标依次取出数据，放入到原来的数组，int index = 0; 先定义一个index变量用作索引。然后依次遍历每个桶，如果桶中有数据，则取出放入到原数组中，注意index++，后移。每进行一轮操作之后，需要将bucketElementCounts[k]置空，以复用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //一维数组的下标依次取出数据，放入到原来的数组  int index = 0; //遍历每一个桶，并将桶中的数据放入到原数组  for (int k = 0; k \u003c bucketElementCounts.length; k++) { //如果桶中有数据，放入到原数组  if (bucketElementCounts[k] != 0) { //循环该桶即第k个桶（第k个一维数组），放入  for (int l = 0; l \u003c bucketElementCounts[k]; l++) { //取出元素放入到arr  arr[index] = bucket[k][l]; index++; } } //第i+1轮处理后，需要将每个bucketElementCounts[k] = 0  bucketElementCounts[k] = 0; }   4、完整版代码 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  // 基数排序方法  public static void radixSort(int[] arr) { // 得到数组中最大的数的位数  int max = arr[0];// 假设第一位数就是最大数  for (int i = 1; i \u003c arr.length; i++) { if (arr[i] \u003e max) { max = arr[i]; } } // 得到的最大数就是几位数  int maxLength = (max + \"\").length(); // 定义一个二维数组，表示10个桶，每个桶就是一个一维数组  /* 说明： 1、二维数组包含10个一维数组 2、为了防止在放入数的时候，数据溢出，则每个一维数组（桶），大小定位arr.length 3、基数排序是使用空间换时间的经典算法 */ int[][] bucket = new int[10][arr.length]; // 再定义一个一维数组来记录各个桶的每次放入的数据个数  int[] bucketElementCounts = new int[10]; for (int i = 0, n = 1; i \u003c maxLength; i++, n *= 10) { // 针对各个元素的对应位进行排序处理，第一次是个位，第二次是十位，以此类推  for (int j = 0; j \u003c arr.length; j++) { // 取出每个元素对应位的值  int digitOfElement = arr[j] / n % 10; // 放入对应的桶中  // 比如：53和3 这两个数，所对应的就是bucket[3][2] 表示的意思就是 个位数字为3的桶中有两个数  // 其中digitOfElement对应的是3（个位数字），bucketElementCounts[digitOfElement]用于记录对应桶中的个数  bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; } //按照这个桶的顺序（一维数组的下标依次取出数据，放入到原来的数组）  int index = 0; //遍历每一个桶，并将桶中的数据放入到原数组  for (int k = 0; k \u003c bucketElementCounts.length; k++) { //如果桶中有数据，放入到原数组  if (bucketElementCounts[k] != 0) { //循环该桶即第k个桶（第k个一维数组），放入  for (int l = 0; l \u003c bucketElementCounts[k]; l++) { //取出元素放入到arr  arr[index] = bucket[k][l]; index++; } } //第i+1轮处理后，需要将每个bucketElementCounts[k] = 0  bucketElementCounts[k] = 0; } } }    三、结束语 到这里，关于排序也就告一段落了，从我们最熟悉的冒泡排序到利用空间换取时间的基数排序，毫无疑问是先驱们对于算法的思考，我们虽然很难再设计出一种新的、高效率的算法，但是却可以做到在原算法的基础上，并对其进行改进。大家一起加油！！！\n源码 ——\u003e 基数排序\n","description":"","tags":null,"title":"排序——基数排序","uri":"/tech/datastructes/radixsort/"},{"categories":null,"content":"归并排序 一、前言 1、基本介绍 归并排序（MergeSort）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略 （分治法将问题分（divide）成一些小的问题然后递归求解，而治（conquer）的阶段则将分的阶段得到的个答案“修补”在一起，即分而治之。）\n将两个的有序数列合并成一个有序数列，我们称之为\"归并\"。 归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括\"从上往下\"和\"从下往上\"2种方式。\n  从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)\n  从上往下的归并排序：它与\"从下往上\"在排序上是反方向的。它基本包括3步： ① 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2; ② 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。 ③ 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。\n  如下图所示： 2、具体操作 归并算法的实质在于把一个复杂的序列进行分解从而可以局部击破，变得简单化，下面我们举栗子，进行操作一把。在把数组进行分割之后，紧接着要做的事情就是 治 ，这里我们取最后一步做图解，实际上的操作过程是每 分 一次，就要进行 治 的操作。\n①分合操作 我们假设有一个数组如下：int[] arr = {5,4,7,9,3,8,2,1}; 那么我们根据前面所了解的规则，对其进行分 。\n②“治“ 实现规则如下：首先把一个数组分成左右两个部分，然后还要有一个空的数组，用作中转。在左右数组的两个部分，两边各还需要一个指针，分别进行扫描待排序的原始数组。在扫描的同时，把左右两个部分得到的元素进行比较，哪个较小则移入中转数组（这里我们是升序，降序反之即可），然后被移入元素的数组的指针依次后移，进行比较。\n 二、算法实现 由具体的实现操作可知，我们需要两个方法，一个进行 分+合 的操作，另一个进行 治 的操作。\n1、“治”（合并）的方法 该方法用于对被分割之后的数组进行排序的操作。\n①定义相关变量 首先我们需要有传入的变量：int[] arr 待排序的原始数组； int rigth 左边有序序列的初始索引； int right 右边有序序列的初始索引；int mid 中间索引；int[] temp 做中转的数组；以上是我们需要通过方法体传入的变量。\n接下来对其相关变量进行初始化：int i = left; 初始化i，左边有序序列的初始索引；int j = right; 初始化j，右边有序序列的初始索引；int t = 0; 指向temp数组的当前索引。\n②初步处理左右序列 步骤如下：先把左右两边（有序）的数据按照排序规则填充到temp数组，直到左右两边的有序序列，有一边处理完毕为止。\n所以我们可以利用while循环来实现。循环的条件是有只要有一边扫描完毕，即i \u003c= mid \u0026\u0026 j \u003c= right 。\n具体的填充规则为：如果左边有序序列的当前元素，小于等于右边有序序列的当前元素，则将左边的当前元素，填充到temp数组，然后指针后移，反之亦然，将右边有序序列的当前元素，填充到temp数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  while (i \u003c= mid \u0026\u0026 j \u003c= right) { // 如果左边的有序序列的当前元素，相遇小于右边有序序列的当前元素  // 即 将左边的当前元素，填充到temp数组  // 然后 t++ i++ 后移  if (arr[i] \u003c arr[j]) { temp[t] = arr[i]; t++; i++; } else {// 反之，将右边有序序列的当前元素，填充到temp数组  temp[t] = arr[j]; t++; j++; } }   ③填充剩余数据 在上个步骤，我们了解到，只要有一边的数据全部处理完毕则结束循环，所以我们需要把剩余数据的一边的数据依次全部填充到temp。这时就需要对于左右两边分别进行扫描。\n1 2 3 4 5 6 7 8 9 10  while (i \u003c= mid) {// 处理左边有序序列的剩余数据  temp[t] = arr[i]; t++; i++; } while (j \u003c= right) {// 处理右边有序序列的剩余数据  temp[t] = arr[j]; t++; j++; }   ④拷贝数据 我们当前对于待排序数组的数据进行处理后，所有的数据都在temp数组中，我们还需要将其拷贝回原始的数组。这里我们需要注意的是：比昂不是每次都要拷贝所有！！！ 即每进行一次分治操作，就拷贝一次数据。\n从左到右，依次拷贝temp数组中的元素。\n1 2 3 4 5 6 7  t = 0; int tempLeft = left; while (tempLeft \u003c= right) { arr[tempLeft] = temp[t]; t++; tempLeft++; }   ⑤完整版代码 我们对于每一步进行可拆分说明，更有助于理解。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  /** * 合并的方法 * * @param arr 待排序的原始数组 * @param left 左边有序序列的初始索引 * @param right 右边有序序列的初始索引 * @param mid 中间索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int right, int mid, int[] temp) { int i = left;// 初始化i，左边有序序列的初始索引  int j = mid + 1;// 初始化j，右边有序序列的初始索引  int t = 0;// 指向temp数组的当前索引  /* （一） 先把左右两边（有序）的数据按照规则填充到temp数组 直到左右两边的有序序列，有一边处理完毕为止。 */ while (i \u003c= mid \u0026\u0026 j \u003c= right) { // 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素  // 即 将左边的当前元素，填充到temp数组  // 然后 t++ i++ 后移  if (arr[i] \u003c arr[j]) { temp[t] = arr[i]; t++; i++; } else {// 反之，将右边有序序列的当前元素，填充到temp数组  temp[t] = arr[j]; t++; j++; } } /* （二） 把有剩余数据的一边的数据依次全部填充到temp */ while (i \u003c= mid) {// 处理左边有序序列的剩余数据  temp[t] = arr[i]; t++; i++; } while (j \u003c= right) {// 处理右边有序序列的剩余数据  temp[t] = arr[j]; t++; j++; } /* （三） 将temp数组的元素拷贝到arr 注意：并不是每次都要拷贝所有！！！ */ t = 0; int tempLeft = left; while (tempLeft \u003c= right) { arr[tempLeft] = temp[t]; t++; tempLeft++; } }   2、分+合的方法 在编写完合并的方法之后，我们在此基础上进行分合操作。同样需要传入一些所需的相关变量如下：int[] arr 待排序的原始数组； int rigth 左边有序序列的初始索引； int right 右边有序序列的初始索引；int[] temp 做中转的数组；以上是我们需要通过方法体传入的变量。\n然后利用递归进行执行，执行的条件为left \u003c right 。分别向左右两个方向拆分，之后调用合并方法。需要注意的是每次拆分的左右指针的位置要选取正确。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 分+合的方法  public static void mergeSort(int[] arr, int left, int right, int[] temp) { if (left \u003c right) { int mid = (left + right) / 2;// 中间索引  // 向左递归进行分解  mergeSort(arr, left, mid, temp); // 向右递归进行分解  mergeSort(arr, mid + 1, right, temp); // 合并  merge(arr, left, right, mid, temp); } }    三、结束语 源码 ——\u003e 归并排序\n","description":"","tags":null,"title":"排序——归并排序","uri":"/tech/datastructes/mergesort/"},{"categories":null,"content":"致RIOT悠悠球协会全体成员的一封信、 社团名以及LOGO的由来 时间返回到一年前，也大约在这个时候，我可以确信我们的悠悠球社团能够成立，也大约在这个时候，想好了社团的名字，以及设计出社团的LOGO。还是想说说名字的来历吧，主要来源于我比较喜欢的一颗悠悠球 “start the riot” ；还有就是RIOT可以简单分成两部分来看：“RI” 其中R的词根的有再一次的意思，而”OT“呢？？这个可不是打游戏里面的OT，而是圈子里面提倡的一个概念”Original Throw“。因为大多数人，或多或少再小时候都接触过悠悠球，所以我希望的是当再一次接触到悠悠球，请不要再放下她。（ 还好学校里面的领导没文化，不知道riot其实是暴动、暴乱的意思，要不然说不定给我ban了，哈哈哈哈 ）\n至于社团的LOGO呢？？更偏向于街头涂鸦的那种感觉，给人的整体感觉也是比较青春有活力的。与传统的圆形或者中规中矩的方形所不同，甚至可以感觉到一点叛逆的味道在里面。。。\n为何创立？？ 为何创立社团？？以及有没有必要创立一个悠悠球社团？？ 其实这两个问题困惑了我许久。先谈谈第一个：悠悠球作为小众运动，对于绝大多数人而言，甚至还停留在儿时的玩具，只能够普普通通一上一下的简单操作，对于电视上出现的各种操作，更以为是特效。。。。。这个原因也是能说是其中的一点。想打破大家对于悠悠球的认识也是创立的一个主要原因。在刚上大学的时候，我就开始尝试着让更多人了解悠悠球，或者说入坑悠悠球，但是悠悠球相比于其他的玩物，上手难度比较大，因为是小众，文化基础不是很好。再加上需要付出时间和精力去练习等等诸多因素，从而导致更多的人都只是愿意看看。但是正是由于她的小众以及上手难度，这也是使得悠悠球更显得与众不同。在当时尝试推广之下，已经有了一定的群众基础，刚好赶上要举办元旦晚会，因此便和几位小伙伴上台表演了一番，虽然玩得都是基础招，对于许多没有真正了解过的人来说，这已经amazing了！！！是的，表演效果还是可以的。这也让我有了创办的信心。在2019年三月份，华东高校悠悠球联赛正式举办，当时因为一些原因，并没有去现场学习。但通过直播，仍然可以看见有许许多多的大学生对于悠悠球的热爱与执着，特别看见新手组的时候，对我而言感觉是最多的。在五一假期的时候，来到上海，参加了上海悠悠球聚会，起初我以为我是最差的，，但是看见很多意想不到的，有小朋友也有大叔，都是因为对于悠悠球的喜欢与热爱，我们得以相聚。玩悠悠球，玩得开心不就可以了，为什么想那么多呢？、如果创立社团可以让这份快乐延续和传播下去，岂不是更好？？从那时起，我就在心中埋下一颗种子，并尽力让其生根发芽。\n有必要吗？？或许正确的答案是没必要吧。创立社团对我自己而言更多的是徒增了许多烦恼（在实际的过程中也是如此）。但既然能够成立一个社团，又何必去管它有没有必要呢、、 干就完了！！\n为期一年？？ 实际上，在协会会长这个职位上，并没有满一年就下来了。。。\n起初，在刚成立的时候，还在幻想着，纳新能招多少多少人，以后举办什么什么活动之类的，理想总是美好的，实际证明这一切的幻想都是基于我自己对于悠悠球的喜欢，对于一个不冷不热的路人来说，我们更应该思考的是如何让他们对此感兴趣。。 所以说，不管是纳新还是举办活动，都比我预想的要差的很多，甚至在有一段时间，我就在想，社团还有必要继续运营下去吗？？这时，我想起《曾国藩》中的一句话：\n 打破牙和血吞！！！\n 哈哈哈，现在回头看来也没有那么严重，只不过是与心里的预期相差太多，有点接受不了，所以难免有点颓废。颓废过去，社团还是要经营的，最重要的每周的训练是必不可少的，只有在保证训练量的基础上，部员才能有所成长。就这样，新的一年即将到来，随之而来的还有元旦晚会，这也算是社团的一个隐藏起点吧。但是身份却发生了改变，相比较一年前，想在舞台上秀操作，那时更多的是想让协会的部员能够上台展示自己，这是社团的收获，也是你们的收获。和当时不变的还是，舞台肯定要炸，玩悠悠球不蹦迪，那不是在土嗨嘛？？（ 开个玩笑 ） 就这样，经过为期三个月的努力，社团可以呈现一个完整的舞台，足够了，是的。这既是对于社团部员的考核，也是对于我自己的一次检验，还好，不算太差。\n到了2020年，因为疫情原因，没能及时返校，部员的训练量也就落下了。回校之后，就在想，要不就这样吧？？反正接力棒就要交到下一届，到时候就与我无关了了了了、、、 内心还是挺纠结的。最后想了想，活动还是要办的，毕竟要为留下来的部员最大化的谋取福利，顺便可以培养下一届会长的办事能力。也算是对自己交个差吧。\n以上大概差不多就是这一年来经营社团方面的心态变化。接下来简单说一下个人的经验：\n 做好牺牲自己（时间和金钱），当选择成立一个社团或者留任的时候，那就代表着你要担负起属于自己的那一份责任； 要有适当的计划，可以是长远性的，也可以是目前的，比如说在纳新结束后，可以根据部员的时间合理安排每周的训练，再具体点就是每周训练的内容； 调动部员的积极性，相比较参与社团活动，可能大部分部员都会选择做自己的事情，因为在他们看来参与社团活动是为了社团的发展之类的，而往往牺牲的是他们自己的时间，长而久之，就慢慢会退出社团活动，这时作为会长就要结合实际情况，调动部员的积极性； 在比较活跃或者说表现比较积极的部员，要培养他们的归属感，从而可以他们有参与社团活动、留在社团之类的想法，产生良性循环； 认真重视自己的社团，比如在每次训练的时候，可以逐一私给部员私发信息，让部员意识到其重要性，如果作为会长自己都不重视，凭什么要求部员积极呢？？  谈谈收获。。 好像读到现在，整体给人的感觉是有点不太乐观的、甚至还是比较颓废的。但事情都是有两面性的。\n给我收获最大的莫过于看见部员的成长。从什么都不会，到可以玩出点东西；从内向腼腆，到敢于上台表演；从遭受别人的冷眼嘲笑，到慢慢有了掌声……\n记得当时纳新结束，有一个小部员，来找我练球，教他的时候，问他什么都不说，发球手还抖的噼里啪啦的，整个人就是特别内向，更别说在人群面前展示自己了，但是逐渐慢慢的，有了变化，在元旦晚会的时候，上台表演，听见来自台下观众的掌声，也可以肯定自己。这一切的变化，不能说都是来自于悠悠球，但是悠悠球在其中有不可或缺的因素。还有的部员说，我从小就双手不协调，不可能玩好的。但是我想说，只要你相信自己，并且听我的愿意花时间去练习，没有什么做不到的。是的， 只要坚持，结果总不会太差 。\n再说说我自己吧，因为把自己大部分时间都放在社团上，也就没了过多的时间抄招想招，每周都在想着教什么基础招，想必圈子里面很多的老前辈都知道基础招的重要性，从而就有了我现在的手感，这与教授部员基础招有着密不可分的关系。还有就是，心态被磨平了，做事情可以从更多的方面去思考问题，这些也全都是收获。\n 那么现在再想有必要创立社团嘛？？我的回答是：有的。我把社团的定位是传播悠悠球的正确玩法，而不是培养比赛型选手，如果可以向圈子里面输送新人也是更好。但就说传播悠悠球的玩法，我想我尽我自己的能力，做的还行吧。\n如果说社团最大的难题在哪？？莫过于 传承 。\n 我的故事到此为止\n没做好的 你来帮我完成\n永远保持热爱\n ","description":"","tags":null,"title":"关于RIOT悠悠球协会","uri":"/life/%E5%85%B3%E4%BA%8Eriot%E6%82%A0%E6%82%A0%E7%90%83%E5%8D%8F%E4%BC%9A/"},{"categories":null,"content":"快速排序 一、前言 1、基本介绍 见名知意，就是一种很快的排序方法。快速排序是基于冒泡排序的升级，那是因为它们都属于交换排序类。即它也是通过不断比较和移动交换次数来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减少了总的比较次数和移动交换次数。\n 基本思想： 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，整个排序过程可以递归进行，以达到整个序列有序的目的。\n 2、排序例图  二、算法实现 1、定义基本变量 首先，我们需要的有：传入待排序的数组int[] arr、左索引int left、右索引int right。\n在方法体内，我们需要有左下标：int l = left; 右下标：int r = right; 中轴值：int pivot = arr[(left + right) / 2]; （这里我们默认中轴值的基准为位于数组中间的元素） 最后还有一个临时变量int temp = 0; 用于交换。\n2、初步分组 这里我们利用while循环来说完成分组的规则，即把数组根据所选基准pivot的大小分成两个部分。while循环的条件为：左下标小于右小标 即l \u003c r。\n①遍历左部分 我们需要在pivot的左边部分一直寻找，直到找到一个元素的数值大于等于pivot值，才退出。\n1 2 3  while(arr[l] \u003c pivot) { l += 1; }   左下标的起始位置为：数组的第一个元素，所以每遍历一个元素需要后移一位。\n②遍历右部分 这时，需要在pivot的右边部分一直寻找，直到找到一个元素的数值小于等于pivot值，才退出。\n1 2 3  while(arr[r] \u003e pivot) { r -= 1; }   右下标的起始位置为：数组的最后一个元素，即arr.length - 1 ，所以每遍历一个元素需要前移一位。\n③结束循环 如果 l \u003e= r 说明pivot左边的值，已经全部是小于等于pivot值，右边全部是大于等于pivot值，这时需要结束循环。\n1 2 3  if(l \u003e= r) { break; }   ④交换 当完成②③的遍历的时候，分别在pivot左右两个部分找到了符合要求的元素，则可以开始执行交换，从而使得每个元素归位于所适合的位置。\n1 2 3 4  // 交换  temp = arr[l]; arr[l] = arr[r]; arr[r] = temp;   3、防止溢出 当我们完成交换的规则之后，接下来就需要保证防止出现栈溢出的情况，这一步也是为了在后面步骤进行左右递归做好前提条件，是必不可少的一步。\n1 2 3 4 5  // 如果 l == r ， 必须l++、r--，否则会出现栈溢出  if (l == r) { l += 1; r -= 1; }   4、递归 在完成上述所有的操作之后，下一步就是进行递归操作。这里需要注意的就是进行左右递归的条件以及起始位置是不同的。\n1 2 3 4 5 6 7 8  // 向左递归  if (left \u003c r) { quickSort(arr, left, r); } // 向右递归  if (right \u003e l) { quickSort(arr, l, right); }   5、完整版代码 因为整个快速排序流程较为复杂，所以对于方法体中的代码进行了拆分讲解，以下是快速排序方法体中的完整代码：\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  // 快速排序  public static void quickSort(int[] arr, int left, int right) { int l = left;// 左下标  int r = right;// 右下标  int pivot = arr[(left + right) / 2];// 中轴值  int temp = 0;// 临时变量  // while循环的目的是让比pivot值小放到左边，比pivot值大放到右边  while (l \u003c r) { // 在pivot的左边一直找，找到大于等于pivot值，才退出  while (arr[l] \u003c pivot) { l += 1; } // 在pivot的右边一直找，找到小于等于pivot值，才退出  while (arr[r] \u003e pivot) { r -= 1; } // 如果 l \u003e= r 说明pivot左边的值，已经全部是小于等于pivot值，右边全部是大于等于pivot值  if (l \u003e= r) { break; } // 交换  temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; // 如果交换完后，发现 arr[l] == pivot值相等，r-- 前移  if (arr[l] == pivot) { r -= 1; } // 如果交换完后，发现arr[r] == pivot值相等，l++ 后移  if (arr[r] == pivot) { l += 1; } } // 如果 l == r ， 必须l++、r--，否则会出现栈溢出  if (l == r) { l += 1; r -= 1; } // 向左递归  if (left \u003c r) { quickSort(arr, left, r); } // 向右递归  if (right \u003e l) { quickSort(arr, l, right); } }    三、结束语 源码 ——\u003e 快速排序\n","description":"","tags":null,"title":"排序——快速排序","uri":"/tech/datastructes/quicksort/"},{"categories":null,"content":"希尔排序 一、前言 1、简单插入排序存在的问题 我们看简单的插入排序可能存在的问题，如下：\n数组 int[] arr = {2,3,4,1} 这时需要插入的数1（最小），这样的过程是：\n{2,3,4,4} ——\u003e {2,3,3,4} ——\u003e {2,2,3,4} ——\u003e {1,2,3,4}\n所以我们可以得出如下结论：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。\n2、基本介绍 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n^2）的第一批算法之一。\n 基本思想： 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n 简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。\n我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。\n3、举栗子  二、算法实现 希尔排序的实质是对于直接插入排序进行改进，所以我们分为交换法和移位法两种。\n1、交换法 希尔排序的精髓，也是其关键点就是 对于增量的选择。我们这里使用当前数组的一半 当作增量。for(int gap = arr.length / 2; gap \u003e 0l; gap /= 2) 这样就对待排序的数组按照增量大小进行了分类。\n 将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。\n 选择好增量之后，需要做的就是对分好组之后的数组进行排序。交换法在这里进出处理使用的是双层for循环，外层循环用于遍历数组。内层循环根据增量大小，逐一对数组中的元素进行比较，从而进行排序。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 希尔排序，对有序序列在插入时直接使用交换法  public static void shellSort01(int[] arr) { int temp = 0;// 用于交换  // 第一层循环，将待排序数组进行分组  for (int gap = arr.length / 2; gap \u003e 0; gap /= 2) { // 第二层排序，从第gap个元素，逐个对其所在组进行直接插入排序操作  for (int i = gap; i \u003c arr.length; i++) { // 第三层循环，遍历各组中所有的元素（共gap组），步长为gap  for (int j = i - gap; j \u003e= 0; j -= gap) { // 如果当前元素大于加上步长后的那个元素，说明交换  if (arr[j] \u003e arr[j + gap]) { temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; } } } } }   通过阅读代码，我们不难发现，利用交换法实现希尔排序中使用了三层for循环，那是因为我们每发现一组增量就进行交换，这样下来，自然而然执行效率就低咯。针对出现的问题，做出优化，也就是接下来的移位法。（效率大幅度提升！！！）\n2、移位法 移位法的第一步也还是得首先确立增量，这也就是为什么说增量是希尔排序的精髓所在的原因。然后执行的操作就是直接插入排序的操作。\n注意：与之前提到的直接插入排序不同的在于，其移动的位置是根据增量大小而移动的，也就是gap。当退出while循环后，也就给待插入的元素找到指定位置，插入即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 对交换式的希尔排序进行优化 ——\u003e 移位法  public static void shellSort02(int[] arr) { // 增量gap，并逐步的缩小增量  for (int gap = arr.length / 2; gap \u003e 0; gap /= 2) { // 从第gap的个元素，逐个对其所在的组进行直接插入排序  for (int i = gap; i \u003c arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] \u003c arr[j - gap]) { while (j - gap \u003e= 0 \u0026\u0026 temp \u003c arr[j - gap]) { // 移动  arr[j] = arr[j - gap]; j -= gap; } // 当退出while后，就给temp找到插入的位置  arr[j] = temp; } } } }    3、结束语 源码 ——\u003e 希尔排序\n","description":"","tags":null,"title":"排序——希尔排序","uri":"/tech/datastructes/shellsort/"},{"categories":null,"content":"直接插入排序 一、前言 1、基本介绍 想必我们大家都玩过或者了解过斗地主，最基本的扑克玩法都是一边摸牌，一边理牌的。我们可以思考一下，理牌的顺序，是不是把大的牌直接插入在小的牌后面的呢？？例如有以下几张牌（不考虑花色）：6、4、5、3 。将4和5移动到6的左侧，再将3移动到最左侧，顺序就算是整理好了。这里我们所使用到的理牌方法就是直接插入排序。\n 直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。\n 插入排序的基本思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中含有 n - 1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序吗进行比较，将它插入到有序表中的适当的位置，使之成为新的有序表。\n2、举栗子 下面以数列{101,34,119,1}为例，\n排序流程：\n第1轮：i=0。交换34和101的位置， 34,101,119,1；\n第2轮：i=1。因为119比101数值大，所以该趟不做任何处理；\n第3轮：i=3。1依次与有序表中的数进行比较，直到找到合适的位置为止，也就是最终的顺序，1,34,101,119；\n 二、算法实现 因为我们使用一个有序表和一个无序表进行排序，所以默认数组的第一个元素为有序表，也就是for循环 的其实位置，for(int i = 1; i \u003c arr.length; i++) 所有的排序过程都需要在当前这个for循环中完成。此外，我们还需要定义int insertVal = arr[i]; 表示为待插入的数；int insertIndex = i - 1; 即待插入数的前面的这个数值的下标。\n接下来，我们使用while循环 给insertVal找到插入的位置。在执行循环的过程中，既要保证给insertVal找插入位置时，不越界 ；insertVal \u003e 0又要确保找到合适的插入位置 insertVal \u003c arr[insertIndex] 。然后将arr[insertVal] 后移，因为已将待插入的数arr[i] 保存到临时变量insertVal中，所以后移过程中不会覆盖，比如将举栗子的数列进行第一轮后移变成：{101,101,119,1}。然后再将insertIndex--; 如此可以保证有效地执行while循环。\n当退出while循环时，说明插入的位置找到，即 insertIndex + 1。然后需要做出判断是否需要赋值，即这个位置是否等于待插入数的下标，使用if选择语句即可完成。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 直接插入排序  public static void insertSort(int[] arr) { for (int i = 1; i \u003c arr.length; i++) { int insertVal = arr[i];// 定义待插入的数  int insertIndex = i - 1;// 即arr[i]的前面的这个数的下标  /* 给insertVal找到插入的位置 说明： 1、insertIndex \u003e= 0 保证在给insertVal找插入位置，不越界 2、insertVal \u003c arr[insertIndex] 待插入的数，还没有找到插入位置 3、需要将arr[insertIndex] 后移 */ while (insertIndex \u003e= 0 \u0026\u0026 insertVal \u003c arr[insertIndex]) { arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; } //当退出while循环时，说明插入的位置找到，insertIndex + 1  //判断是否需要赋值  if (insertIndex + 1 != i) { arr[insertIndex + 1] = insertVal; } } }    三、结束语 直接插入排序时间复杂度：直接插入排序的时间复杂度是O(n^2)。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(n)，需要遍历多少次呢？N-1！因此，直接插入排序的时间复杂度是O(n^2)。\n直接插入排序稳定性:直接插入排序是稳定的算法，它满足稳定算法的定义。算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n源码 ——\u003e 直接插入排序\n","description":"","tags":null,"title":"排序——直接插入排序","uri":"/tech/datastructes/insertsort/"},{"categories":null,"content":"选择排序 一、前言 1、基本介绍 选择排序（Selection sort）是一种简单直观的排序算法。它的基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n2、举栗子 下面以数列{20,40,30,10,60,50}为例，\n排序流程：\n第1轮：i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化：20,40,30,10,60,50 -- \u003e 10,40,30,20,60,50；\n第2轮：i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化：10,40,30,20,60,50 -- \u003e 10,20,30,40,60,50；\n第3轮：i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理；\n第4轮：i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理；\n第5轮：i=4。交换a[4]和a[5]的数据。 数列变化：10,20,30,40,60,50 -- \u003e 10,20,30,40,50,60\n3、说明  选择排序一共有 数组大小 - 1 轮排序 每一轮排序，又是一个循环，循环的规则：  先假定当前这个数是最小数 然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标 当遍历到数组的最后时，就得到本轮最小数和下标     二、算法实现 选择排序和冒泡排序一样，使用双重for循环进行实现。\n外层循环 for(int i = 0; i \u003c arr.length; i++) 用于确定排序的轮数，同时确定相关变量 minIndex = i; 最小值的下标，以及 最小值 min = arr[i]; 。然后定义内层循环 for(int j = i + 1; j \u003c arr.length; j++) 注意内层循环的起始位置是从i + 1 开始的（每执行完一轮排序，就确立一个最小值）。这时，在内层循环要筛选出最小值。当执行完内层循环之后，需要判断当前最小值的位置，是否在已排序数列的最后的位置。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public static void selectSort(int[] arr) { for (int i = 0; i \u003c arr.length; i++) { int minIndex = i; int min = arr[i]; for (int j = i + 1; j \u003c arr.length; j++) { if (min \u003e arr[j]) {// 说明假定的最小值不是最小  min = arr[j];// 重置min  minIndex = j;// 重置minIndex  } } // 将最小值，放在arr[i]，即交换  if (minIndex != i) { arr[minIndex] = arr[i]; arr[i] = min; } } }    三、结束语 从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况。其比较次数都是一样的多，第i趟排序需要进行 n - i 次关键字的比较，此时需要比较 n * (n - 1) / 2 次。而对于交换次数而言，当最好的时候，交换次数为0次，当最差的时候，也就初始降序的时候，交换次数为 n - 1 次，基于最终的排序时间是比较与交换次数的总和，因此，总的时间复杂度依然为O(n^2)。\n应该说，尽管与冒泡排序同为O(n^2) ，但简单选择排序的性能是要略优于冒泡排序。\n源码 ——\u003e 选择排序\n","description":"","tags":null,"title":"排序——选择排序","uri":"/tech/datastructes/selectsort/"},{"categories":null,"content":"冒泡排序 一、前言 回想起来，当时一开始接触编程的时候，在学完循环和数组之后，老师便给我们讲解了冒泡排序 ，老师还开玩笑说这种排序的算法最简单，相对而言也最容易理解。但对于当时的我们来说听得还是云里雾里的。\n 冒泡排序（Bubble Sort） 一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。\n 因为排序的过程（如果相邻的元素逆序就交换）就像是水中的气泡一样往上冒，因此得名叫做冒泡排序。下面举一个简单的栗子：\n原始数组：3，9，-1，10，20\n 第一趟排序：  1）3，9，-1，10，20 // 3和9比较，3比9小，位置不变\n2）3，-1，9，10，20 // 9和-1比较，发现逆序，交换位置\n3）3，-1，9，10，20 // 9和10比较，位置不变\n4）3，-1，9，10，20 // 10和20比较，从而确定第一趟排序下来最大的数20\n 第二趟排序：  1）-1，3，9，10，20 // 3和-1比较，发现逆序，交换位置\n2）-1，3，9，10，20 // 3和9比较，位置不变\n3）-1，3，9，10，20 // 9和10比较，从而确定第二趟排序下来最大的数10\n 第三趟排序：  1）-1，3，9，10，20 // -1和3比较，位置不变\n2）-1，3，9，10，20 // 3和9比较，从而确定第三趟排序下来最大的数9\n 第四趟排序：  1）-1，3，9，10，20 // -1和3比较，从而确定第四趟排序下来最大的数3\n小结：\n 一共进行 数组的大小 - 1 次 大的循环； 每一趟排序的次数在逐渐的减少。   二、算法实现 1、排序 冒泡排序的算法实现，并不难理解，我们使用双重for循环遍历即可。只不过需要注意的是每一次循环时候的条件。外层循环 for(int i = 0; i \u003c arr.length - 1; i++) 表示的是每一趟循环，所需要的次数就是数组大小-1 。而内层循环 for(int j = 0; j \u003c arr.length - i - 1; j++) 表示的是每一趟需要排序的元素的的个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 冒泡排序方法  public static void bubbleSort(int[] arr) { int temp = 0;// 临时变量  for (int i = 0; i \u003c arr.length - 1; i++) { for (int j = 0; j \u003c arr.length - i - 1; j++) { if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } }   2、优化 在使用冒泡排序的时候，我们不难发现，如果一串数字中有部分两两相邻的元素是顺序的，但是仍然执行 swap函数 的操作，这样一来极大程度上降低了排序的效率。针对以上出现的情况，我们做出如下的优化：\n增加一个布尔类型的变量flag 作为标识符，用于判断，当前的两两相邻的元素是否是按照顺序的，如果是就跳出，继续排查下一个元素，依次类推。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 冒泡排序方法  public static void bubbleSort(int[] arr) { boolean flag = false;// 标识符  int temp = 0;// 临时变量  for (int i = 0; i \u003c arr.length - 1; i++) { for (int j = 0; j \u003c arr.length - i - 1; j++) { if (arr[j] \u003e arr[j + 1]) { flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } if (!flag) {// 在一趟排序中，一次交换都没有发生过  break; } else { flag = false;// 重置flag进行下次判断  } } }    三、结束语 以上便是关于冒泡排序的基本内容了。如果还有描述不清或者是无法理解的，可以适当画图结合debug进行调试，细心点，坚持下去，总会有结果的。\n分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以判断出就是 n - 1 次的比较。没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表示逆序的情况，此时需要比较 n*(n - 1) / 2 次，并作等数量级的记录移动。因此，总的时间复杂度为O(n^2)。\n源码 ——\u003e BubbleSort\n","description":"","tags":null,"title":"排序——冒泡排序","uri":"/tech/datastructes/bubblesort/"},{"categories":null,"content":"说起 《三体》 ，想必大家并不陌生，大约从初中就听说过这套书，但很遗憾的是，当时的我并不喜欢读书，直到现在，也就是大二的时候才读完。但庆幸的是，有些书幸好没有那么早的草草地过一遍，要不书中想表达的含义，在当时的经历与心境来说是无法理解和体会的。\n 地球生命真的是宇宙中偶然里的偶然，宇宙是个空荡荡的大宫殿，人类是这宫殿中唯一的一只小蚂蚁。这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉人就老了……\n 这是《三体1》当中叶文洁，对伪主人公汪淼所说的一段话，也是全书中我比较喜欢的一段话。读完书之后，在翻阅之前做的笔记的时候，看到这段。不得不佩服大刘的思维，在读第一本的时候，可能会觉得这只是叶文洁的感叹。但通读全书之后，何尝又不是每个读者心里发出的一声叹息呢。。从宏观的角度来看，与浩渺的宇宙相比，人类确实只是一粒尘埃。但同时，人类是幸运的，生活在地球上。可悲的是，人类本身却不知道爱惜这块土地。\n反观叶文洁，为何要给三体人发信息呢？？甚至不惜犯了反人类罪。当从汪淼的视角，第一次看见叶文洁的时候，不免觉得这样一位老太太有点可怜，失去了自己的女儿，看着她那照看小区里邻居家小孩的样子，哪能想得到是ETO的统帅。。 但结合叶文洁的遭遇，也不难发现，她之所以决定把三体人引来都是有原因的，甚至不惜牺牲丈夫的生命，是人类一次又一次的做出违反道德底线的事情，在文革那个特殊时期，国将不国，人成非人。从而给叶文洁的心中埋下不相信人类的种子，当来到红岸基地之后，凭借自己的技术和手段，在收到三体人的警告：“不要回答！不要回答！不要回答！” 但她还是毫不犹豫地发送信息，暴露出地球的坐标，也就有了三体以后的故事。\n全书中，我最喜欢的角色是：章北海 ；最欣赏的应该是： 维德 。一个是要多想，一个是前进，不择手段的前进！之前，在还没读《三体》之前，隐隐约约看了点书评之类的，知道章北海是一个坚定的失败主义者，那时候就在想，既然是一个失败主义者，为何还有那么多人粉他呢？？不是应该被批评的嘛？？所以一开始对于章北海并没有什么太好的印象，甚至还有点反感。。。。在读到的《黑暗森林》的时候，面对三体人的来临，几乎所有人都慌张失措的时候，联合国更因此，制定了反人类的面壁计划。在这个条件下，反观章北海，没有面壁者的权利有义务，却成为了一个合格的民间面壁者。当大刘写到他问自己的父亲，下一步该怎么做的时候，父亲告诉他：“北海，我只能告诉你那以前要多想”。设想一下，如果我们自己在当时的环境下，我们该如何去做？？更多的可能是崩溃，但他没有。知道人类的特性都明白，逃亡主义是不可能实现的，但面对敌我实力的悬殊，也唯有逃亡，才能为人类文明的延续留下火种，尽管流浪在宇宙中的新人类，已经成为非人。但是毫无疑问，他是成功的，也完成了自己的任务。再来看看看维德，第一反应是这个人未免有点太讨厌了，喜欢欣赏人绝望的时候，就凭这一点就很恶心，是不是。。但是慢慢读下去，发现他是一个彻底的功利主义者，更说出了很多金句，比如： 失去人性，失去很多，失去兽性，失去一切 。但是欣赏归欣赏，要是在现实生活中，要这么一个人，肯定是不愿意和他做朋友的，太危险了，得绕的远远的，哈哈哈~\n简单的说一下阅读感受，在读第一部的时候，能感觉到这本书的格局之大，也被大刘的一些科幻创意点子所惊呆，尤其是在说冯诺依曼用大量的士兵给秦始皇展示计算机模型的时候，绝对的是一大亮点，还有就是从工具人汪淼的视角，来揭开三体人，让人感觉不太像是科幻小说，更有点的侦探悬疑的感觉。再看第二部，主人公罗辑从一个混日子的大学教授，被指定为面壁者，从而慢慢经历在书的末尾与三体人正面对决，可谓惊叹，对于罗辑的心路历程，再看看年少时候到我们。反观第三部，程心被喷圣母biao，但是她做错了什么嘛、是人类选择了程心，在那个时代的人类，可怜更可笑，盲目地自大，所以选择程心是理所当然。在读到书的结尾的时候，被大刘一个接着一个抛出的科幻点子所惊艳，有一种喘不过气的感觉。但又有点急急促促的感觉。\n读科幻小说给我的最大感受，就是每次读的时候都把自己的思想扩展到宏观层面，感觉眼前的所有烦心事，在整个人类文明面前都是不值一提的，可以把问题思考的更深入点，就想到既然文明可以一直延续下去，那么该如何让自己更有意义，成为文明的一部分呢？？我得出的答案是，那就是做些有意义的事情，什么事情是有意义的呢？？放下小了说，就是活好当下。。。\n","description":"","tags":null,"title":"读后感——《三体》","uri":"/life/threebody/"},{"categories":null,"content":"八皇后问题 一、前言 1、问题描述 八皇后问题（英文：Eight queens），是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出的问题，是递归回溯的典型案例。\n 问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以编程解决此问题。\n 2、思路分析 我们的主要思路是通过一行一行的放置皇后，来使得每一行都有一个皇后。当然，这些皇后在放置时都必须要满足规定的要求才行。\n因此就会出先如下情况:  放置时不符合规则，继续检索同一行的下一列位置是否合理 如果符合规则就将其放置，然后进行下一行的尝试（递归） 如果有某一行没有可行的解，则退回上一行，消除上一行摆放的皇后，检索剩余的列，看是否有合理的位置，然后继续进行。(回溯) 直到所有的行都被放置为止。  具体操作： 1)第一个皇后先放第一行第一列;\n2)第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适；\n3)继续第三个皇后，还是第一列、第二列......直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解；\n4)当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到；\n5)然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤。\n注意条件： 需要注意的是，我们在放置皇后时需要检测其防止和理性的判断条件为:\n 同一列的上方所有行中是否有皇后 左上方对角线上是否有皇后 右上方对角线上是否有皇后  说明： 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.arr[8]={0,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后，arr[i]=val,val表示第i+1个皇后，放在第i+1行的第val+1列\n 二、算法实现 1、定义相关变量 int max = 8; 定义max变量用于表示有多少个皇后；\nint[] array = new int[max]; 定义数组array，保存皇后放置位置的结果。\n2、输出皇后位置 因为我们使用的是一维数组，所以直接遍历输出该数组即可。\n代码实现如下：\n1 2 3 4 5 6 7  // 输出皇后摆放的位置  private void print() { for (int value : array) { System.out.print(value + \" \"); } System.out.println();// 换行  }   3、检查冲突 该方法用于 查看放置第n个皇后，检测该皇后是否和前面已经摆放的皇后冲突。这里我们使用一个boolean类型 的方法用于判定。如果不冲突就返回true ，否则返回false 。这里我们传入一个n表示是第几个皇后，如果n = 1，就表示是第一个皇后，需要检查的冲突也就是其本身；如果n = 2，表示是第二个皇后，需要检查的冲突是和第一个皇后的冲突，以此类推……所以可以使用for循环遍历，从第一个皇后开始，直到遍历到其本身为止。for(int i = 0; i \u003c n; i++)\n那么判断是否冲突需要遵守的规则是：同一行、列以及对角线不能有皇后。由于我们是使用一维数组来存储皇后摆放的位置，所以就不用判断放置的两个皇后是否在同一行的情况咯。array[i] == array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一列；Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * @param n 表示第n个皇后 * @return 如果不冲突返回true，否则返回false */ private boolean judge(int n) { for (int i = 0; i \u003c n; i++) { /* 说明： 1、array[i] == array[n] 示判断第n个皇后是否和前面的n-1个皇后在同一列 2、Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线 */ if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) { return false; } } return true; }   4、放置皇后 我们传入一个变量n表示放置第n个皇后，当n == max 表示8个皇后已经全部放置完毕，直接打印输出即可，并使用return; 语句跳出方法体。\n然后我们利用for循环依次放入皇后for(int i = 0; i \u003c max; i++)，首先把当前的这个皇后n放入到第1列，然后判断是否冲突，如果不冲突执行check(n + 1); 也就是开始放置下一个皇后；如果冲突，则就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 方法：放置第n个皇后  // 特别注意：check是每一次递归时，进入到check中都有for(int i = 0; i \u003c max; i++)，因此会有回溯  private void check(int n) { if (n == max) {// n = 8 时，表示8个皇后已经全部安放好  print(); return; } // 依次放入皇后，并判断是否冲突  for (int i = 0; i \u003c max; i++) { // 先把当前和这做个皇后n，放到该行的第1列  array[n] = i; // 判断当放置第n个皇后到i列时，是否冲突  if (judge(n)) {// 不冲突  check(n + 1); } //如果冲突，就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置  } }    三、结束语 以上便是关于八皇后问题的简单描述，理解起来可能有些许困难，比如为什么使用一维数组存放数据，如何检查冲突以及整个放置过程中的回溯都是值得动脑筋思考的。\n源码 ——\u003eQueue8\n","description":"","tags":null,"title":"递归应用——八皇后","uri":"/tech/datastructes/8queen/"},{"categories":null,"content":"今天想说说 关于知足 、 大家经常说“知足常乐”，但对于知足却没有一个明确的定义。\n 语出《道德经》。认为“祸莫大于不知足”，不知满足，进而追求，定招灾祸。知其足，不追求，安于所得，无为无德，反而常常满足。知足才能避免灾祸，才能全生保身。\n 今天我为数不多的一位朋友，遇到了点烦心事，和我唠嗑。然后我对她说“知足就好。” 她说：“ 我太喜欢这个词了，知足常乐”\n但怎么说呢、知足是个好词，每个人都渴望知足，但是从我的角度来说：其实我想要的是比知足多一丢丢，这样才能因为知不足，而保持学习。 知足确实是挺好的，但是人在成长的过程中，往往会由于自己的贪婪或者说是欲望，而不断提高对于自己的要求。当自己的要求更高、更严，从而可以在一定程度上促使自己变得更好、站得更高，那么在那个时候的自己，可能就会变得不那么知足，甚至有点贪得无厌。其实我感觉这些都是人之常情，如果所有人都安于泛泛而谈的知足，那么又有谁来推动社会的进步呢？？\n其实这种想法也是不对的，把贪婪说成知足，把知足说成安逸。我所理解的知足，是一种享受状态，是在于知道自己想得到什么之后，不用多想其他的什么，是完成目标之后的，有点小小的满足，甚至是骄傲的感觉，似乎整个世界都没有烦心事了，又好似整个世界的事情都与自己无关，可以安安稳稳地去做自己想做的事情，没有为了目标而去努力的劳累感。就这样，一切都安静了。。\n事实证明，知足状态下的我，可能会变得一塌糊涂，如果再这种状态下去，甚至会变得一无是处。在暑期，当忙完了所有要紧的事情的时候，当时的我已经精力交瘁，也有一种“知足”的感觉。因为感觉所有的事情都结束了，似乎可以让自己好好休息一段时间咯。当时理想的状态就是：每天写写代码，看看书，练练球，再学点额外的技能之类的。但是这几样，几乎没有一件事情是完成了的。这就是因为人的惰性，人只会着急与眼前的事情，很难去保证或者说坚持一些有意义的事情，让自己可以变得更优秀。\n等等，写到这里，我不由得想到，前面所说的我想要的是比知足多一丢丢 。这似乎就进入了一个死循环当中，每当处理完一些事情（￥%#\u0026噼里啪啦、乱七八糟之类的事），就会进入短暂的休息期，这个期间的自己是不想做任何事的，或者说不想做任何要动脑、动体力的事情，在这个状态下去，就会想是不是因为自己最近的不努力、懈怠，从而导致自己没有进步，与别人的差距又拉开了？？然后就感觉自己不再知足…… 长此以往下去，似乎会让自己变得更累，总感觉自己没有丝毫喘气的机会。。。\n那么问题来了？？究竟什么样的状态才是知足呢？？就如同五月天在歌词中写到：\n 天上的星星笑地上的人，总是不能懂不能觉得足够。\n ","description":"","tags":null,"title":"谈谈知足","uri":"/life/%E7%9F%A5%E8%B6%B3/"},{"categories":null,"content":"迷宫问题 一、前言 在上一篇博客中，我们了解了关于递归的一些基本知识，这次我们讲一下递归的应用——走迷宫。\n我们利用二维数组构建一个迷宫，其中1表示墙，0表示可以的走的路，2表示走过的路。 可以在迷宫中设置挡板，也用1表示。然后利用递归给小球找路。在走迷宫时，我们需要确定一个策略，不能盲目地瞎走，要不然岂不是在里面绕圈圈，哈哈哈哈。策略如下：下-\u003e右-\u003e上-\u003e左，如果该点走不通，再回溯。下面我们开始代码实现一把。\n 二、算法实现 1、创建迷宫 我们先定义一个二维数组map 表示地图。然后再分别将四周（上下左右）设置为墙。再在需要的位置设置挡板，增加出迷宫的难度。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 先创建一个二维数组，模拟迷宫  int[][] map = new int[8][7]; // 使用1表示墙  // 将上下全部置为1  for (int i = 0; i \u003c 7; i++) { map[0][i] = 1; map[7][i] = 1; } // 将左右全部置为1  for (int i = 0; i \u003c 8; i++) { map[i][0] = 1; map[i][6] = 1; } // 设置挡板  map[3][1] = 1; map[3][2] = 1;   2、递归找路 这里我们使用递归setWay(int[][] map, int i, intj)方法，来寻找路线。map 表示地图、传入的i, j 表示小球的起始位置；将终点设置为map[6][5] （除去墙在地图中所占的位置）。如果小球你找到通路，就返回true ，否则返回false 。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true，否则返回false */ public static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) {// 如果当前这点还没有走过  // 按照策略 下 -\u003e 右 -\u003e 上 -\u003e 左 走  map[i][j] = 2;// 假定该点可以走通  if (setWay(map, i + 1, j)) {// 向下走  return true; } else if (setWay(map, i, j + 1)) {// 向右走  return true; } else if (setWay(map, i - 1, j)) {// 向上走  return true; } else if (setWay(map, i, j - 1)) {// 向左走  return true; } else { // 说明该点是走不通，是死路  map[i][j] = 3; return false; } } else {// 如果map[i][j] != 0 可能是1、2、3  return false; } } }    三、结束语 对于迷宫的问题的描述就到这里，总体而言是比较简单的。具体的递归过程可以进行debug一下，更有助于理解。\n源码 ——\u003eMiGong\n","description":"","tags":null,"title":"递归——解决迷宫问题","uri":"/tech/datastructes/migong/"},{"categories":null,"content":"TwoSum 一、题目概述  给定一个整数数组 nums 和一个目标值 target ，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n 示例：\n给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  二、解法分析 对于这个题目想必大家并不陌生，可以说是绝大多数人的开始刷题之路的敲门砖。如果是一开始起初接触刷题的朋友，看到这题，可能没有思路，也可能是暴力解法 ，对于我自己就是使用双重for循环遍历暴力解，：）\n下面将使用双重for循环和HashMap两种解法供大家参考：\n1、暴力解法 我们首先来简单的分析一下题目：需要从nums数组中寻找两个数，使这两个数的和等于目标值target，并且数组中同一元素不能使用两次。所以我们可以使用for循环来寻找，外层循环的条件是for(int i = 0; i \u003c nums.length; i++) 即从数组的第一个下标开始遍历，直到遍历到数组结束；内层循环的条件是for(int j = i + 1; j \u003c nums.length; j++) 注意内层循环开始的条件不是从数组的第一个下标开始的，而是从nums[i] 的下一个位置开始遍历，结束条件相同。\n就这样，咱们使用双重for循环如此暴力的遍历，直到遇见了符合nums[i] + nums[j] == target  条件时，返回数组对应的下标即可；如果遍历结束之后，仍然没有在该数组中找到需要的数，则抛出异常。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 使用for循环遍历 暴力解题  public int[] twoSum02(int[] nums, int target) { for (int i = 0; i \u003c nums.length; i++) { for (int j = i + 1; j \u003c nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } throw new IllegalArgumentException(\"Two Sum No Solution\"); }   2、HashMap解法 对于哈希表这种数据结构，这里就不做具体的说明，想要了解的小伙伴可以自己查阅一下相关文档。\n我们先定义一个数组res[] 用于存放最后返回的结果。然后再创建一个哈希表，HashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); 然后对于这个数组进行遍历，每次遍历的时候取出一个数，然后再map 中查询，是否能找到一个合适的数，使两者之和等于目标值target ，如果找到直接返回即可；否则，将该数加入map 。依次进行遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 使用HashMap来解决该问题  public int[] twoSum01(int[] nums, int target) { int[] res = new int[2];// 存放返回的结果  if (nums == null || nums.length \u003c= 1) {// 判断传入的数组是否符合条件  return res; } HashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e();// 创建哈希表  for (int i = 0; i \u003c nums.length; i++) { int num = nums[i]; int val = target - num; if (map.containsKey(val)) {// 在map中寻找  res[0] = map.get(val); res[1] = i; return res; } else { map.put(num, i); } } return res; }    3、结束语 这个也算是开的一个新坑吧，虽然数据结构篇还没有完结。。。。刷题，几乎是一个程序猿的必经之路。大家一起加油！！！\n源码地址 —\u003e TwoSum\n","description":"","tags":null,"title":"TwoSum","uri":"/leetcode/twosum/"},{"categories":null,"content":"关于递归 一、前言 说起递归，可能有些同学会问，什么是递归啊？？ 我们举个简单的栗子：如果你站在镜子前面，这时你会在镜子中看见自己的像，称这个镜子为A；那么有没有试一下在手里也拿一面镜子，把手里的镜子称为镜子B，然后将A、B两面镜子互相面对面放着，你再往中间那么一站，神奇的情况发生了，将会发现两面镜子中都有你的“化身”。为什么会出现这种现象呢？？原来，A镜子里有B镜子的像，B镜子里也有A镜子的像，这样反反复复，就会产生一连串的“像中像”。这其实就是一种递归现象。\n说简单点，就是递归就是方法自己调用自己，每次调用时传入不同的变量。（递归有助于开发者解决复杂的问题，同时可以让代码变得更简洁）\n 二、递归规则 递归需要遵守的重要规则：\n1）执行一个方法时，就创建一个新的受保护的独立空间（栈空间）；\n2）方法的局部变量是独立的，不会相互影响，比如n变量；\n3）如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据；\n4）递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了 : ) ；\n5）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时方法执行完毕或者返回时，该方法也就执行完毕了。\n 三、斐波那契数列 1、概要 **斐波那契数列（Fibonacci）**是一个典型的递归例子，说如果兔子在出生两个月之后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有的兔子都不死。那么，一年以后可以繁殖多少对兔子？？\n我们拿新出生的一对小兔子来分析一下：第一个月的小兔子是没有繁殖能力的，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月后，老兔子又生下一对，因为上个月出生的小兔子还没有繁殖能力，所以还是一共还是三对……依次类推，可以列出下表：\n   所经过的月数 1 2 3 4 5 6 7 8 9 10 11 12     兔子对数 1 1 2 3 5 8 13 21 34 55 89 144    表中数字1,1,2,3,5,8,13……构成一个序列。这个数列有个明显的特点就是：前面相邻两项之和，构成了后一项。\n2、常规解法 先思考一下，如果我们要实现斐波那契数列用常规的迭代方法应该如何实现？\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int[] a = new int[13]; a[0] = 0; a[1] = 1; System.out.println(\"未使用递归计算：\"); System.out.println(\"a[0] = \" + a[0]); System.out.println(\"a[1] = \" + a[1]); for (int i = 2; i \u003c a.length; i++) { a[i] = a[i - 1] + a[i - 2]; System.out.printf(\"第%d个月兔子总数为：%d\", i, a[i]); System.out.println(); }   我们来简单看一遍这段代码，数组a[]表示从第0月到第12月，其中第0个月没有任何兔子，第一个月有一对兔子，然后我们利用for循环，从第2个月开始计算，即下一个月的兔子数为前两个月兔子数相加。\n代码很简单，几乎不用怎么解释，都可以理解，但其实，我们如果使用递归来实现，代码将会更加整洁。\n3、递归解法 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 使用递归计算  System.out.println(\"使用递归计算如下：\"); for (int i = 0; i \u003c a.length; i++) { System.out.printf(\"第%d个月兔子总数为：%d\", i, Fbi(i)); System.out.println(); } // 使用递归的方法处理  public static int Fbi(int i) { if (i \u003c 2) { return i == 0 ? 0 : 1; } else { return Fbi(i - 1) + Fbi(i - 2); } }   虽然代码整体而言要简洁许多，但却并不是那么好理解。函数怎么可以自己调用自己？？听起来确实有些难以理解，不过我们可以不把一个递归函数中调用自己的函数看作是在调用自己，而就当它是在调用另一个函数。只不过，这个函数和自己长得一样而已。\n我们来模拟代码中的Fbi(i)函数当i = 5的执行过程。Fbi(5) = Fbi(4) + Fbi(3) = Fbi(3) + Fbi(2) + Fbi(2) + Fbi(1) = Fbi(2) + Fbi(1) + 1 + 1 + 1 = 1 + 1 + 1 + 1 + 1 = 5\n三、结束语 我们来对比一下这两种实现斐波那契的代码。迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归可以使程序的结构更清晰、更简洁、更容易让人理解。从而有效地减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同的情况选择不同的代码实现方式。\n斐波那契数列源码地址 ——\u003e Fibonacci\n 《大话数据结构》 ——程杰\n ","description":"","tags":null,"title":"数据结构——递归","uri":"/tech/datastructes/recursion/"},{"categories":null,"content":"后缀表达式——代码讲解 一、前言 在上一篇博客中我们介绍了有关后缀表达式的有关知识，关于如何将中缀表达式转换为后缀表达式，以及后缀表达式的运算规则，做了详细的介绍。因此这篇博客将会用代码来实现一个完整的后缀表达式。\n 二、算法描述 1、将后缀表达式的数据和运算符放入到ArrayList中 我们会获取到一个String类型的后缀表达式，因为对于字符串类型是无法正常完成计算的，因此需要先将后缀表达式里面的数据和运算符按照空格\" \"分割开，然后存放到ArrayList中。\n这里会用到foreach遍历字符串，每遍历一个元素，再利用 list.add() 方法加入到List中，然后返回List即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 依次将一个逆波兰表达式的数据和运算符放入到ArrayList中  public static List\u003cString\u003e getListString(String suffixExpression) { // 将suffixExpression按照空格“ ”分开  String[] split = suffixExpression.split(\" \"); List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (String ele : split) { list.add(ele); } return list; }   2、后缀表达式的运算 关于运算规则，在上一篇博客中已经做过说明，所以这里就不做过多的赘述。我们通过栈来存放扫描到的数字（这里使用正则表达式来判断是否是多位数）。扫描表达式的时候如果遇见运算符，则分别取出栈顶元素和次顶元素，进行计算，并把运算结果再重新入栈。最后留在栈中的数就是该表达式最后的运算结果。需要注意的是：在进行减、除运算的时候，需要注意栈顶元素和次顶元素的位置。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public static int calculate(List\u003cString\u003e ls) { // 创建一个栈（在这里只需要一个栈即可）  Stack\u003cString\u003e stack = new Stack\u003cString\u003e(); // 遍历ls  for (String item : ls) { // 使用正则表达式来取出数  if (item.matches(\"\\\\d+\")) {// 匹配的是多位数  // 入栈  stack.push(item); } else { // pop出两个数，并运算，再入栈  int num1 = Integer.parseInt(stack.pop()); int num2 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\")) { res = num2 + num1; } else if (item.equals(\"-\")) { res = num2 - num1; } else if (item.equals(\"*\")) { res = num2 * num1; } else if (item.equals(\"/\")) { res = num2 / num1; } else { throw new RuntimeException(\"输入的运算符有误！！！\"); } // 把res入栈  stack.push(\"\" + res);// 加上双引号即可转换为字符串形式  } } // 最后留在stack中的数据就是运算结果  return Integer.parseInt(stack.pop()); }    通过上述两种方法，可以实现对于后缀表达式的直接运算。但后缀表达式是计算机容易理解，而相对于人而言，其转换过程是比较头疼的，所以接下来我们实现关于中缀表达式转换后缀表达式的方法。\n 3、将中缀表达式转换成对应的List 对于一个字符串，我们是无法进行操作的，所以首先要做的就是先把中缀表达式转成对应的List。\n需要的变量有： ls(List) 用于存放扫描得到的元素； i(int) 当作指针，用于扫描中缀表达式； str(String) 用于多位数的拼接； c(char) 每遍历一个字符，就放入到c。\n这里我们使用do……while循环来进行遍历，循环的条件是i \u003c s.length();扫描遇到的如果是操作符，直接加入即可；如果是数字，则每次添加的时候先将str置空，然后利用str += c拼接多位数。每次扫描到一个元素之后，指针i需要进行后移，可以利用ASCII码来判断数字的范围，然后进行相关操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 将中缀表达式转换成对应的List  public static List\u003cString\u003e toInfixExpressionList(String s) { // 定义一个List，存放在中缀表达式中对应的内容  List\u003cString\u003e ls = new ArrayList\u003c\u003e(); int i = 0;// 这是一个指针，用于遍历中缀表达式字符串  String str;// 用于多位数的拼接  char c;// 每遍历一个字符，就放入到c  do { // 如果是一个非数字，就需要加入到ls  if ((c = s.charAt(i)) \u003c 48 || (c = s.charAt(i)) \u003e 57) { ls.add(\"\" + c); i++;// i需要后移  } else {// 如果是一个数，需要考虑多位数的情况  str = \"\";// 先将str置空“ ”  while (i \u003c s.length() \u0026\u0026 (c = s.charAt(i)) \u003e= 48 \u0026\u0026 (c = s.charAt(i)) \u003c= 57) { str += c; i++; } ls.add(str); } } while (i \u003c s.length()); return ls;// 返回  }   4、将中缀表达式对应的List转换成后缀表达式 关于中缀表达式转换的规则，在之前也进行过相关的阐述，这里也就不再细说了，不过需要注意的是转换之后的后缀表达式对应的也是List。对于运算符符号操作的时候，我们需要比较运算符的优先级，所以定义一个类，用于返回运算符的优先级。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 编写一个类Operation class Operation { private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; // 编写一个方法，返回对应的优先级数字  public static int getValue(String operation) { int result = 0; switch (operation) { case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; default: System.out.println(\"不存在该运算符\" + operation); break; } return result; } }   具体操作代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 将得到的中缀表达式对应的List转换成后缀表达式对应的List  public static List\u003cString\u003e parseSuffixExpressionList(List\u003cString\u003e ls) { // 定义一个栈，用于存放扫描所得到的符号  Stack\u003cString\u003e s1 = new Stack\u003c\u003e();// 符号栈  // 定义一个ArrayList用于存储中间的结果  List\u003cString\u003e s2 = new ArrayList\u003c\u003e(); // 遍历  for (String item : ls) { // 如果是一个数，加入s2  if (item.matches(\"\\\\d+\")) { s2.add(item); } else if (item.equals(\"(\")) { s1.push(item); } else if (item.equals(\")\")) { // 如果是右括号\")\"，则依次pop出s1栈顶的运算符，并加入s2，直到遇见左括号为止，此时将这一对括号丢弃  while (!s1.peek().equals(\"(\")) { s2.add(s1.pop()); } s1.pop();// 将 ( 弹出s1栈，消除小括号  } else { // 当item的优先级小于或等于s1栈顶运算符，将s1栈顶的运算符弹出，并加入到s2中然后再与s1中新的栈顶运算符相比较  while (s1.size() != 0 \u0026\u0026 Operation.getValue(s1.peek()) \u003e= Operation.getValue(item)) { s2.add(s1.pop()); } s1.push(item); } } // 将s1中剩余的运算符依次弹出并加入到s2  while (s1.size() != 0) { s2.add(s1.pop()); } return s2;// 注意：因为是存放到List，因此按顺序输出就是对应后的后缀表达式对应的List  }    三、结束语 对于栈的应用，使用了中缀表达式和后缀表达式来进行说明，由此可见，想把数据结构学好还是得下一定功夫的，世界上没有随随便便的成功，一步一步踏踏实实地向前走。\n源码 —— \u003e PolandNotation\n","description":"","tags":null,"title":"栈的应用——后缀表达式02","uri":"/tech/datastructes/polandnotation02/"},{"categories":null,"content":"后缀表达式——预备知识 一、前言 在上一篇博客中，我们介绍了中缀表达式的相关操作过程，虽然中缀表达式比较符合我们的日常使用习惯，但是对于计算机却不那么容易去理解，因此有了我们今天要介绍的——后缀表达式。\n例如：( 3 +4 ) * 5 - 6 对应的后缀表达式就是3 4 + 5 * 6 -，那么这个操作过程是怎么实现的呢？？以及后缀表达式该如何进行运算呢？？在下面的内容，我们来一探究竟。\n 二、中缀表达式转后缀表达式 1、规则： 1）初始化一个运算符栈s1和一个用云储存中间结果的List s2；\n2）从左到右扫描中缀表达式；\n3）如果遇到操作数，直接加入到s2；\n4）如果遇到运算符，则比较其与s1栈顶元素的优先级：\n4.1）如果s1为空，或栈顶运算符为左括号\"(\"，则直接将此运算符入栈；\n4.2）若当前运算符比栈顶运算符的优先级高，也将此运算符入栈；\n4.3）否则，将s1栈顶的运算符弹出并加入到s2中，然后再回到4.1）与s1中新的栈顶运算符相比较；\n5）遇到括号时：\n5.1）如果是左括号\"(\"，则直接压入s1；\n5.2）如果是右括号\")\"，则依次弹出s1栈顶的运算符，并加入s2，直到遇见左括号为止，此时将这一对括号丢弃；\n6）重复上述步骤 2）至 5），直到表达式的最右边；\n7）再将s1中剩余的运算符依次加入到s2；\n8）依次输出s2中的元素，输出结果就是相对应的后缀表达式。\n2、举例说明 将中缀表达式\"1+((2+3)*4)-5\"转换为后缀表达式的过程如下：\n   扫描到的元素 s2（表头—\u003e表尾） s1（栈底—\u003e栈顶） 说明     1 1 空 数字，直接加入到s2   + 1 + s1为空，运算符直接入栈   ( 1 + ( 左括号直接入栈   ( 1 + ( ( 左括号直接入栈   2 1 2 + ( ( 数字，直接加入到s2   + 1 2 + ( ( + s1栈顶为左括号，运算符直接入栈   3 1 2 3 + ( ( + 数字，直接加入到s2   ) 1 2 3 + + ( 右括号，弹出s1中的运算符，直至遇到左括号   * 1 2 3 + + ( * s1栈顶元素为左括号，运算符直接入栈   4 1 2 3 + 4 + ( * 数字，直接加入到s2   ) 1 2 3 + 4 * + 右括号，弹出s1中的运算符，直至遇到左括号   - 1 2 3 + 4 * + - -与＋优先级相同，因此弹出+，再压入-   5 1 2 3 + 4 * + 5 - 数字，直接加入到s2   到达最右端 1 2 3 + 4 * + 5 - 空 s1中剩余的运算符     三、后缀表达式运算 后缀表达式的运算还是利用栈这种数据结构，这里我们利用\"3 4 + 5 * 6 -\"这个后缀表达式来进行说明：\n1、规则：  从左到右遍历表达式的每个数字和字符，遇到是数字就进栈，遇到是运算符，就将处于栈顶两个数字（栈顶元素和次顶元素）出栈，进行运算，运算结果进栈，一直到最终获得结果。\n 2、具体操作： 1）从左至右扫描，将3和4压入栈；\n2）遇到+运算符，依次弹出4和3（4为栈顶元素，3为次顶元素），并计算4 + 3的结果，得7，再将7入栈；\n3）将5入栈；\n4）接下来是*运算符，依次弹出5和7，计算出7 * 5 = 35，将35入栈；\n5）将6入栈；\n6）最后是-运算符，计算出35-6的值，即29，由此得出最终结果。\n 三、结束语 因为后缀表达式相对而言是比较复杂的，所以我们分两篇博客进行讲解，这里先介绍的是如何将中缀表达式转换为后缀表达式以及后缀表达式的运算。在下一篇博客中，将进行具体的代码说明。\n","description":"","tags":null,"title":"栈的应用——后缀表达式01","uri":"/tech/datastructes/polandnotation01/"},{"categories":null,"content":"中缀表达式 一、前言 栈的现实应用有很多，这次我们重点来说一下，关于如何使用栈来求数学表达式的值，这里我们描述的为中缀表达式，也就是我们在日常生活中经常使用的四则运算式的形式。\n大家是否还记得，当我们在上小学的时候，老师们时常强调的“先乘除后加减，从左往右算”之类的话呢？？这其实就是四则运算的规则，那么在我们学习编程之后，该如何使用程序来解决这个问题呢？？\n二、算法描述 我们需要一个栈来存放数据（数栈numStack）和另一个栈来存放运算符（符号栈operStack）。那么在此之前，我们需要定义一个类来表示栈。\n1、定义一个类表示栈 在这个类中，我们需要完成的方法有：判断栈满栈空、入栈、出栈、查看栈顶元素、判断是否是运算符、比较运算符的优先级以及运算方法。\n在这里有些方法以及变量的说明，在数组模拟栈已经做出相关说明，这里就直接使用，不做过多的解释。\n①定义相关变量及赋值 代码实现如下：\n1 2 3 4 5 6 7 8 9  private int[] stack;// 数组，用于模拟栈，数据就存放在该数组  private int maxSize;// 栈的大小  private int top = -1;// 表示栈顶，初始化为-1  // 构造器  public ArrayStack2(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; }   ②判断栈满 栈空 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 栈满  public boolean isFull() { return top == maxSize - 1; } // 栈空  public boolean isEmpty() { return top == -1; }   ③入栈 —— push 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 入栈 —— push  public void push(int value) { if (isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; }   ④出栈 —— pop 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 出栈 —— pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据~~~\"); } int value = stack[top]; top--; return value; }   ⑤查看栈顶元素 在这里增加一个方法，用于返回当前栈顶的值，但不是真正的top。那么有些小伙伴可能会问，为什么会在这里增加一个查看栈顶元素的方法呢？？其实我们在存放运算符入符号栈的时候，需要先判断入栈元素与栈顶元素的优先级。这里增加查看栈顶元素的方法，就不用再取出栈顶元素咯，更加有利于我们进行比较运算符的优先级。\n代码实现如下：\n1 2 3 4  // 增加一个方法，可以返回当前栈顶的值，但不是真正的top  public int peek() { return stack[top]; }   ⑥判断是否是运算符 这个方法用于判断表达式中的元素是否是运算符，如果是运算符则直接入符号栈。在这里我们只考虑\"+\"、\"-\"、\"*\"、\"/\"四种运算符。\n代码实现如下：\n1 2 3 4  // 判断是否是运算符  public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; }   ⑦比较运算符的优先级 因为进行四则运算需要遵循”先乘除后加减“的规则，所以需要规定运算符的优先级。我们在这里规定：优先级越高，则返回的数字越大。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 返回运算符的优先级，优先级是由程序猿来确定的，使用数字表示  // 这里规定：优先级越高，返回的数字越大  public int priority(char oper) { if (oper == '*' || oper == '/') { return 1; } else if (oper == '+' || oper == '-') { return 0; } else { return -1;// 假定目前表达式的运算符只有+、-、*、/  } }   ⑧计算方法 具体的计算流程如下：分别从数栈pop出两个数：num1和num2，以及从符号栈pop出一个符号：oper，然后根据pop出的符号进行相关运算。\n在这里我们需要注意的是：因为num1是先取出的，num2是后取出的，所以在进行减除运算的时候，需要注意一下顺序。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 计算方法  public int cal(int num1, int num2, char oper) { int res = 0;// res用于存放计算的结果  switch (oper) { case '+': res = num1 + num2; break; case '-': res = num2 - num1; break; case '*': res = num2 * num1; break; case '/': res = num2 / num1; break; default: break; } return res; }    2、具体运算操作 ①相关变量的定义 我们前文提到了，需要一个数栈numStack，用于存放从表达式中扫描得到的数字；再定义一个符号栈operStack，用于存放扫描得到的运算符；定义一个index用于扫描表达式；num1、num2、oper分别表示取出的数字和运算符。再定义一个字符类型的变量ch，用于存放每次扫描所得到的运算符；定义res用于存放经过计算之后的数；在对于数字进行扫描到时候，如果是多位数，不能发现是一个数就入栈，需要往后面再看一位，如果是数字就继续扫描，否则push入栈，因此需要定义一个变量keepNum用于拼接多位数。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  String expression = \"7*21*2-5+1-5+3-4+2/1\"; //创建两个栈，一个数栈，一个符号栈  ArrayStack2 numStack = new ArrayStack2(100); ArrayStack2 operStack = new ArrayStack2(100); //定义需要的相关变量  int index = 0;//用于扫描  int num1 = 0; int num2 = 0; char oper = 0; int res = 0; char ch = ' ';//将每次扫面得到的运算符保存到ch  String keepNum = \"\";//用于拼接,处理扫描到的数字是多位数   ②扫描表达式 这一步是程序的核心内容，也是运算实现的关键步骤。我们可以使用while循环来操作。\n首先，利用index索引进行扫描表达式，依次得到表达式的每一个字符，可以使用substring()来操作，即ch = expression.substring(index,index+1).charAt(0); 在得到表达式的各个字符之后，然后判断ch是什么符号。\n先假设扫描得到的ch是运算符。如果此时符号栈operStack中已经有运算符，则需要比较当前运算符和栈顶元素的运算符的优先级，如果当前的操作运算符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的运算符入符号栈。（注意：别忘了把当前的运算符push入符号栈）；如果当前的运算符的优先级大于栈中的运算符，则直接入符号栈。另外注意，我们到现在为止，所描述的都是符号栈内有操作符的情况，如果符号栈为空，直接push当前运算符入栈即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  if (operStack.isOper(ch)) {//如果是运算符  //判断当前的符号栈是否为空  if (!operStack.isEmpty()) { //如果符号栈有操作符，就进行比较，如果当前的操作运算符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数  //再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的运算符入符号栈  if (operStack.priority(ch) \u003c= operStack.priority((char) operStack.peek())) { num1 = numStack.pop(); num2 = numStack.pop(); oper = (char) operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果入数栈  numStack.push(res); //然后将当前的操作符入符号栈  operStack.push(ch); } else { //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈  operStack.push(ch); } } else { //如果为空直接入符号栈  operStack.push(ch); } }   现在我们来假设如果扫描得到的是数字，将会如何操作呢？？因为扫描得到的数字，其实是字符型，所以需要转化为整型，这里使用的是Integer。还有需要注意的就是，该如何处理多位数的问题。\n分析思路： * 1、当处理多位数时，不能发现是一个数就立即入栈，因为它有可能是多位数 * 2、在处理数时，需要向expression的表达式的index 后再看一位，如果是数就进行扫描，如果是符号才入栈 * 3、因此需要定义一个变量 字符串，用于拼接 在定义变量的时候我们提到了keepNum，可以使用它来拼接多位数，即keepNum += ch; 但是如果扫描得到的数字是最后一个数字，直接push入栈即可；如果不是最后一位，就需要往后看一位，若后面一位还是数字，则需要继续扫描，直到不是数字为止，同样可以利用substring来实现。每次扫描完成之后需要将拼接符keepNum清空，这一步是千万不能少！！！\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  else {//如果是数，则直接入数栈  //处理多位数  keepNum += ch; //如果ch已经是expression的最后一位，就直接入栈  if (index == expression.length() - 1) { numStack.push(Integer.parseInt(keepNum));//Integer将字符串转化为整型  } else { //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈  //注意是最后一位，不是index++  if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) { //如果后一位是运算符，则入栈 keepNum = \"1\" 或者 ”123“  numStack.push(Integer.parseInt(keepNum)); //重要！！！！！，keepNum清空  keepNum = \"\"; } } }   在完成上述操作之后，需要将index后移，直到index的比表达式长度的值大时，退出循环。\n代码实现如下：\n1 2 3 4 5  //让index + 1，并判断是否扫描到expr最后  index++; if (index \u003e= expression.length()) { break; }   ③完成计算 在完成扫描之后，就顺序从数栈和符号栈中pop出相应的数字和符号完成计算。\n同样可以利用while循环来完成。将最后的计算结果res入数栈。别忘了把数栈中最后的数取出，这个数就是表达式的计算结果。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行  while (true) { // 如果符号栈为空，则运算到最后的结果，数栈中只有一个数字【结果】  if (operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = (char) operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res);//入栈  } //将数栈的最后数，pop出，就是结果  int res2 = numStack.pop(); System.out.printf(\"表达式%s = %d\\n\",expression,res2); }    三、结束语 关于使用栈实现中缀表达式的描述，真的太吃力了，能明显感觉到需要描述不清晰的地方，如果小伙伴们有较好的阐述方法或者建议，都可以提交pr或者issue。\n源码——\u003e Calculator\n","description":"","tags":null,"title":"栈的应用——中缀表达式","uri":"/tech/datastructes/calculator/"},{"categories":null,"content":"单链表模拟栈 一、前言 在上一篇博客中，我们开启了对于栈的数据结构的相关讲解，使用的是数组模拟栈，在这篇博客中，我们将介绍一下如何利用链表来模拟栈。\n之前对于栈这种数据结构的相关定义以及应用场景已经做了简单的说明，在此就不做过多的赘述，下面我们开始了解一下算法的实现过程吧。\n 二、算法实现 1、创建结点类 在使用链表模拟栈之前，我们需要先创建一个结点类，存放信息，以及相关的使用方法。\n该类中所包含的信息有：创建data域用于存放结点信息，next域用于指向下一个结点的指针；利用构造器传入给结点赋值的信息；以及利用toString方法显示结点信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 定义一个类表示结点 class StackNode { public int data;// data域用于存储数据  public StackNode next;// next域用于链接下一个结点  // 构造器  public StackNode(int data) { this.data = data; this.next = null; } @Override public String toString() { return \"StackNode{\" + \"data=\" + data + '}'; } }   2、创建一个类用于管理结点 ①定义相关变量以及赋值 我们可以定义一个头结点top，用来表示栈顶，再定义一个size用于表示栈的大小，并且用于记录入栈和出栈的元素。\n代码实现如下：\n1 2 3 4 5 6 7 8  private StackNode top = null;// 定义一个头结点，表示栈顶  private int size; // 初始化  public LinkedListStack() { top = null; size = 0; }   ②判断链栈是否为空 定义的头结点top是可以存放数据的，所以当top没有存放任何数据的时候，链栈为空。\n代码实现如下：\n1 2 3 4  // 判断链栈是否为空  public boolean isEmpty() { return top == null; }   ③获取有效结点的个数 在定义变量size的时候，提到size可以用来记录链栈的数据入栈和出栈情况，所以我们可以使用getSize()方法，返回的值就是当前链栈的有效结点。\n代码实现如下：\n1 2 3 4  // 获取size的大小  public int getSize() { return size;   ④入栈 —— push 链栈的入栈操作总体上来说还是比较简单的，传入一个需要添加的结点stackNode。与单链表添加结点不同的是，单链表添加的结点在链表的最后，而链栈需要保证的是所添加的结点需要在栈顶。\n因此，我们需要先将新的结点后继结点指向当前链栈的栈顶元素，即stackNode.next = top; （这时原来栈顶的位置就变成了先添加结点的后继结点的位置），然后再将新添加的结点设置为栈顶元素，即top = stackNode; （这时新添加的结点就是栈顶元素）。最后别忘记，每添加一个结点，size需要+1。\n代码实现如下：\n1 2 3 4 5 6 7  // 入栈 —— push  public void push(StackNode stackNode) { stackNode.next = top; top = stackNode; size++; }   ⑤出栈 —— pop 在出栈之前，我们需要先判断链栈是否为空，如果为空则给出相应的提示（这里我们通过抛出异常的方式来进行处理）。至于链栈的出栈操作，具体实现如下：\n先将栈顶元素临时赋值给临时变量temp保存，然后将栈顶元素toptemp的下一个结点。这时栈顶元素的信息已经保存在temp当中。紧接着，再定义一个临时变量retValue，用于存储栈顶元素的data域。在完成上述操作之后，我们还需要将 temp置空，别忘了**size--**和返回retValue。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 出栈 —— pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"链栈为空~~\"); } StackNode temp = top;// 辅助变量  top = temp.next; int retValue = temp.data;// 定义一个临时变量，用于保存栈顶元素  temp = null;// 将temp置空  size--; return retValue; }   ④显示链栈信息 显示链栈信息的方法，与单链表显示方法一样，所以我们直接上代码，哈哈哈哈哈\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示栈中信息  public void show() { if (isEmpty()) { System.out.println(\"链栈为空~~\"); return; } StackNode temp = top; while (temp != null) { System.out.println(temp); temp = temp.next; } }    三、结束语 到这里，我们完成了对于栈的两种实现方式，相对于使用链表实现，数组更容易让我们接受一点。在编写入栈和出栈方法的时候，一开始直接参照单链表的相关实现方法，因此走了不少弯路，所以在学习过程中我们需要学会比较着来学，这样可以帮助我们更好地巩固所学的知识。\n其实关于出栈操作的方法，我总觉得不够好，似乎缺少了点什么。关于临时变量temp，如果不定义temp，而是对栈顶元素直接操作，会发生些什么呢？？小伙伴们可以自己尝试一下，如果有更好的实现方法，也欢迎提出issue噢！\n源码 ——\u003e [数据结构]\n","description":"","tags":null,"title":"数据结构——链表模拟栈","uri":"/tech/datastructes/linkedliststackdemo/"},{"categories":null,"content":"数组模拟栈 一、基本介绍 1、相关定义  栈是一个先入后出的有序列表； 栈是限制线性表中元素的插入和删除只能在线性表的同一段进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top）,另一端为固定的一端，称为栈底（Bottom）； 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先删除的元素最后删除。  2、应用场景  子程序的调用：在跳往子程序前，会先将下个指令的地址存放到堆中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数、区域变量等数据存入到堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。 二叉树的遍历。 图形的深度优先（depth - first）搜索法。   二、算法实现 需要构建一个ArrayStack类，用于表示栈。\n1、定义相关变量以及赋值 需要定义的相关变量有：定义一个数组模拟栈int[] stack、栈的大小maxSize以及栈顶元素top。（在这里我们把栈顶元素top的初始值为-1，有利于后期存入和删除数据）。\n定义完相关变量之后，我们可以利用构造器对maxSize和stack数组进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  private int maxSize;// 栈的大小  private int[] stack;// 数组，数组模拟栈，数据就在该数组  private int top = -1;// top表示栈顶，初始化为-1  // 构造器  public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; }   2、判断栈是否为满 因为数组的下标是从0开始的，所以当栈满时，栈顶元素的下标为stack[top] = maxSize - 1;所以当 top == maxSize - 1时，栈满。\n代码实现如下：\n1 2 3 4  // 栈满  public boolean isFull() { return top == maxSize - 1; }   3、判断栈是否为空 之前在定义相关变量的时候，我们提到top的初始值为-1，即当 top == -1时，栈中没有存入任何数据，为空。\n代码实现如下：\n1 2 3 4  // 栈空  public boolean isEmpty() { return top == -1; }   4、入栈——push 方法 在入栈之前，我们首先需要判断栈是否已满，如果栈满则给出提示，并结束程序。否则执行以下操作：由于top的初始值为-1，即数组第一个元素的前一个位置，因此需要先移动top到指定位置，然后给其赋值即可。（先后移再赋值）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 入栈——push  public void push(int value) { // 先判断栈是否未满  if (isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; }   5、出栈——pop 方法 在进行出栈操作之前，我们首先需要判断栈是否为空，如果为空，则给出相关提示（这里我们是用抛出异常的方式来进行处理）；否则，执行以下操作：先定义一个临时变量value来存储栈顶元素，然后栈顶元素top--，往前移动，最后返回临时变量即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 出栈——pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据~~~\"); } int value = stack[top]; top--; return value; }   6、打印输出栈的信息 如果栈为空，则没有任何数据可以显示，所以在输出栈的信息之前，我们需要先判断栈是否为空。在遍历的时候，我们需要从栈顶开始显示数据。可以通过for循环l来实现。\n因为是从栈顶开始显示数据，所以循环的起始位置应该为栈顶top，循环结束的条件应该为i \u003c 0，每执行一次循环，则需要i--。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 遍历栈，遍历时，需要从栈顶开始显示数据  public void show() { if (isEmpty()) { System.out.println(\"栈空，没事有数据~~~\"); return; } // 需要从栈顶开始显示数据  for (int i = top; i \u003e= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } }    三、结束语 这里我们使用的是数组模拟栈的操作，所以说对应的也可以利用链表来模拟栈，小伙伴们可以自己先尝试一下噢。\n在写代码的时候，因为是利用数组模拟栈的相关操作，不由的想起之前写过的数组模拟单向队列，两者可以进行比较的学习，可以思考一下，同样是没有取模的操作，为什么单向队列不能够进行复用，而栈却可以呢？？\n源码地址——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——数组模拟栈","uri":"/tech/datastructes/arraystackdemo/"},{"categories":null,"content":"两年前的这个时候，高考也已经告一段落。一直以来，都太强调学习，满脑子里想的都是”知识改变命运“这种空而大的口号。其实这一点，直到今天，还依然未变。要不看了这么多年的书，岂不是白看了嘛？？哈哈哈哈哈……\n在高三的时候，总想着，只要再努力一点，再多背一个单词，多做一道题目，就离考了大学更进一步，但其实不然。当拿到报考指南的那一刻，还是傻眼了。似乎有一种无力感，高考查完分之后的那种兴奋再也找不到了，就在想：当时熬的夜，还值得吗？？都说付出就会有回报，但结果呢？？这大概就是灰色而幽默的现实，当头一棒，给我敲醒。我只是个蝼蚁，还有很长的路要走！！\n在大一的时候，大部分的同学的共同语言，还是关于“高三”。似乎，之前的所有经历和高三相比都不值一提，还是当时眼界太低，能看见的只有高考呢？？上了大学，懵懵懂懂，总想着，摆脱了高中的条条框框的拘束，也有个平台可以展示自己了。其实现在反过来，想想当时自己为什么要加哪些组织、社团呢？？是真的喜欢吗？？还是单纯的为了学分呢？？还是利益相关呢？？大一刚入学的时候，感觉那些当着学生组织负责人的学长学姐好了不起，如果自己到了那个时候，会变得和他们一样优秀吗？？大一，也许在悔恨高中为什么不努力好好学习，也许是刚刚告别高三，还把看书、刷题当做一种习惯，但慢慢的，随着时间的推移，当时的屠龙少年，现在也变成了一条恶龙。（前段时间在整理书柜的时候，发现了大一时候学高数，演算的稿纸，还真的挺佩服那时候的自己）\n到了大二，渐渐的在学校里有了自己的圈子，创立了自己的社团，原以为会变成自己想要的样子，迎来的却是各种毒打，其实也算不上毒打，准确来说是劝退。当热情被慢慢消磨殆尽，坚持下来的可能就是责任了吧。那如果连责任心都没了呢？？我还有什么坚持下去的理由呢？？\n到现在，回过头来，看看高三时候的自己，可能会对他说：把一切都看淡一点，没什么大不了的。是的，没什么大不了的。说句鸡汤的话：只要你努力，总不会变得太差劲。\n 其实这篇文章，在好久之前就想写，但一直找不到带入点，也不知该如何去说起。可能是最近的烦心事多了，又变得消极了点，心里有情绪，总归要抒发出来的嘛。\n","description":"","tags":null,"title":"写个两年前的自己","uri":"/life/%E5%86%99%E4%B8%AA%E4%B8%A4%E5%B9%B4%E5%89%8D%E7%9A%84%E8%87%AA%E5%B7%B1/"},{"categories":null,"content":"环形链表  一、基本介绍 1、问题来历 据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。\n2、问题简化 在了解了约瑟夫环的来历之后，我们对该问题进行以下简化。其实我们联系一下，将会发现约瑟夫环是不是和我们小时候玩的丢手帕有些类似呢？\n那么我们首先假设有五个小孩围城一个圈，然后从第一个小孩开始报数，每次数到2，则这个小孩出圈，以此类推，通过简单地推理我们可以得出，出队列的顺序是：2—\u003e4—\u003e1—\u003e5—\u003e3.\n在了解了有关约瑟夫环的介绍之后，我们可以使用单向环形链表来对它进行相关操作。这里我们使用的是没有头结点的链表。\n 二、算法描述 1、定义结点 定义一个结点，存放小孩的编号。在之前介绍链表的时候，我们定义变量的属性都是共有的，这里我们尝试一下私有的，因此需要使用到get和set方法，来进行赋值和获取相关变量。同时，还需要一个构造器，分别用于传入结点的编号。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 创建一个Boy类，表示一个结点 class Boy { private int no;// 编号  private Boy next;// 指向下一个结点，默认为null  // 构造器  public Boy(int no) { this.no = no; } public int getNo() { return no; } public Boy getNext() { return next; } public void setNo(int no) { this.no = no; } public void setNext(Boy next) { this.next = next; } }   2、定义一个类用于管理结点 首先需要创建一个first结点，不存放任何数据，也就是当前没有编号的结点。\n代码实现如下：\n1 2  // 创建一个first结点，当前没有编号  private Boy first = null;   ①添加结点入链表 首先传入一个nums表示需要添加结点的个数。在进行添加之前，还需要判断传入的nums是否符合要求。然后定义一个curBoy辅助指针，帮助构建环形链表。\n我们通过for循环创建结点，先创建第一个结点，让first结点指向该结点，然后first的next域指向自己，构成一个环，最后再让辅助指针curBoy指向first，即完成第一个结点的添加操作；添加其它结点的方法如下：先让curBoy的下一个结点指向需要添加的结点（通过setNext方法），然后再让该结点的next域指向first结点，形成环，最后使curBoy指向当前添加的结点（为了方便下一次添加结点），从而完成添加结点的相关操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 添加小孩结点，构建一个环形的链表，nums表示需要添加结点的个数  public void addBoy(int nums) { if (nums \u003c 1) {//检验  System.out.println(\"nums的值不正确\"); return; } Boy curBoy = null;// 辅助指针，帮助构建环形链表  // 使用for循环俩创建环形链表  for (int i = 1; i \u003c= nums; i++) { // 根据编号，创建小孩结点  Boy boy = new Boy(i); // 如果是第一个小孩  if (i == 1) { first = boy; first.setNext(first);// 构成环  curBoy = first; } else { curBoy.setNext(boy); boy.setNext(first); curBoy = boy; } } }   ②遍历输出环形链表 首先判断链表是否为空，即if(first == null)，如果为空则给出提示；不为空则执行以下操作：因为first结点不能动，因此需要一个辅助变量用于完成遍历，即 Boy curBoy = first，然后我们使用while来进行循环遍历。通过getNext方法实现后移，如果curBoy的下一个结点为first则遍历结束，退出循环。完成链表的遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 遍历当前的环形链表  public void showBoy() { // 判断链表是否为空  if (first == null) { System.out.println(\"该环形链表为空~\"); return; } // 因为first不能动，因此需要一个辅助指针完成遍历  Boy curBoy = first; while (true) { System.out.printf(\"小孩的编号%d\\n\", curBoy.getNo()); if (curBoy.getNext() == first) {// 说明已经遍历完毕  break; } curBoy = curBoy.getNext();// curBoy后移  } }   ③完成结点出链表 我们需要传入几个参数，startNo表设从第几个结点开始报数，countNum表示需要数几下，nums表示圈中有多少个小孩。\n首先需要对数据进行一个校验，即判断环形链表是否为空，开始报数的位置不能低于1，也不能大于圈中的结点。\n代码实现如下：\n1 2 3 4  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; }   然后需要创建一个辅助指针helper，帮助完成小孩出圈。接下来我们需要将helper先指向链表的最后这个结点，即helper的下一个结点就是first结点。紧接着通过while循环，我们再将first和helper指针同时移动countNum - 1次，到达需要出圈结点的位置。\n最后也是最关键的一步，完成小孩结点出圈。先让first结点指向它的下一个结点，即first = first.getNext();，然后再将helper的下一个结点设置为当前first所指向的结点，即helper = helper.setNext(first);，这样first原来所指向的结点没有任何引用，就会被回收。\n如果helper == first,则说明圈中只有一个结点。输出这个结点的信息，就完成了出圈的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /** * 根据用户的输入，计算出小孩出圈的顺序 * * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少个小孩在圈中 */ public void countNum(int startNo, int countNum, int nums) { // 先对数据进行校验  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; } // 创建一个辅助指针，帮组完成小孩出圈  Boy helper = first; //需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这结点  while (true) { if (helper.getNext() == first) {// 说明helper指向最后小孩结点  break; } helper = helper.getNext(); } // 当小孩报数前，先让first和helper指针同时移动 startNo - 1 次，到达需要报数的位置  for (int j = 0; j \u003c startNo - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 当小孩报数时，让first和helper指针同时移动countNum - 1次，然后出圈  // 这里使用循环操作，直到圈中只有一个结点  while (true) { if (helper == first) {// 说明圈中只有一个结点  break; } // 让first和helper指针同时移动countNum - 1次  for (int j = 0; j \u003c countNum - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 这时first指向的结点，就是要出圈的小孩结点  System.out.printf(\"小孩%d出圈\\n\",first.getNo()); first = first.getNext(); helper.setNext(first); } System.out.printf(\"最后留在圈中的小孩编号%d\\n\",first.getNo()); }    三、结束语 在此，更新了环形链表，关于链表的所有基础知识也就要告一段落咯。谈谈我一开始学习链表的感觉吧，从一个小白，刚开始接触数据结构，就被其中各种复杂的结构所惊讶到。特别在学习到链表的时候，更加感觉到举步维艰，似乎很玄学，说不懂，但其实还是有一点点明白大概的结构。但是距离能够独立写出一个链表的结构还有很长一段路要走。因此我查阅了一些相关博客，只看代码和文字描述，总感觉少了点什么，写得再好的代码和文字，倒不如一张图来得实在，所以在学习的时候，我建议可以结合画图来实际操作，这样更方便理解，还有利于记忆。\n环形链表源码—\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——约瑟夫环","uri":"/tech/datastructes/circlelinkedlistdemo/"},{"categories":null,"content":"关于我？ 叫我二夕就好，可能看到这里，你会好奇，为啥起一个这么怪的名字呢？？\n当时在想昵称的时候一直找不到合适的，打算叫“无名”，但总感觉有点落了俗套。还好，中文是比较有意思的，把“无”和“名”下面的部分拿了，不就是“二夕”了嘛。。。。。哈哈哈哈哈哈\n 玩什么？？ 常常会感慨自己是个老年人了，过了打游戏的年龄。在大学生活中，不打游戏，时间就多了起来。无聊的时候，总想找些东西打发时间。慢慢的，找到新的伙伴——悠悠球。停停停！！！我知道你想说：刚刚还感慨自己是老年人，现在又玩起小孩子的东西。\n大多数人对于悠悠球的印象可能还停留在儿时的玩具，是的，重新开始接触的时候，我也是那么认为的。但随着技术的提升，认识的玩家越来越多，会发现一个全新的世界。你会发现，有很多人都在为之而共同努力。只想把悠悠球，一种玩具，小众文化，推向大众。想得到大众的认可。\n 除了玩？？ 除了玩，那肯定就是吃和睡咯……呸呸呸，这不是我！！！\n学的专业是软件工程，所以平时最多打交道的就是代码，哪还有时间吃吃睡睡的，捋了捋自己的头发。作为一个日常摸鱼的当代大学生，平时无非就是看看书，写写代码，听听歌。就这？？\n","description":"","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"双向链表  一、基本介绍 在上一篇博客中，我们提到了单链表，它只有一个next指针，指向下一个结点，所以我们要查找下一个结点是很容易做到的，但是要想查找上一个结点就复杂的多了。因此有了双向链表。\n双向链表有两个指针域，除了有next域指向下一个结点之外，还有pre域指向上一个结点。这样使得双链表可以双向遍历。节省了时间成本，但相比于单链表插入数据和删除数据就相对复杂一些。下面我们对双链表进行简单学习一下吧。\n 二、算法实现 双链表和单链表一样，需要创建一个类用于存放结点信息，再创建一个类用于管理结点，对双链表进行相关的操作。\n1、定义节点类 我们需要在HeroNode2类中实现相关变量的定义、赋值以及显示信息的方法。\n①相关变量 这里我们使用双链表存储水浒英雄，和单链表相同，还得增加一个pre指针，指向前一个结点。\n代码实现如下：\n1 2 3 4 5  public int no; public String name; public String nickname; public HeroNode2 pre;// 指向下一个结点，默认为null  public HeroNode2 next;// 指向前一个结点，默认为null   ②构造器 利用构造器，对相关变量进行赋值。\n代码实现如下：\n1 2 3 4 5  public HeroNode2(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 这里利用toString方法，返回链表的信息。\n1 2 3 4 5 6 7 8 9  // 为了显示方法，重写toString  @Override public String toString() { return \"HeroNode2{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }    2、定义一个DoubleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，同样需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  // 先初始化一个结点，头结点不要动，不存放具体的数据  private HeroNode2 head = new HeroNode2(0, \"\", \"\");   ①添加数据到队列尾 与单链表相同，需要先定义一个辅助变量temp，利用while循环遍历到链表的最后。当退出while循环时，即temp指向了链表的最后。这时我们需要将temp的next域指向需要添加的结点，然后再将需要添加的结点的pre域指向temp，完成添加。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 添加一个结点到双向链表的最后  public void add(HeroNode2 heroNode2) { // 因为head结点不能动，因此我们需要添加一个辅助变量temp  HeroNode2 temp = head; // 遍历链表，知=找到链表的最后  while (true) { if (temp.next == null) {// 遍历到链表的最后  break; } // 如果没有找到将temp后移  temp = temp.next;// 后移  } // 当退出while循环时，temp就指向了链表的最后  // 形成了一个双向链表  temp.next = heroNode2; heroNode2.pre = temp; }   ②根据编号顺序添加结点 与单链表相同，需要先找到需要添加结点(heroNode2)的前一个结点（temp），这里不做过多赘述。当找到需要添加的结点的前一个结点之后，需要进行如下操作：\n需要先将heroNode2完成拼接，即先将heroNode2的next域指向temp.next;（新插入节点的前一个结点指向它的下一个结点），再将heroNode的pre域指向temp（将新插入的结点指向它的前一个结点），这时heroNode的pre域和next域已经分别指向了heroNode的前驱结点和后继结点；剩余需要做的就是让heroNode的前驱结点的next域和后继结点的pre域指向heroNode，但需要注意的是：如果添加的位置刚好是最后一个结点，则heroNode没有后继结点，也就是不用执行temp.next.pre = heroNode2。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 根据编号顺序添加结点  public void addByOrder(HeroNode2 heroNode2) { HeroNode2 temp = head; boolean flag = false; while (true) { if (temp.next == null) { break; } if (temp.next.no \u003e heroNode2.no) { break; } else if (temp.next.no == heroNode2.no) { flag = true; break; } temp = temp.next; } if (flag) { System.out.printf(\"需要插入的英雄编号%d已存在，添加失败\\n\", heroNode2.no); } else { heroNode2.next = temp.next;// 将新插入的结点指向它的下一个结点  heroNode2.pre = temp;// 将新插入的结点指向它的前一个结点  // 注：如果不是最后一个结点，则不需要执行下面这块代码，否则会出现空指针  if (temp.next != null) { temp.next.pre = heroNode2; } temp.next = heroNode2; } }   ③修改结点信息 修改结点信息的方法和单链表如出一辙，通过遍历找到需要修改结点所在的位置即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 修改结点信息（可以看待双向链表的结点内容修改和单向链表一样）  public void update(HeroNode2 newHeroNode2) { // 判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 找到需要修改的结点，根据no编号  HeroNode2 temp = head.next;// 定义一个辅助变量  boolean flag = false; while (true) { if (temp == null) { break; } if (temp.no == newHeroNode2.no) {// 找到  flag = true; break; } temp = temp.next; } //根据flag判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode2.name; temp.nickname = newHeroNode2.nickname; } else {//没有找到  System.out.printf(\"没有找到 编号%d的节点，不能修改\", newHeroNode2.no); } }   ④删除结点 从双向链表中删除一个结点，我们只需直接找到需要删除的结点，找到后，双链表可以实现自我删除。\n具体操作如下：定义一个辅助变量temp = head.next;这里我们直接找到该结点所在的位置，所以temp直接等于head.next;还需要一个flag标记是否找到待删除结点。通过遍历找到链表的最后，然后让temp的前驱结点的next域直接指向temp的下一个结点，即temp.pre.next = temp.next;如果待删除结点不是最后的结点，则还需要执行下列操作：让temp的下一个结点的pre指向temp的前一个结点，即temp.next.pre = temp.pre;完成上述操作之后，待删除结点的前后指针都指向null，也就完成了删除。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public void del(int no) { // 判断当前链表是否为空  if (head.next == null) {// 空链表  System.out.println(\"链表为空，无法删除~\"); return; } HeroNode2 temp = head.next; // 辅助变量(指针)  boolean flag = false; // 标志是否找到待删除节点的  while (true) { if (temp == null) { // 已经到链表的最后  break; } if (temp.no == no) { // 找到的待删除节点的前一个节点temp  flag = true; break; } temp = temp.next; // temp后移，遍历  } // 判断flag  if (flag) { // 找到  // 可以删除  temp.pre.next = temp.next; // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针  if (temp.next != null) { temp.next.pre = temp.pre; } } else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } }   ⑤输出链表信息 和单链表操作相同。。。。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 遍历打印输出链表信息  public void show() { // 先判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 因为头结点不能动，定义一个辅助变量用于遍历  HeroNode2 temp = head.next; while (true) { // 判断是否到链表最后  if (temp == null) { break; } // 输出结点信息  System.out.println(temp); temp = temp.next;// 将temp后移！！！  } }    三、结束语 到这里，我们完成了对于双链表的相关操作。双向链表相对于单链表来说，要更复杂一些，毕竟它多了pre指针，进行删除和操作的时候需要格外小心。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点操作带来了方便，可以有效提高算法的时间性能。说白了，就是用空间换时间。\n源代码——\u003e数据结构\n 《大话数据结构》 ——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构——双向链表","uri":"/tech/datastructes/doublelinkedlist/"},{"categories":null,"content":"单链表的应用举例 一、前言 在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操作：\n 获取单链表的有效结点 查找单链表中的倒数第k个结点 逆序打印单链表（从尾到头打印） 反转单链表   二、算法介绍 1、获取单链表的有效结点 作为使用的第一个方法难度不是很大。因为需要求出单链表中有效结点的个数，所以我们可分为带头结点和不带头结点两种情况。\n我们这边考虑的是不带头结点的单链表，（如果是带头结点的链表需要再加上头结点即可）。需要的变量有length(统计链表的长度)和cur(辅助变量，用于遍历)，可以通过传入一个头结点，然后依次遍历该链表，当链表遍历到最后的时候，即cur.next == null，每一次遍历链表的长度加一，即length++。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // head链表的头结点，返回的就是有效结点的个数  public static int getLength(HeroNode head) { if (head.next == null) {// 链表为空  return 0; } int length = 0; HeroNode cur = head.next;// 定义一个辅助变量  while (cur != null) { length++; cur = cur.next; } return length; }   2、查找单链表中的倒数第k个结点 因为单链表是单向的，只能从头到尾开始遍历，而无法从后往前遍历，所以我们需要传入一个头结点head（遍历的起始位置）和index(倒数第k个结点)。\n定义一个size表示链表的长度，也就是链表有效结点的个数，可以通过方法一来获取。即size = getLength(head)，然后需要定义一个辅助变量用于遍历。然后通过for循环定位到倒数的index，即size - index的位置，也就是需要查找的倒数第k个结点。最后返回当前的辅助变量，完成查找。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static HeroNode findLastIndexNode(HeroNode head, int index) { // 判断链表是否为空，如果是则返回null  if (head.next == null) { return null;// 没有找到  } // 第一次遍历得到链表对的长度（结点个数）  int size = getLength(head); // 先做一个index校验  if (index \u003c 0 || index \u003e size) { return null; } // 定义一个辅助变量，for循环定位到倒数的index  HeroNode cur = head.next; // 第二次遍历 size - index位置，就是倒数的第k个结点  for (int i = 0; i \u003c size - index; i++) { cur = cur.next; } return cur; }   3、逆序打印单链表 在不改变链表结构的情况下，进行逆序打印，我们可以利用栈这个数据结构来实现。栈的特点就是先进后出。先把链表push压入栈中，再pop出栈即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public static void reversePrint(HeroNode head) { if (head.next == null) { return;// 空链表，不能打印  } // 创建一个栈，将各个结点压入栈  Stack\u003cHeroNode\u003e stack = new Stack\u003c\u003e(); HeroNode cur = head.next; // 将链表的所有结点压入到栈  while (cur != null) { stack.push(cur); cur = cur.next; } // 将栈中的结点进行打印，pop出栈  while (stack.size() \u003e 0) { System.out.println(stack.pop());// stack的特点就是先进后出  } }   4、反转单链表（有点难度） 对单链表进行反转，表示的意思是：将最后的结点变成最前端的结点，以此类推。所以我们需要分为两种情况：\n 当前链表为空，或者当前链表只有一个结点，无需反转，直接返回即可。 有多个结点时：  需要的变量有：cur(用于遍历原来的链表)，nextNode(指向当前结点[cur]的下一个结点)，reverseHead(结点，新链表的最前端)。\n具体操作过程如下：先将nexNodet指向cur的下一个结点，用于保存当前结点的下一个结点，然后将cur的下一个结点指向新链表的最前端，即cur.next = reverseHead.next,然后再将cur连接到新的链表上，这样才能形成一个完成的链表（一个回路）。然后后移，遍历下一个结点，即cur = nextNode;在进行上述操作之后，我们已经将链表的所有结点取出，并存放在新的链表下，这时我们需要将head.next 指向 reverseHead.next，实现单链表的反转，即 head.next = reverseHead.next; 完成单链表的反转。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void reverseList(HeroNode head) { // 如果当前链表为空，或者只有一个结点，无需反转，直接返回  if (head.next == null || head.next.next == null) { return; } HeroNode cur = head.next;// 定义一个辅助变量，帮助遍历原来的链表  HeroNode nextNode = null;// 指向当前结点[cur]的下一个结点  HeroNode reverseHead = new HeroNode(0, \"\", \"\"); // 遍历原来的链表，每遍历一个结点，将其取出，并放在新的链表reverseHead的最前端  while (cur != null) { nextNode = cur.next;// 先暂时保存当前结点的下一个结点，  cur.next = reverseHead.next;;// 将cur的下一个结点指向新的链表的最前端  reverseHead.next = cur;// 将cur连接到新的链表上  cur = nextNode;// 让cur后移  } // 将 head.next 指向 reverseHead.next，实现单链表的反转  head.next = reverseHead.next; }    三、结束语 其实我们不难发现，数组也好，链表也罢，都只是存储信息的不同方式，最重要的还是对其的理解和使用，只有这样才能更好的掌握。对于一个刚接触数据结构的小白来说，学到这里的时候，信息量已经远远超过之前所学的知识，但并不应该气馁，数据结构多而且难，所以更需要我们耐下性子，去慢慢琢磨、回顾，愿成长路上，与君共勉！\n源码地址——\u003e数据结构\n","description":"","tags":null,"title":"单链表的使用","uri":"/tech/datastructes/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"单向链表 一、基本介绍 1、相关定义 链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的，且链表的长度不是固定的。链表的每个元素称为一个结点，每个结点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑关系，以便构成“一个结点链着一个结点”的链式存储结构，为了保持每个结点之间的链接，所以链表除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个结点都包含两个部分，第一部分用于存储元素本身的数据信息，称为数据域，它不局限于一个成员数据，也可是多个成员数据；第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的结点信息，这里用next表示，next的值实际上就是下一个结点的地址，当前结点为末结点时，next的值设为空指针，即为null。链表在使用过程中，可以根据实际需求来判断是否需要添加头结点。\n2、链表与数组比较 数组（包括结构体数组）的实质是一种线性表的顺序表示方式，它的优点是使用直观，便于快速、随机地存取线性表中的任一元素，但缺点是对其进行插入和删除操作时需要移动大量的数组元素，同时由于数组属于静态内存分配，定义数组时必须指定数组的长度，程序一旦运行，其长度就不能再改变，实际使用个数不能超过数组元素最大长度的限制，否则就会发生下标越界的错误，低于最大长度时又会造成系统资源的浪费，因此空间效率差。\n 二、算法实现 我们需要定义一个类用来存放结点信息，同时也还需要定义一个类用于管理结点，实现单链表的增删改查。\n1、定义一个HeroNode类表示结点 我们需要在HeroNode类中实现相关变量的定义、赋值以及显示信息的方法。\n① 相关变量 这里我们使用单链表来存储水浒英雄，需要存储的信息有：编号、姓名和昵称。还需要定义一个next域用于指向下一个结点。\n代码实现如下：\n1 2 3 4  public int no;// 编号  public String name;// 姓名  public String nickname;// 昵称  public HeroNode next;// next域，指向下一个节点   ②构造器 可以利用构造器对相关变量进行赋值。\n代买实现如下：\n1 2 3 4 5  public HeroNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 我们可以使用toString方法来显示链表的信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 利用toString显示信息  @Override public String toString() { return \"HeroNode{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }   2、定义一个SingleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  //先初始化一个头节点，头节点不要动，不存放具体的数据  private HeroNode head = new HeroNode(0, \"\", \"\");   ①直接添加数据到单链表 直接添加数据到队列尾，即不考虑编号按照添加顺序，入链表。因为头结点不能动，所以需要定义一个临时变量temp用于遍历。通过后移temp实现遍历，temp = temp.next 。遍历的目的在于，找到当前链表最后的结点，然后将最后这个结点的next指向新的结点，便完成了添加的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public void add(HeroNode heroNode) { //因为head节点不能动，因此我们需要一个辅助变量temp  HeroNode temp = head; //遍历链表，找到最后  while (true) { //找到链表的最后  if (temp.next == null) { break; } //如果没有找到最后，将temp后移  temp = temp.next; } //当退出while循环时，temp指向了链表的最后  //将最后这个节点的next指向新的节点  temp.next = heroNode; }   ②根据编号添加结点 这次我们使用按照编号顺序添加结点，如果该编号已经存在，则添加失败，并给出提示。按照编号添加结点，使用的方法是通过 后移temp 遍历，找到该编号的前一个结点，然后让需要添加的结点先指向前一个结点的下一个结点，然后再让前一个结点指向需要添加的结点。所以需要一个flag变量来标记是否找到当前结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public void addByOrder(HeroNode heroNode) { //因为头节点不能动，因此仍然需要通过一个辅助指针（变量）来帮助找到添加的位置  //因此我们找的temp是位于添加位置的前一个节点，否则插入不了  HeroNode temp = head; boolean flag = false;//标志添加的编号是否存在，默认为false  while (true) { if (temp.next == null) {//说明temp已经在链表的最后  break; } if (temp.next.no \u003e= heroNode.no) {//位置找到，就在temp的后面插入  break; } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode编号已经存在  flag = true;//说明编号存在  break; } temp = temp.next;//后移，遍历当前链表  } //判断flag的值  if (flag) {//不能添加，说明编号已经存在  System.out.printf(\"准备插入的英雄编号%d已经存在，添加失败\\n\", heroNode.no); } else { //插入到链表中，temp的后面  heroNode.next = temp.next; temp.next = heroNode; } }   ③修改结点信息 这里我们通过根据编号来修改结点信息，即编号不能改。同时需要传入一个新的结点 newHeroNode ，用于存储修改结点的信息。在进行修改之前，需要先判断单链表是否为空，head.next == null 链表为空。然后定义一个辅助变量temp和flag分别用于遍历和标记是否找到当前结点。如果 temp.no == newHeroNode.no 表示找到当前需要修改的结点。赋予新的name和nickname完成修改结点的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //1、根据newHeroNode的no来修改即可  public void update(HeroNode newHeroNode) { //判断是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //2、找到需要修改的节点，根据num编号修改  HeroNode temp = head.next;//定义一个辅助变量  boolean flag = false;//表示是否找到该节点  while (true) { if (temp == null) { break;//已经遍历结束  } if (temp.no == newHeroNode.no) {//找到  flag = true; break; } temp = temp.next; } //3、根据flag，判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; } else {//没有找到  System.out.printf(\"没有找到编号%d的节点，不能修改\\n\", newHeroNode.no); } }   ④删除结点 在进行删除结点的操作的时候，我们仍然根据编号来进行寻找需要删除的结点。找到需要删除结点的前一个结点，让前一个结点的next跨过需要删除的结点，直接指向下一个结点，即 temp.netx = temp.next.next ，完成删除。在进行删除之前仍然需要定义temp和flag用于遍历和标记是否找到需要删除结点的前一个结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public void del(int no) { HeroNode temp = head; boolean flag = false;//标志是否找到待删除节点  while (true) { if (temp.next == null) { break;//已经到链表的最后  } if (temp.next.no == no) {//找到待删除节点的前一个节点temp  flag = true; break; } temp = temp.next;//temp后移，遍历  } //判断flag  if (flag) {//找到  //可以删除  temp.next = temp.next.next; } else { System.out.printf(\"需要删除的%d节点不存在\\n\", no); } }   ⑤显示链表信息 在显示链表信息之前，需要先判断链表是否为空，并给出相关信息。通过后移临时变量temp完成遍历。先输出结点信息，每当输出一个结点信息，就需要后移一次。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //显示链表，遍历  public void show() { //判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //因为头节点不能动，因此我们需要一个辅助变量来遍历  HeroNode temp = head.next; while (temp != null) {// 判断是否到链表最后  //输出节点的信息  System.out.println(temp); //将temp后移  temp = temp.next; } }    三、结束语 到此，我们了解了有关单链表的相关操作。在算法实现过程中，可能不少小朋友会发现一些问题，比如为什么有时候临时变量 temp = head.next ， 而有时却变成了temp = head 了呢？？其实仔细阅读一遍代码，我们不难发现，当进行增删操作的时候，temp = head ，那是因为需要增删的结点刚好是直接添加到头结点之后的，如果变成了 head.next ， 则会造成覆盖结点的情况；而在进行修改和遍历的时候，临时变量 temp = head.next ，那是因为我们这里定义头结点为空，不存放任何数据，所以修改和遍历的时候，需要从真正的有效结点开始。\n源码已经push到 ——\u003e数据结构\n","description":"","tags":null,"title":"数据结构--单向链表","uri":"/tech/datastructes/singlelinkedlist/"},{"categories":null,"content":"数组模拟环形队列  一、前言 在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。\n 二、算法实现 1、初始化相关变量 需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对front和rear做以下调整：front由原来指向队列的前一个位置，改变为队列的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；rear从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为maxSize - 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  private int maxSize;// 表示数组的最大容量  private int front;// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素  private int rear;// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0  private int[] arr;// 该数组用于存放数据，模拟队列  // 构造器  public CircleArray(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = 0; rear = 0; }   2、判断队列是否为满 我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针下一个位置是头指针的时候，表示队列满。（在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 (rear + 1) % maxSize == front 。( 这里取模的目的就是为了整合rear和front大小为一个问题 )\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return (rear + 1) % maxSize == front; }   3、判断队列是否为空 因为front和rear的初始值相同，所以判断队列空的方法与之前一样。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return rear == front; }   4、求出当前队列的有效数据个数 这个方法与之前相比是新添加的，其目的是为了判断遍历队列的长度。队列的有效数据的个数 = 尾队列 - 头队列，但有时front比rear大，有时front比rear小，所以可以通过取模的方式来实现。\n代码实现如下：\n1 2 3 4  // 求出当前队列的有效数据的个数  public int size() { return (rear + maxSize - front) % maxSize; }   5、入队列 添加数据入队的操作和之前相类似，只不过该队列front指向队列的第一个元素的位置，所以需要进行先赋值，然后再后移。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 添加数据入队列  public void addQueue(int n) { if (isFull()) { System.out.println(\"该队列已满，，无法添加任何数据~\"); return; } arr[rear] = n;// 直接将数据加入  rear = (rear + 1) % maxSize;// 将rear后移，这里必须考虑取模  }   6、出队列 之前由于头指针指向队列的前一个位置，所以先后移，到达需要取出数据的位置，从而返回即可 。但此时头指针所在的位置就是需要取出的位置，如果直接返回则无法进行后移，如果先后移，则取出的数据就是下一个位置的数据。我们可以做一下处理，从而达到想要的效果：\n 先把front对应的值保留到一个临时变量； 将front后移，考虑取模 将临时保存的变量返回  代码实现如下：\n1 2 3 4 5 6 7 8 9  // 从队列中取出数据  public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无任何数据可以取出~\"); } int val = arr[front]; front = (front + 1) % maxSize; return val; }   7、显示队列的所有数据 在遍历的时候，我们需要注意到因为是环形队列，需要从front开始遍历，遍历到什么位置结束呢？？ 在之前我们已经求出了有效数据的个数，所以遍历元素为 front + size()。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 显示队列的所有数据  public void show() { if (isEmpty()) { System.out.println(\"该队列为空，无任何数据可以显示~\"); return; } // 遍历时，从front开始遍历，遍历元素为 front+有效数据的个数  for (int i = front; i \u003c front + size(); i++) { System.out.printf(\"arr[%d]=%d\\n\", i % maxSize, arr[i % maxSize]); } }   8、显示队列的头数据 因为front指向的队列的一个元素的位置，所以直接返回即可。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示队列的头数据  public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无头数据可显示~\"); } return arr[front]; }    三、结束语 到此，我们了解了关于数组模拟循环队列的相关操作，在判断队列是为满的时候，可以尝试画图理解，（记住要队列要空出一个位置，留作约定哦！）还有一个难点，求出有效数据个数。其余方法，根据数组模拟队列做出相应的调整即可（由于front和rear指向的位置不同而做出的改变）。\n源码地址 ——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构--数组模拟环形队列","uri":"/tech/datastructes/circlearrayqueue/"},{"categories":null,"content":"数组模拟队列  一、基本介绍 1、队列介绍：   队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用数组或是链表来实现。\n  遵循先入先出的原则，允许插入的一端称为队尾，允许删除的一端称队头。\n  2、举例说明： 队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是先入先出的原则。\n二、算法实现 1、所需元素及其方法 在实现数组模拟队列的时候，我们需要先定义一个ArrayQueue类来存放所需的元素以及相关方法，所需元素有：数组arr[]：用于存放数据，模拟队列；数组的最大容量maxSize；队列头front；以及队列尾rear。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。\n代码实现如下：\n1 2 3 4  private int maxSize;// 表示数组的最大容量  private int front;// 队列头  private int rear;// 队列尾  private int[] arr;// 该数组用于存放数据，模拟队列   2、初始化相关变量 在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量maxSize，这时数组可以存放maxSize的数据，但数组下标的范围为arr[0]--arr[maxSize - 1]。为front和rear赋值为-1，即队列的前一个位置。\n代码实现如下：\n1 2 3 4 5 6 7  // 创建队列的构造器  public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1;// 指向队列头部，front是指向队列头的前一个位置  rear = -1;// 指向队列的尾部，rear是队列最后一个数据  }   3、判断队列是否为满 ​\t在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在不断变大。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即rear == arr[maxSize - 1]。\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return rear == maxSize - 1; }   4、判断队列是否为空 ​\t在初始状态下，front和rear均指向下标为-1的同一个位置，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向同一个下标的时候，表示所有数据已经全部出队列。所以当rear == front时，队列空。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return front == rear; }   5、添加数据到队列 在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 添加数据到队列  public void addQueue(int n) { // 首先判断队列是否为满  if (isFull()) { System.out.println(\"该队列已满，无法添加任何数据~\"); return; } rear++;// 让rear后移  arr[rear] = n; }   6、取出队列的数据 在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 获取队列的数据，出队列  public int getQueue() { // 首先判断队列是否为空  if (isEmpty()) {// 这里可以通过抛出异常处理  throw new RuntimeException(\"该队列为空，无法取出任何数据\"); } front++;// 让front后移  return arr[front]; }   7、显示队列所有数据 我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。注意在执行出队列的操作之后，front的值也随之后移，而且front指向的位置为队列的前一个位置，所以遍历的起始位置应该为front + 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示队列所有数据  public void showQueue() { // 先判断是否为空  if (isEmpty()) { System.out.println(\"该队列为空，无数据可显示~\"); return; } // 遍历  for (int i = front + 1; i \u003c arr.length; i++) { System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); } }   8、显示队列头的信息 需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要front + 1。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示头队列的信息，注意不是取出数据  public int headQueue() { // 先判断是否为空  if (isEmpty()) { throw new RuntimeException(\"队列为空，无数据可显示\"); } return arr[front + 1]; }   三、结束语 至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——\u003e 数据结构。\n 《大话数据结构》——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构--数组模拟队列","uri":"/tech/datastructes/arrayqueue/"},{"categories":null,"content":"稀疏数组  一、基本介绍 1、实际需求 假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：\n0 0 0 2 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用稀疏数组来保存该数组。\n2、相关概念 基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：\n   行 列 值     A B C   E F G     A：表示总行数 B：表示总列数 C：表示真正有效数值的个数（除0外的数值） E：表示该元素所在的行 F：表示该元素所在的列 G：表示该元素的数值  所以上述原始的二维数组转化成稀疏数组，应该如下：\n   row col value     10 10 4   0 3 2   1 3 1   1 4 2   2 2 1    ​\n 二、算法实现 1、创建并输出原始二维数组 ①创建原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  // 0表示没有棋子，1表示黑子，2表示白子  int chessArr1[][] = new int[10][10];// 创建一个原始的二维数组 10*10  chessArr1[1][3] = 1; chessArr1[1][4] = 2; chessArr1[2][3] = 1; chessArr1[0][3] = 2;\t  ②打印输出原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr1) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); }   2、将二维数组转换成稀疏数组 ①先遍历二维数组，记录非0数值的个数 ​\t遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8  int sum = 0;// 用于记录非0数值的个数  for (int i = 0; i \u003c chessArr1.length; i++) { for (int j = 0; j \u003c chessArr1.length; j++) { if (chessArr1[i][j] != 0) { sum++; } } }   ②创建对应的二维数组 ​\t在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。\n代码实现如下：\n1 2 3 4 5  int sparseArr[][] = new int[sum + 1][3]; // 给稀疏数组赋值  sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = sum;   ③遍历二维数组，将非0的值存放到 sparseArr 中 ​\t在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int count = 0;// count用于记录是第几个非0数据  for (int i = 0; i \u003c sparseArr.length; i++) { for (int j = 0; j \u003c sparseArr.length; j++) { if (chessArr1[i][j] != 0) { count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } } }   ④打印输出稀疏数组 代码实现如下：\n1 2 3  for (int i = 0; i \u003c sparseArr.length; i++) { System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); }   3、将稀疏数组恢复成原始的二维数组 ①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 ​\t将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小\n代码实现如下：\n1  int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];   ②再读取稀疏数组后后几行的数据 （从第二行开始！！！） ​\t因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i = 1; 读取所有非0数据即可，其余的位置，默认值为0。\n代码实现如下：\n1 2 3  for (int i = 1; i \u003c sparseArr.length; i++) { chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; }   ③输出恢复后的二维数组 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr2) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); }    三、结束语： ​\t第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！\n​\t源码我已push到我的Github仓库，数据结构，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！\n","description":"","tags":null,"title":"数据结构--稀疏数组","uri":"/tech/datastructes/sparsearray/"},{"categories":null,"content":"前言 大政的Blog就这样稀里糊涂的开通了。\n 有时候闲着无聊，总想着写点什么，可能是乱七八糟的想法，可能是一段书评，也有可能是一段歌词。因为相对于话语的直白，文字能表达的情感是更加细腻的，它也可以将有些事情一直保存下去。\n也有可能是我天生就有点内向，甚至比较丧，不太喜欢说话。\n 当时之所以想开通Blog最主要是想督促自己保持学习的习惯，并且可以在这里记录一些关于学习的笔记。也有一部分原因是在这段时间接触了许多之前没有接触过的人和事，总想着这些美好的事和可爱的人更应该被文字所记录，而不是埋藏在我的心里。\n所以博客的内容可能是一串代码，一行文字，一条书评，一段歌词，或许是一句心里话。\n我既做不上神明，那当个野兽也好。\n","description":"","tags":null,"title":"Hello World ! Hello Blog !","uri":"/life/hello/"}]