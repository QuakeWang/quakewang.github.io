[{"categories":null,"content":"冒泡排序 一、前言 回想起来，当时一开始接触编程的时候，在学完循环和数组之后，老师便给我们讲解了冒泡排序 ，老师还开玩笑说这种排序的算法最简单，相对而言也最容易理解。但对于当时的我们来说听得还是云里雾里的。\n 冒泡排序（Bubble Sort） 一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。\n 因为排序的过程就像是水中的气泡一样往上冒，因此得名叫做冒泡排序。下面举一个简单的栗子：\n原始数组：3，9，-1，10，20\n 第一趟排序：  1）3，9，-1，10，20 // 如果相邻的元素逆序就交换\n2）3，-1，9，10，20\n3）3，-1，9，10，20\n4）3，-1，9，10，20\n 第二趟排序：  1）-1，3，9，10，20 //交换\n2）-1，3，9，10，20\n3）-1，3，9，10，20\n 第三趟排序：  1）-1，3，9，10，20\n2）-1，3，9，10，20\n 第四趟排序：  1）-1，3，9，10，20\n小结：\n 一共进行 数组的大小 - 1 次 大的循环； 每一趟排序的次数在逐渐的减少。  ","description":"","tags":null,"title":"BubbleSort","uri":"/tech/bubblesort/"},{"categories":null,"content":"说起 《三体》 ，想必大家并不陌生，大约从初中就听说过这套书，但很遗憾的是，当时的我并不喜欢读书，直到现在，也就是大二的时候才读完。但庆幸的是，有些书幸好没有那么早的草草地过一遍，要不书中想表达的含义，在当时的经历与心境来说是无法理解和体会的。\n 地球生命真的是宇宙中偶然里的偶然，宇宙是个空荡荡的大宫殿，人类是这宫殿中唯一的一只小蚂蚁。这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉人就老了……\n 这是《三体1》当中叶文洁，对伪主人公汪淼所说的一段话，也是全书中我比较喜欢的一段话。读完书之后，在翻阅之前做的笔记的时候，看到这段。不得不佩服大刘的思维，在读第一本的时候，可能会觉得这只是叶文洁的感叹。但通读全书之后，何尝又不是每个读者心里发出的一声叹息呢。。从宏观的角度来看，与浩渺的宇宙相比，人类确实只是一粒尘埃。但同时，人类是幸运的，生活在地球上。可悲的是，人类本身却不知道爱惜这块土地。\n反观叶文洁，为何要给三体人发信息呢？？甚至不惜犯了反人类罪。当从汪淼的视角，第一次看见叶文洁的时候，不免觉得这样一位老太太有点可怜，失去了自己的女儿，看着她那照看小区里邻居家小孩的样子，哪能想得到是ETO的统帅。。 但结合叶文洁的遭遇，也不难发现，她之所以决定把三体人引来都是有原因的，甚至不惜牺牲丈夫的生命，是人类一次又一次的做出违反道德底线的事情，在文革那个特殊时期，国将不国，人成非人。从而给叶文洁的心中埋下不相信人类的种子，当来到红岸基地之后，凭借自己的技术和手段，在收到三体人的警告：“不要回答！不要回答！不要回答！” 但她还是毫不犹豫地发送信息，暴露出地球的坐标，也就有了三体以后的故事。\n全书中，我最喜欢的角色是：章北海 ；最欣赏的应该是： 维德 。一个是要多想，一个是前进，不择手段的前进！之前，在还没读《三体》之前，隐隐约约看了点书评之类的，知道章北海是一个坚定的失败主义者，那时候就在想，既然是一个失败主义者，为何还有那么多人粉他呢？？不是应该被批评的嘛？？所以一开始对于章北海并没有什么太好的印象，甚至还有点反感。。。。在读到的《黑暗森林》的时候，面对三体人的来临，几乎所有人都慌张失措的时候，联合国更因此，制定了反人类的面壁计划。在这个条件下，反观章北海，没有面壁者的权利有义务，却成为了一个合格的民间面壁者。当大刘写到他问自己的父亲，下一步该怎么做的时候，父亲告诉他：“北海，我只能告诉你那以前要多想”。设想一下，如果我们自己在当时的环境下，我们该如何去做？？更多的可能是崩溃，但他没有。知道人类的特性都明白，逃亡主义是不可能实现的，但面对敌我实力的悬殊，也唯有逃亡，才能为人类文明的延续留下火种，尽管流浪在宇宙中的新人类，已经成为非人。\n","description":"","tags":null,"title":"读后感——《三体》","uri":"/life/threebody/"},{"categories":null,"content":"八皇后问题 一、前言 1、问题描述 八皇后问题（英文：Eight queens），是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出的问题，是递归回溯的典型案例。\n 问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以编程解决此问题。\n 2、思路分析 我们的主要思路是通过一行一行的放置皇后，来使得每一行都有一个皇后。当然，这些皇后在放置时都必须要满足规定的要求才行。\n因此就会出先如下情况:  放置时不符合规则，继续检索同一行的下一列位置是否合理 如果符合规则就将其放置，然后进行下一行的尝试（递归） 如果有某一行没有可行的解，则退回上一行，消除上一行摆放的皇后，检索剩余的列，看是否有合理的位置，然后继续进行。(回溯) 直到所有的行都被放置为止。  具体操作： 1)第一个皇后先放第一行第一列;\n2)第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适；\n3)继续第三个皇后，还是第一列、第二列......直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解；\n4)当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到；\n5)然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤。\n注意条件： 需要注意的是，我们在放置皇后时需要检测其防止和理性的判断条件为:\n 同一列的上方所有行中是否有皇后 左上方对角线上是否有皇后 右上方对角线上是否有皇后  说明： 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.arr[8]={0,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后，arr[i]=val,val表示第i+1个皇后，放在第i+1行的第val+1列\n 二、算法实现 1、定义相关变量 int max = 8; 定义max变量用于表示有多少个皇后；\nint[] array = new int[max]; 定义数组array，保存皇后放置位置的结果。\n2、输出皇后位置 因为我们使用的是一维数组，所以直接遍历输出该数组即可。\n代码实现如下：\n1 2 3 4 5 6 7  // 输出皇后摆放的位置  private void print() { for (int value : array) { System.out.print(value + \" \"); } System.out.println();// 换行  }   3、检查冲突 该方法用于 查看放置第n个皇后，检测该皇后是否和前面已经摆放的皇后冲突。这里我们使用一个boolean类型 的方法用于判定。如果不冲突就返回true ，否则返回false 。这里我们传入一个n表示是第几个皇后，如果n = 1，就表示是第一个皇后，需要检查的冲突也就是其本身；如果n = 2，表示是第二个皇后，需要检查的冲突是和第一个皇后的冲突，以此类推……所以可以使用for循环遍历，从第一个皇后开始，直到遍历到其本身为止。for(int i = 0; i \u003c n; i++)\n那么判断是否冲突需要遵守的规则是：同一行、列以及对角线不能有皇后。由于我们是使用一维数组来存储皇后摆放的位置，所以就不用判断放置的两个皇后是否在同一行的情况咯。array[i] == array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一列；Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * @param n 表示第n个皇后 * @return 如果不冲突返回true，否则返回false */ private boolean judge(int n) { for (int i = 0; i \u003c n; i++) { /* 说明： 1、array[i] == array[n] 示判断第n个皇后是否和前面的n-1个皇后在同一列 2、Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线 */ if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) { return false; } } return true; }   4、放置皇后 我们传入一个变量n表示放置第n个皇后，当n == max 表示8个皇后已经全部放置完毕，直接打印输出即可，并使用return; 语句跳出方法体。\n然后我们利用for循环依次放入皇后for(int i = 0; i \u003c max; i++)，首先把当前的这个皇后n放入到第1列，然后判断是否冲突，如果不冲突执行check(n + 1); 也就是开始放置下一个皇后；如果冲突，则就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 方法：放置第n个皇后  // 特别注意：check是每一次递归时，进入到check中都有for(int i = 0; i \u003c max; i++)，因此会有回溯  private void check(int n) { if (n == max) {// n = 8 时，表示8个皇后已经全部安放好  print(); return; } // 依次放入皇后，并判断是否冲突  for (int i = 0; i \u003c max; i++) { // 先把当前和这做个皇后n，放到该行的第1列  array[n] = i; // 判断当放置第n个皇后到i列时，是否冲突  if (judge(n)) {// 不冲突  check(n + 1); } //如果冲突，就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置  } }    三、结束语 以上便是关于八皇后问题的简单描述，理解起来可能有些许困难，比如为什么使用一维数组存放数据，如何检查冲突以及整个放置过程中的回溯都是值得动脑筋思考的。\n源码 ——\u003eQueue8\n","description":"","tags":null,"title":"递归应用——八皇后","uri":"/tech/8queen/"},{"categories":null,"content":"今天想说说 关于知足 、 大家经常说“知足常乐”，但对于知足却没有一个明确的定义。\n 语出《道德经》。认为“祸莫大于不知足”，不知满足，进而追求，定招灾祸。知其足，不追求，安于所得，无为无德，反而常常满足。知足才能避免灾祸，才能全生保身。\n 今天我为数不多的一位朋友，遇到了点烦心事，和我唠嗑。然后我对她说“知足就好。” 她说：“ 我太喜欢这个词了，知足常乐”\n但怎么说呢、知足是个好词，每个人都渴望知足，但是从我的角度来说：其实我想要的是比知足多一丢丢，这样才能因为知不足，而保持学习。怎么说呢？ ？ 知足确实是挺好的，但是人在成长的过程中，往往会由于自己的贪婪或者说是欲望，而不断提高对于要求。从而就变得不那么知足，甚至有点贪得无厌。其实我感觉这些都是人之常情，如果所有人都安于泛泛而谈的知足，那么又有谁来推动社会的进步呢？？\n其实这种想法也是不对的，把贪婪说成知足，把知足说成安逸。我所理解的知足，是一种享受状态，是在于知道自己想得到什么之后，不用多想其他的什么，是完成目标之后的，有点小小的满足，甚至是骄傲的感觉，似乎整个世界都没有烦心事了，又好似整个世界的事情都与自己无关，可以安安稳稳地去做自己想做的事情，没有为了目标而去努力的劳累感。就这样，一切都安静了。。\n","description":"","tags":null,"title":"谈谈知足","uri":"/life/%E7%9F%A5%E8%B6%B3/"},{"categories":null,"content":"迷宫问题 一、前言 在上一篇博客中，我们了解了关于递归的一些基本知识，这次我们讲一下递归的应用——走迷宫。\n我们利用二维数组构建一个迷宫，其中1表示墙，0表示可以的走的路，2表示走过的路。 可以在迷宫中设置挡板，也用1表示。然后利用递归给小球找路。在走迷宫时，我们需要确定一个策略，不能盲目地瞎走，要不然岂不是在里面绕圈圈，哈哈哈哈。策略如下：下-\u003e右-\u003e上-\u003e左，如果该点走不通，再回溯。下面我们开始代码实现一把。\n 二、算法实现 1、创建迷宫 我们先定义一个二维数组map 表示地图。然后再分别将四周（上下左右）设置为墙。再在需要的位置设置挡板，增加出迷宫的难度。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 先创建一个二维数组，模拟迷宫  int[][] map = new int[8][7]; // 使用1表示墙  // 将上下全部置为1  for (int i = 0; i \u003c 7; i++) { map[0][i] = 1; map[7][i] = 1; } // 将左右全部置为1  for (int i = 0; i \u003c 8; i++) { map[i][0] = 1; map[i][6] = 1; } // 设置挡板  map[3][1] = 1; map[3][2] = 1;   2、递归找路 这里我们使用递归setWay(int[][] map, int i, intj)方法，来寻找路线。map 表示地图、传入的i, j 表示小球的起始位置；将终点设置为map[6][5] （除去墙在地图中所占的位置）。如果小球你找到通路，就返回true ，否则返回false 。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true，否则返回false */ public static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) {// 如果当前这点还没有走过  // 按照策略 下 -\u003e 右 -\u003e 上 -\u003e 左 走  map[i][j] = 2;// 假定该点可以走通  if (setWay(map, i + 1, j)) {// 向下走  return true; } else if (setWay(map, i, j + 1)) {// 向右走  return true; } else if (setWay(map, i - 1, j)) {// 向上走  return true; } else if (setWay(map, i, j - 1)) {// 向左走  return true; } else { // 说明该点是走不通，是死路  map[i][j] = 3; return false; } } else {// 如果map[i][j] != 0 可能是1、2、3  return false; } } }    三、结束语 对于迷宫的问题的描述就到这里，总体而言是比较简单的。具体的递归过程可以进行debug一下，更有助于理解。\n源码 ——\u003eMiGong\n","description":"","tags":null,"title":"递归——解决迷宫问题","uri":"/tech/migong/"},{"categories":null,"content":"TwoSum 一、题目概述  给定一个整数数组 nums 和一个目标值 target ，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n 示例：\n给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  二、解法分析 对于这个题目想必大家并不陌生，可以说是绝大多数人的开始刷题之路的敲门砖。如果是一开始起初接触刷题的朋友，看到这题，可能没有思路，也可能是暴力解法 ，对于我自己就是使用双重for循环遍历暴力解，：）\n下面将使用双重for循环和HashMap两种解法供大家参考：\n1、暴力解法 我们首先来简单的分析一下题目：需要从nums数组中寻找两个数，使这两个数的和等于目标值target，并且数组中同一元素不能使用两次。所以我们可以使用for循环来寻找，外层循环的条件是for(int i = 0; i \u003c nums.length; i++) 即从数组的第一个下标开始遍历，直到遍历到数组结束；内层循环的条件是for(int j = i + 1; j \u003c nums.length; j++) 注意内层循环开始的条件不是从数组的第一个下标开始的，而是从nums[i] 的下一个位置开始遍历，结束条件相同。\n就这样，咱们使用双重for循环如此暴力的遍历，直到遇见了符合nums[i] + nums[j] == target  条件时，返回数组对应的下标即可；如果遍历结束之后，仍然没有在该数组中找到需要的数，则抛出异常。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 使用for循环遍历 暴力解题  public int[] twoSum02(int[] nums, int target) { for (int i = 0; i \u003c nums.length; i++) { for (int j = i + 1; j \u003c nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } throw new IllegalArgumentException(\"Two Sum No Solution\"); }   2、HashMap解法 对于哈希表这种数据结构，这里就不做具体的说明，想要了解的小伙伴可以自己查阅一下相关文档。\n我们先定义一个数组res[] 用于存放最后返回的结果。然后再创建一个哈希表，HashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); 然后对于这个数组进行遍历，每次遍历的时候取出一个数，然后再map 中查询，是否能找到一个合适的数，使两者之和等于目标值target ，如果找到直接返回即可；否则，将该数加入map 。依次进行遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 使用HashMap来解决该问题  public int[] twoSum01(int[] nums, int target) { int[] res = new int[2];// 存放返回的结果  if (nums == null || nums.length \u003c= 1) {// 判断传入的数组是否符合条件  return res; } HashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e();// 创建哈希表  for (int i = 0; i \u003c nums.length; i++) { int num = nums[i]; int val = target - num; if (map.containsKey(val)) {// 在map中寻找  res[0] = map.get(val); res[1] = i; return res; } else { map.put(num, i); } } return res; }    3、结束语 这个也算是开的一个新坑吧，虽然数据结构篇还没有完结。。。。刷题，几乎是一个程序猿的必经之路。大家一起加油！！！\n源码地址 —\u003e TwoSum\n","description":"","tags":null,"title":"TwoSum","uri":"/leetcode/twosum/"},{"categories":null,"content":"关于递归 一、前言 说起递归，可能有些同学会问，什么是递归啊？？ 我们举个简单的栗子：如果你站在镜子前面，这时你会在镜子中看见自己的像，称这个镜子为A；那么有没有试一下在手里也拿一面镜子，把手里的镜子称为镜子B，然后将A、B两面镜子互相面对面放着，你再往中间那么一站，神奇的情况发生了，将会发现两面镜子中都有你的“化身”。为什么会出现这种现象呢？？原来，A镜子里有B镜子的像，B镜子里也有A镜子的像，这样反反复复，就会产生一连串的“像中像”。这其实就是一种递归现象。\n说简单点，就是递归就是方法自己调用自己，每次调用时传入不同的变量。（递归有助于开发者解决复杂的问题，同时可以让代码变得更简洁）\n 二、递归规则 递归需要遵守的重要规则：\n1）执行一个方法时，就创建一个新的受保护的独立空间（栈空间）；\n2）方法的局部变量是独立的，不会相互影响，比如n变量；\n3）如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据；\n4）递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了 : ) ；\n5）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时方法执行完毕或者返回时，该方法也就执行完毕了。\n 三、斐波那契数列 1、概要 **斐波那契数列（Fibonacci）**是一个典型的递归例子，说如果兔子在出生两个月之后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有的兔子都不死。那么，一年以后可以繁殖多少对兔子？？\n我们拿新出生的一对小兔子来分析一下：第一个月的小兔子是没有繁殖能力的，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月后，老兔子又生下一对，因为上个月出生的小兔子还没有繁殖能力，所以还是一共还是三对……依次类推，可以列出下表：\n   所经过的月数 1 2 3 4 5 6 7 8 9 10 11 12     兔子对数 1 1 2 3 5 8 13 21 34 55 89 144    表中数字1,1,2,3,5,8,13……构成一个序列。这个数列有个明显的特点就是：前面相邻两项之和，构成了后一项。\n2、常规解法 先思考一下，如果我们要实现斐波那契数列用常规的迭代方法应该如何实现？\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int[] a = new int[13]; a[0] = 0; a[1] = 1; System.out.println(\"未使用递归计算：\"); System.out.println(\"a[0] = \" + a[0]); System.out.println(\"a[1] = \" + a[1]); for (int i = 2; i \u003c a.length; i++) { a[i] = a[i - 1] + a[i - 2]; System.out.printf(\"第%d个月兔子总数为：%d\", i, a[i]); System.out.println(); }   我们来简单看一遍这段代码，数组a[]表示从第0月到第12月，其中第0个月没有任何兔子，第一个月有一对兔子，然后我们利用for循环，从第2个月开始计算，即下一个月的兔子数为前两个月兔子数相加。\n代码很简单，几乎不用怎么解释，都可以理解，但其实，我们如果使用递归来实现，代码将会更加整洁。\n3、递归解法 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 使用递归计算  System.out.println(\"使用递归计算如下：\"); for (int i = 0; i \u003c a.length; i++) { System.out.printf(\"第%d个月兔子总数为：%d\", i, Fbi(i)); System.out.println(); } // 使用递归的方法处理  public static int Fbi(int i) { if (i \u003c 2) { return i == 0 ? 0 : 1; } else { return Fbi(i - 1) + Fbi(i - 2); } }   虽然代码整体而言要简洁许多，但却并不是那么好理解。函数怎么可以自己调用自己？？听起来确实有些难以理解，不过我们可以不把一个递归函数中调用自己的函数看作是在调用自己，而就当它是在调用另一个函数。只不过，这个函数和自己长得一样而已。\n我们来模拟代码中的Fbi(i)函数当i = 5的执行过程。Fbi(5) = Fbi(4) + Fbi(3) = Fbi(3) + Fbi(2) + Fbi(2) + Fbi(1) = Fbi(2) + Fbi(1) + 1 + 1 + 1 = 1 + 1 + 1 + 1 + 1 = 5\n三、结束语 我们来对比一下这两种实现斐波那契的代码。迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归可以使程序的结构更清晰、更简洁、更容易让人理解。从而有效地减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同的情况选择不同的代码实现方式。\n斐波那契数列源码地址 ——\u003e Fibonacci\n 《大话数据结构》 ——程杰\n ","description":"","tags":null,"title":"数据结构——递归","uri":"/tech/recursion/"},{"categories":null,"content":"后缀表达式——代码讲解 一、前言 在上一篇博客中我们介绍了有关后缀表达式的有关知识，关于如何将中缀表达式转换为后缀表达式，以及后缀表达式的运算规则，做了详细的介绍。因此这篇博客将会用代码来实现一个完整的后缀表达式。\n 二、算法描述 1、将后缀表达式的数据和运算符放入到ArrayList中 我们会获取到一个String类型的后缀表达式，因为对于字符串类型是无法正常完成计算的，因此需要先将后缀表达式里面的数据和运算符按照空格\" \"分割开，然后存放到ArrayList中。\n这里会用到foreach遍历字符串，每遍历一个元素，再利用 list.add() 方法加入到List中，然后返回List即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 依次将一个逆波兰表达式的数据和运算符放入到ArrayList中  public static List\u003cString\u003e getListString(String suffixExpression) { // 将suffixExpression按照空格“ ”分开  String[] split = suffixExpression.split(\" \"); List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (String ele : split) { list.add(ele); } return list; }   2、后缀表达式的运算 关于运算规则，在上一篇博客中已经做过说明，所以这里就不做过多的赘述。我们通过栈来存放扫描到的数字（这里使用正则表达式来判断是否是多位数）。扫描表达式的时候如果遇见运算符，则分别取出栈顶元素和次顶元素，进行计算，并把运算结果再重新入栈。最后留在栈中的数就是该表达式最后的运算结果。需要注意的是：在进行减、除运算的时候，需要注意栈顶元素和次顶元素的位置。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public static int calculate(List\u003cString\u003e ls) { // 创建一个栈（在这里只需要一个栈即可）  Stack\u003cString\u003e stack = new Stack\u003cString\u003e(); // 遍历ls  for (String item : ls) { // 使用正则表达式来取出数  if (item.matches(\"\\\\d+\")) {// 匹配的是多位数  // 入栈  stack.push(item); } else { // pop出两个数，并运算，再入栈  int num1 = Integer.parseInt(stack.pop()); int num2 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\")) { res = num2 + num1; } else if (item.equals(\"-\")) { res = num2 - num1; } else if (item.equals(\"*\")) { res = num2 * num1; } else if (item.equals(\"/\")) { res = num2 / num1; } else { throw new RuntimeException(\"输入的运算符有误！！！\"); } // 把res入栈  stack.push(\"\" + res);// 加上双引号即可转换为字符串形式  } } // 最后留在stack中的数据就是运算结果  return Integer.parseInt(stack.pop()); }    通过上述两种方法，可以实现对于后缀表达式的直接运算。但后缀表达式是计算机容易理解，而相对于人而言，其转换过程是比较头疼的，所以接下来我们实现关于中缀表达式转换后缀表达式的方法。\n 3、将中缀表达式转换成对应的List 对于一个字符串，我们是无法进行操作的，所以首先要做的就是先把中缀表达式转成对应的List。\n需要的变量有： ls(List) 用于存放扫描得到的元素； i(int) 当作指针，用于扫描中缀表达式； str(String) 用于多位数的拼接； c(char) 每遍历一个字符，就放入到c。\n这里我们使用do……while循环来进行遍历，循环的条件是i \u003c s.length();扫描遇到的如果是操作符，直接加入即可；如果是数字，则每次添加的时候先将str置空，然后利用str += c拼接多位数。每次扫描到一个元素之后，指针i需要进行后移，可以利用ASCII码来判断数字的范围，然后进行相关操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 将中缀表达式转换成对应的List  public static List\u003cString\u003e toInfixExpressionList(String s) { // 定义一个List，存放在中缀表达式中对应的内容  List\u003cString\u003e ls = new ArrayList\u003c\u003e(); int i = 0;// 这是一个指针，用于遍历中缀表达式字符串  String str;// 用于多位数的拼接  char c;// 每遍历一个字符，就放入到c  do { // 如果是一个非数字，就需要加入到ls  if ((c = s.charAt(i)) \u003c 48 || (c = s.charAt(i)) \u003e 57) { ls.add(\"\" + c); i++;// i需要后移  } else {// 如果是一个数，需要考虑多位数的情况  str = \"\";// 先将str置空“ ”  while (i \u003c s.length() \u0026\u0026 (c = s.charAt(i)) \u003e= 48 \u0026\u0026 (c = s.charAt(i)) \u003c= 57) { str += c; i++; } ls.add(str); } } while (i \u003c s.length()); return ls;// 返回  }   4、将中缀表达式对应的List转换成后缀表达式 关于中缀表达式转换的规则，在之前也进行过相关的阐述，这里也就不再细说了，不过需要注意的是转换之后的后缀表达式对应的也是List。对于运算符符号操作的时候，我们需要比较运算符的优先级，所以定义一个类，用于返回运算符的优先级。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 编写一个类Operation class Operation { private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; // 编写一个方法，返回对应的优先级数字  public static int getValue(String operation) { int result = 0; switch (operation) { case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; default: System.out.println(\"不存在该运算符\" + operation); break; } return result; } }   具体操作代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 将得到的中缀表达式对应的List转换成后缀表达式对应的List  public static List\u003cString\u003e parseSuffixExpressionList(List\u003cString\u003e ls) { // 定义一个栈，用于存放扫描所得到的符号  Stack\u003cString\u003e s1 = new Stack\u003c\u003e();// 符号栈  // 定义一个ArrayList用于存储中间的结果  List\u003cString\u003e s2 = new ArrayList\u003c\u003e(); // 遍历  for (String item : ls) { // 如果是一个数，加入s2  if (item.matches(\"\\\\d+\")) { s2.add(item); } else if (item.equals(\"(\")) { s1.push(item); } else if (item.equals(\")\")) { // 如果是右括号\")\"，则依次pop出s1栈顶的运算符，并加入s2，直到遇见左括号为止，此时将这一对括号丢弃  while (!s1.peek().equals(\"(\")) { s2.add(s1.pop()); } s1.pop();// 将 ( 弹出s1栈，消除小括号  } else { // 当item的优先级小于或等于s1栈顶运算符，将s1栈顶的运算符弹出，并加入到s2中然后再与s1中新的栈顶运算符相比较  while (s1.size() != 0 \u0026\u0026 Operation.getValue(s1.peek()) \u003e= Operation.getValue(item)) { s2.add(s1.pop()); } s1.push(item); } } // 将s1中剩余的运算符依次弹出并加入到s2  while (s1.size() != 0) { s2.add(s1.pop()); } return s2;// 注意：因为是存放到List，因此按顺序输出就是对应后的后缀表达式对应的List  }    三、结束语 对于栈的应用，使用了中缀表达式和后缀表达式来进行说明，由此可见，想把数据结构学好还是得下一定功夫的，世界上没有随随便便的成功，一步一步踏踏实实地向前走。\n源码 —— \u003e PolandNotation\n","description":"","tags":null,"title":"栈的应用——后缀表达式02","uri":"/tech/polandnotation02/"},{"categories":null,"content":"后缀表达式——预备知识 一、前言 在上一篇博客中，我们介绍了中缀表达式的相关操作过程，虽然中缀表达式比较符合我们的日常使用习惯，但是对于计算机却不那么容易去理解，因此有了我们今天要介绍的——后缀表达式。\n例如：( 3 +4 ) * 5 - 6 对应的后缀表达式就是3 4 + 5 * 6 -，那么这个操作过程是怎么实现的呢？？以及后缀表达式该如何进行运算呢？？在下面的内容，我们来一探究竟。\n 二、中缀表达式转后缀表达式 1、规则： 1）初始化一个运算符栈s1和一个用云储存中间结果的List s2；\n2）从左到右扫描中缀表达式；\n3）如果遇到操作数，直接加入到s2；\n4）如果遇到运算符，则比较其与s1栈顶元素的优先级：\n4.1）如果s1为空，或栈顶运算符为左括号\"(\"，则直接将此运算符入栈；\n4.2）若当前运算符比栈顶运算符的优先级高，也将此运算符入栈；\n4.3）否则，将s1栈顶的运算符弹出并加入到s2中，然后再回到4.1）与s1中新的栈顶运算符相比较；\n5）遇到括号时：\n5.1）如果是左括号\"(\"，则直接压入s1；\n5.2）如果是右括号\")\"，则依次弹出s1栈顶的运算符，并加入s2，直到遇见左括号为止，此时将这一对括号丢弃；\n6）重复上述步骤 2）至 5），直到表达式的最右边；\n7）再将s1中剩余的运算符依次加入到s2；\n8）依次输出s2中的元素，输出结果就是相对应的后缀表达式。\n2、举例说明 将中缀表达式\"1+((2+3)*4)-5\"转换为后缀表达式的过程如下：\n   扫描到的元素 s2（表头—\u003e表尾） s1（栈底—\u003e栈顶） 说明     1 1 空 数字，直接加入到s2   + 1 + s1为空，运算符直接入栈   ( 1 + ( 左括号直接入栈   ( 1 + ( ( 左括号直接入栈   2 1 2 + ( ( 数字，直接加入到s2   + 1 2 + ( ( + s1栈顶为左括号，运算符直接入栈   3 1 2 3 + ( ( + 数字，直接加入到s2   ) 1 2 3 + + ( 右括号，弹出s1中的运算符，直至遇到左括号   * 1 2 3 + + ( * s1栈顶元素为左括号，运算符直接入栈   4 1 2 3 + 4 + ( * 数字，直接加入到s2   ) 1 2 3 + 4 * + 右括号，弹出s1中的运算符，直至遇到左括号   - 1 2 3 + 4 * + - -与＋优先级相同，因此弹出+，再压入-   5 1 2 3 + 4 * + 5 - 数字，直接加入到s2   到达最右端 1 2 3 + 4 * + 5 - 空 s1中剩余的运算符     三、后缀表达式运算 后缀表达式的运算还是利用栈这种数据结构，这里我们利用\"3 4 + 5 * 6 -\"这个后缀表达式来进行说明：\n1、规则：  从左到右遍历表达式的每个数字和字符，遇到是数字就进栈，遇到是运算符，就将处于栈顶两个数字（栈顶元素和次顶元素）出栈，进行运算，运算结果进栈，一直到最终获得结果。\n 2、具体操作： 1）从左至右扫描，将3和4压入栈；\n2）遇到+运算符，依次弹出4和3（4为栈顶元素，3为次顶元素），并计算4 + 3的结果，得7，再将7入栈；\n3）将5入栈；\n4）接下来是*运算符，依次弹出5和7，计算出7 * 5 = 35，将35入栈；\n5）将6入栈；\n6）最后是-运算符，计算出35-6的值，即29，由此得出最终结果。\n 三、结束语 因为后缀表达式相对而言是比较复杂的，所以我们分两篇博客进行讲解，这里先介绍的是如何将中缀表达式转换为后缀表达式以及后缀表达式的运算。在下一篇博客中，将进行具体的代码说明。\n","description":"","tags":null,"title":"栈的应用——后缀表达式01","uri":"/tech/polandnotation01/"},{"categories":null,"content":"中缀表达式 一、前言 栈的现实应用有很多，这次我们重点来说一下，关于如何使用栈来求数学表达式的值，这里我们描述的为中缀表达式，也就是我们在日常生活中经常使用的四则运算式的形式。\n大家是否还记得，当我们在上小学的时候，老师们时常强调的“先乘除后加减，从左往右算”之类的话呢？？这其实就是四则运算的规则，那么在我们学习编程之后，该如何使用程序来解决这个问题呢？？\n二、算法描述 我们需要一个栈来存放数据（数栈numStack）和另一个栈来存放运算符（符号栈operStack）。那么在此之前，我们需要定义一个类来表示栈。\n1、定义一个类表示栈 在这个类中，我们需要完成的方法有：判断栈满栈空、入栈、出栈、查看栈顶元素、判断是否是运算符、比较运算符的优先级以及运算方法。\n在这里有些方法以及变量的说明，在数组模拟栈已经做出相关说明，这里就直接使用，不做过多的解释。\n①定义相关变量及赋值 代码实现如下：\n1 2 3 4 5 6 7 8 9  private int[] stack;// 数组，用于模拟栈，数据就存放在该数组  private int maxSize;// 栈的大小  private int top = -1;// 表示栈顶，初始化为-1  // 构造器  public ArrayStack2(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; }   ②判断栈满 栈空 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 栈满  public boolean isFull() { return top == maxSize - 1; } // 栈空  public boolean isEmpty() { return top == -1; }   ③入栈 —— push 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 入栈 —— push  public void push(int value) { if (isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; }   ④出栈 —— pop 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 出栈 —— pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据~~~\"); } int value = stack[top]; top--; return value; }   ⑤查看栈顶元素 在这里增加一个方法，用于返回当前栈顶的值，但不是真正的top。那么有些小伙伴可能会问，为什么会在这里增加一个查看栈顶元素的方法呢？？其实我们在存放运算符入符号栈的时候，需要先判断入栈元素与栈顶元素的优先级。这里增加查看栈顶元素的方法，就不用再取出栈顶元素咯，更加有利于我们进行比较运算符的优先级。\n代码实现如下：\n1 2 3 4  // 增加一个方法，可以返回当前栈顶的值，但不是真正的top  public int peek() { return stack[top]; }   ⑥判断是否是运算符 这个方法用于判断表达式中的元素是否是运算符，如果是运算符则直接入符号栈。在这里我们只考虑\"+\"、\"-\"、\"*\"、\"/\"四种运算符。\n代码实现如下：\n1 2 3 4  // 判断是否是运算符  public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; }   ⑦比较运算符的优先级 因为进行四则运算需要遵循”先乘除后加减“的规则，所以需要规定运算符的优先级。我们在这里规定：优先级越高，则返回的数字越大。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 返回运算符的优先级，优先级是由程序猿来确定的，使用数字表示  // 这里规定：优先级越高，返回的数字越大  public int priority(char oper) { if (oper == '*' || oper == '/') { return 1; } else if (oper == '+' || oper == '-') { return 0; } else { return -1;// 假定目前表达式的运算符只有+、-、*、/  } }   ⑧计算方法 具体的计算流程如下：分别从数栈pop出两个数：num1和num2，以及从符号栈pop出一个符号：oper，然后根据pop出的符号进行相关运算。\n在这里我们需要注意的是：因为num1是先取出的，num2是后取出的，所以在进行减除运算的时候，需要注意一下顺序。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 计算方法  public int cal(int num1, int num2, char oper) { int res = 0;// res用于存放计算的结果  switch (oper) { case '+': res = num1 + num2; break; case '-': res = num2 - num1; break; case '*': res = num2 * num1; break; case '/': res = num2 / num1; break; default: break; } return res; }    2、具体运算操作 ①相关变量的定义 我们前文提到了，需要一个数栈numStack，用于存放从表达式中扫描得到的数字；再定义一个符号栈operStack，用于存放扫描得到的运算符；定义一个index用于扫描表达式；num1、num2、oper分别表示取出的数字和运算符。再定义一个字符类型的变量ch，用于存放每次扫描所得到的运算符；定义res用于存放经过计算之后的数；在对于数字进行扫描到时候，如果是多位数，不能发现是一个数就入栈，需要往后面再看一位，如果是数字就继续扫描，否则push入栈，因此需要定义一个变量keepNum用于拼接多位数。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  String expression = \"7*21*2-5+1-5+3-4+2/1\"; //创建两个栈，一个数栈，一个符号栈  ArrayStack2 numStack = new ArrayStack2(100); ArrayStack2 operStack = new ArrayStack2(100); //定义需要的相关变量  int index = 0;//用于扫描  int num1 = 0; int num2 = 0; char oper = 0; int res = 0; char ch = ' ';//将每次扫面得到的运算符保存到ch  String keepNum = \"\";//用于拼接,处理扫描到的数字是多位数   ②扫描表达式 这一步是程序的核心内容，也是运算实现的关键步骤。我们可以使用while循环来操作。\n首先，利用index索引进行扫描表达式，依次得到表达式的每一个字符，可以使用substring()来操作，即ch = expression.substring(index,index+1).charAt(0); 在得到表达式的各个字符之后，然后判断ch是什么符号。\n先假设扫描得到的ch是运算符。如果此时符号栈operStack中已经有运算符，则需要比较当前运算符和栈顶元素的运算符的优先级，如果当前的操作运算符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的运算符入符号栈。（注意：别忘了把当前的运算符push入符号栈）；如果当前的运算符的优先级大于栈中的运算符，则直接入符号栈。另外注意，我们到现在为止，所描述的都是符号栈内有操作符的情况，如果符号栈为空，直接push当前运算符入栈即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  if (operStack.isOper(ch)) {//如果是运算符  //判断当前的符号栈是否为空  if (!operStack.isEmpty()) { //如果符号栈有操作符，就进行比较，如果当前的操作运算符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数  //再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的运算符入符号栈  if (operStack.priority(ch) \u003c= operStack.priority((char) operStack.peek())) { num1 = numStack.pop(); num2 = numStack.pop(); oper = (char) operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果入数栈  numStack.push(res); //然后将当前的操作符入符号栈  operStack.push(ch); } else { //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈  operStack.push(ch); } } else { //如果为空直接入符号栈  operStack.push(ch); } }   现在我们来假设如果扫描得到的是数字，将会如何操作呢？？因为扫描得到的数字，其实是字符型，所以需要转化为整型，这里使用的是Integer。还有需要注意的就是，该如何处理多位数的问题。\n分析思路： * 1、当处理多位数时，不能发现是一个数就立即入栈，因为它有可能是多位数 * 2、在处理数时，需要向expression的表达式的index 后再看一位，如果是数就进行扫描，如果是符号才入栈 * 3、因此需要定义一个变量 字符串，用于拼接 在定义变量的时候我们提到了keepNum，可以使用它来拼接多位数，即keepNum += ch; 但是如果扫描得到的数字是最后一个数字，直接push入栈即可；如果不是最后一位，就需要往后看一位，若后面一位还是数字，则需要继续扫描，直到不是数字为止，同样可以利用substring来实现。每次扫描完成之后需要将拼接符keepNum清空，这一步是千万不能少！！！\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  else {//如果是数，则直接入数栈  //处理多位数  keepNum += ch; //如果ch已经是expression的最后一位，就直接入栈  if (index == expression.length() - 1) { numStack.push(Integer.parseInt(keepNum));//Integer将字符串转化为整型  } else { //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈  //注意是最后一位，不是index++  if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) { //如果后一位是运算符，则入栈 keepNum = \"1\" 或者 ”123“  numStack.push(Integer.parseInt(keepNum)); //重要！！！！！，keepNum清空  keepNum = \"\"; } } }   在完成上述操作之后，需要将index后移，直到index的比表达式长度的值大时，退出循环。\n代码实现如下：\n1 2 3 4 5  //让index + 1，并判断是否扫描到expr最后  index++; if (index \u003e= expression.length()) { break; }   ③完成计算 在完成扫描之后，就顺序从数栈和符号栈中pop出相应的数字和符号完成计算。\n同样可以利用while循环来完成。将最后的计算结果res入数栈。别忘了把数栈中最后的数取出，这个数就是表达式的计算结果。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行  while (true) { // 如果符号栈为空，则运算到最后的结果，数栈中只有一个数字【结果】  if (operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = (char) operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res);//入栈  } //将数栈的最后数，pop出，就是结果  int res2 = numStack.pop(); System.out.printf(\"表达式%s = %d\\n\",expression,res2); }    三、结束语 关于使用栈实现中缀表达式的描述，真的太吃力了，能明显感觉到需要描述不清晰的地方，如果小伙伴们有较好的阐述方法或者建议，都可以提交pr或者issue。\n源码——\u003e Calculator\n","description":"","tags":null,"title":"栈的应用——中缀表达式","uri":"/tech/calculator/"},{"categories":null,"content":"单链表模拟栈 一、前言 在上一篇博客中，我们开启了对于栈的数据结构的相关讲解，使用的是数组模拟栈，在这篇博客中，我们将介绍一下如何利用链表来模拟栈。\n之前对于栈这种数据结构的相关定义以及应用场景已经做了简单的说明，在此就不做过多的赘述，下面我们开始了解一下算法的实现过程吧。\n 二、算法实现 1、创建结点类 在使用链表模拟栈之前，我们需要先创建一个结点类，存放信息，以及相关的使用方法。\n该类中所包含的信息有：创建data域用于存放结点信息，next域用于指向下一个结点的指针；利用构造器传入给结点赋值的信息；以及利用toString方法显示结点信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 定义一个类表示结点 class StackNode { public int data;// data域用于存储数据  public StackNode next;// next域用于链接下一个结点  // 构造器  public StackNode(int data) { this.data = data; this.next = null; } @Override public String toString() { return \"StackNode{\" + \"data=\" + data + '}'; } }   2、创建一个类用于管理结点 ①定义相关变量以及赋值 我们可以定义一个头结点top，用来表示栈顶，再定义一个size用于表示栈的大小，并且用于记录入栈和出栈的元素。\n代码实现如下：\n1 2 3 4 5 6 7 8  private StackNode top = null;// 定义一个头结点，表示栈顶  private int size; // 初始化  public LinkedListStack() { top = null; size = 0; }   ②判断链栈是否为空 定义的头结点top是可以存放数据的，所以当top没有存放任何数据的时候，链栈为空。\n代码实现如下：\n1 2 3 4  // 判断链栈是否为空  public boolean isEmpty() { return top == null; }   ③获取有效结点的个数 在定义变量size的时候，提到size可以用来记录链栈的数据入栈和出栈情况，所以我们可以使用getSize()方法，返回的值就是当前链栈的有效结点。\n代码实现如下：\n1 2 3 4  // 获取size的大小  public int getSize() { return size;   ④入栈 —— push 链栈的入栈操作总体上来说还是比较简单的，传入一个需要添加的结点stackNode。与单链表添加结点不同的是，单链表添加的结点在链表的最后，而链栈需要保证的是所添加的结点需要在栈顶。\n因此，我们需要先将新的结点后继结点指向当前链栈的栈顶元素，即stackNode.next = top; （这时原来栈顶的位置就变成了先添加结点的后继结点的位置），然后再将新添加的结点设置为栈顶元素，即top = stackNode; （这时新添加的结点就是栈顶元素）。最后别忘记，每添加一个结点，size需要+1。\n代码实现如下：\n1 2 3 4 5 6 7  // 入栈 —— push  public void push(StackNode stackNode) { stackNode.next = top; top = stackNode; size++; }   ⑤出栈 —— pop 在出栈之前，我们需要先判断链栈是否为空，如果为空则给出相应的提示（这里我们通过抛出异常的方式来进行处理）。至于链栈的出栈操作，具体实现如下：\n先将栈顶元素临时赋值给临时变量temp保存，然后将栈顶元素toptemp的下一个结点。这时栈顶元素的信息已经保存在temp当中。紧接着，再定义一个临时变量retValue，用于存储栈顶元素的data域。在完成上述操作之后，我们还需要将 temp置空，别忘了**size--**和返回retValue。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 出栈 —— pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"链栈为空~~\"); } StackNode temp = top;// 辅助变量  top = temp.next; int retValue = temp.data;// 定义一个临时变量，用于保存栈顶元素  temp = null;// 将temp置空  size--; return retValue; }   ④显示链栈信息 显示链栈信息的方法，与单链表显示方法一样，所以我们直接上代码，哈哈哈哈哈\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示栈中信息  public void show() { if (isEmpty()) { System.out.println(\"链栈为空~~\"); return; } StackNode temp = top; while (temp != null) { System.out.println(temp); temp = temp.next; } }    三、结束语 到这里，我们完成了对于栈的两种实现方式，相对于使用链表实现，数组更容易让我们接受一点。在编写入栈和出栈方法的时候，一开始直接参照单链表的相关实现方法，因此走了不少弯路，所以在学习过程中我们需要学会比较着来学，这样可以帮助我们更好地巩固所学的知识。\n其实关于出栈操作的方法，我总觉得不够好，似乎缺少了点什么。关于临时变量temp，如果不定义temp，而是对栈顶元素直接操作，会发生些什么呢？？小伙伴们可以自己尝试一下，如果有更好的实现方法，也欢迎提出issue噢！\n源码 ——\u003e [数据结构]\n","description":"","tags":null,"title":"数据结构——链表模拟栈","uri":"/tech/linkedliststackdemo/"},{"categories":null,"content":"数组模拟栈 一、基本介绍 1、相关定义  栈是一个先入后出的有序列表； 栈是限制线性表中元素的插入和删除只能在线性表的同一段进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top）,另一端为固定的一端，称为栈底（Bottom）； 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先删除的元素最后删除。  2、应用场景  子程序的调用：在跳往子程序前，会先将下个指令的地址存放到堆中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数、区域变量等数据存入到堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。 二叉树的遍历。 图形的深度优先（depth - first）搜索法。   二、算法实现 需要构建一个ArrayStack类，用于表示栈。\n1、定义相关变量以及赋值 需要定义的相关变量有：定义一个数组模拟栈int[] stack、栈的大小maxSize以及栈顶元素top。（在这里我们把栈顶元素top的初始值为-1，有利于后期存入和删除数据）。\n定义完相关变量之后，我们可以利用构造器对maxSize和stack数组进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  private int maxSize;// 栈的大小  private int[] stack;// 数组，数组模拟栈，数据就在该数组  private int top = -1;// top表示栈顶，初始化为-1  // 构造器  public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; }   2、判断栈是否为满 因为数组的下标是从0开始的，所以当栈满时，栈顶元素的下标为stack[top] = maxSize - 1;所以当 top == maxSize - 1时，栈满。\n代码实现如下：\n1 2 3 4  // 栈满  public boolean isFull() { return top == maxSize - 1; }   3、判断栈是否为空 之前在定义相关变量的时候，我们提到top的初始值为-1，即当 top == -1时，栈中没有存入任何数据，为空。\n代码实现如下：\n1 2 3 4  // 栈空  public boolean isEmpty() { return top == -1; }   4、入栈——push 方法 在入栈之前，我们首先需要判断栈是否已满，如果栈满则给出提示，并结束程序。否则执行以下操作：由于top的初始值为-1，即数组第一个元素的前一个位置，因此需要先移动top到指定位置，然后给其赋值即可。（先后移再赋值）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 入栈——push  public void push(int value) { // 先判断栈是否未满  if (isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; }   5、出栈——pop 方法 在进行出栈操作之前，我们首先需要判断栈是否为空，如果为空，则给出相关提示（这里我们是用抛出异常的方式来进行处理）；否则，执行以下操作：先定义一个临时变量value来存储栈顶元素，然后栈顶元素top--，往前移动，最后返回临时变量即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 出栈——pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据~~~\"); } int value = stack[top]; top--; return value; }   6、打印输出栈的信息 如果栈为空，则没有任何数据可以显示，所以在输出栈的信息之前，我们需要先判断栈是否为空。在遍历的时候，我们需要从栈顶开始显示数据。可以通过for循环l来实现。\n因为是从栈顶开始显示数据，所以循环的起始位置应该为栈顶top，循环结束的条件应该为i \u003c 0，每执行一次循环，则需要i--。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 遍历栈，遍历时，需要从栈顶开始显示数据  public void show() { if (isEmpty()) { System.out.println(\"栈空，没事有数据~~~\"); return; } // 需要从栈顶开始显示数据  for (int i = top; i \u003e= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } }    三、结束语 这里我们使用的是数组模拟栈的操作，所以说对应的也可以利用链表来模拟栈，小伙伴们可以自己先尝试一下噢。\n在写代码的时候，因为是利用数组模拟栈的相关操作，不由的想起之前写过的数组模拟单向队列，两者可以进行比较的学习，可以思考一下，同样是没有取模的操作，为什么单向队列不能够进行复用，而栈却可以呢？？\n源码地址——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——数组模拟栈","uri":"/tech/arraystackdemo/"},{"categories":null,"content":"两年前的这个时候，高考也已经告一段落。一直以来，都太强调学习，满脑子里想的都是”知识改变命运“这种空而大的口号。其实这一点，直到今天，还依然未变。要不看了这么多年的书，岂不是白看了嘛？？哈哈哈哈哈……\n在高三的时候，总想着，只要再努力一点，再多背一个单词，多做一道题目，就离考了大学更进一步，但其实不然。当拿到报考指南的那一刻，还是傻眼了。似乎有一种无力感，高考查完分之后的那种兴奋再也找不到了，就在想：当时熬的夜，还值得吗？？都说付出就会有回报，但结果呢？？这大概就是灰色而幽默的现实，当头一棒，给我敲醒。我只是个蝼蚁，还有很长的路要走！！\n在大一的时候，大部分的同学的共同语言，还是关于“高三”。似乎，之前的所有经历和高三相比都不值一提，还是当时眼界太低，能看见的只有高考呢？？上了大学，懵懵懂懂，总想着，摆脱了高中的条条框框的拘束，也有个平台可以展示自己了。其实现在反过来，想想当时自己为什么要加哪些组织、社团呢？？是真的喜欢吗？？还是单纯的为了学分呢？？还是利益相关呢？？大一刚入学的时候，感觉那些当着学生组织负责人的学长学姐好了不起，如果自己到了那个时候，会变得和他们一样优秀吗？？大一，也许在悔恨高中为什么不努力好好学习，也许是刚刚告别高三，还把看书、刷题当做一种习惯，但慢慢的，随着时间的推移，当时的屠龙少年，现在也变成了一条恶龙。（前段时间在整理书柜的时候，发现了大一时候学高数，演算的稿纸，还真的挺佩服那时候的自己）\n到了大二，渐渐的在学校里有了自己的圈子，创立了自己的社团，原以为会变成自己想要的样子，迎来的却是各种毒打，其实也算不上毒打，准确来说是劝退。当热情被慢慢消磨殆尽，坚持下来的可能就是责任了吧。那如果连责任心都没了呢？？我还有什么坚持下去的理由呢？？\n到现在，回过头来，看看高三时候的自己，可能会对他说：把一切都看淡一点，没什么大不了的。是的，没什么大不了的。说句鸡汤的话：只要你努力，总不会变得太差劲。\n 其实这篇文章，在好久之前就想写，但一直找不到带入点，也不知该如何去说起。可能是最近的烦心事多了，又变得消极了点，心里有情绪，总归要抒发出来的嘛。\n","description":"","tags":null,"title":"写个两年前的自己","uri":"/life/%E5%86%99%E4%B8%AA%E4%B8%A4%E5%B9%B4%E5%89%8D%E7%9A%84%E8%87%AA%E5%B7%B1/"},{"categories":null,"content":"环形链表  一、基本介绍 1、问题来历 据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。\n2、问题简化 在了解了约瑟夫环的来历之后，我们对该问题进行以下简化。其实我们联系一下，将会发现约瑟夫环是不是和我们小时候玩的丢手帕有些类似呢？\n那么我们首先假设有五个小孩围城一个圈，然后从第一个小孩开始报数，每次数到2，则这个小孩出圈，以此类推，通过简单地推理我们可以得出，出队列的顺序是：2—\u003e4—\u003e1—\u003e5—\u003e3.\n在了解了有关约瑟夫环的介绍之后，我们可以使用单向环形链表来对它进行相关操作。这里我们使用的是没有头结点的链表。\n 二、算法描述 1、定义结点 定义一个结点，存放小孩的编号。在之前介绍链表的时候，我们定义变量的属性都是共有的，这里我们尝试一下私有的，因此需要使用到get和set方法，来进行赋值和获取相关变量。同时，还需要一个构造器，分别用于传入结点的编号。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 创建一个Boy类，表示一个结点 class Boy { private int no;// 编号  private Boy next;// 指向下一个结点，默认为null  // 构造器  public Boy(int no) { this.no = no; } public int getNo() { return no; } public Boy getNext() { return next; } public void setNo(int no) { this.no = no; } public void setNext(Boy next) { this.next = next; } }   2、定义一个类用于管理结点 首先需要创建一个first结点，不存放任何数据，也就是当前没有编号的结点。\n代码实现如下：\n1 2  // 创建一个first结点，当前没有编号  private Boy first = null;   ①添加结点入链表 首先传入一个nums表示需要添加结点的个数。在进行添加之前，还需要判断传入的nums是否符合要求。然后定义一个curBoy辅助指针，帮助构建环形链表。\n我们通过for循环创建结点，先创建第一个结点，让first结点指向该结点，然后first的next域指向自己，构成一个环，最后再让辅助指针curBoy指向first，即完成第一个结点的添加操作；添加其它结点的方法如下：先让curBoy的下一个结点指向需要添加的结点（通过setNext方法），然后再让该结点的next域指向first结点，形成环，最后使curBoy指向当前添加的结点（为了方便下一次添加结点），从而完成添加结点的相关操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 添加小孩结点，构建一个环形的链表，nums表示需要添加结点的个数  public void addBoy(int nums) { if (nums \u003c 1) {//检验  System.out.println(\"nums的值不正确\"); return; } Boy curBoy = null;// 辅助指针，帮助构建环形链表  // 使用for循环俩创建环形链表  for (int i = 1; i \u003c= nums; i++) { // 根据编号，创建小孩结点  Boy boy = new Boy(i); // 如果是第一个小孩  if (i == 1) { first = boy; first.setNext(first);// 构成环  curBoy = first; } else { curBoy.setNext(boy); boy.setNext(first); curBoy = boy; } } }   ②遍历输出环形链表 首先判断链表是否为空，即if(first == null)，如果为空则给出提示；不为空则执行以下操作：因为first结点不能动，因此需要一个辅助变量用于完成遍历，即 Boy curBoy = first，然后我们使用while来进行循环遍历。通过getNext方法实现后移，如果curBoy的下一个结点为first则遍历结束，退出循环。完成链表的遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 遍历当前的环形链表  public void showBoy() { // 判断链表是否为空  if (first == null) { System.out.println(\"该环形链表为空~\"); return; } // 因为first不能动，因此需要一个辅助指针完成遍历  Boy curBoy = first; while (true) { System.out.printf(\"小孩的编号%d\\n\", curBoy.getNo()); if (curBoy.getNext() == first) {// 说明已经遍历完毕  break; } curBoy = curBoy.getNext();// curBoy后移  } }   ③完成结点出链表 我们需要传入几个参数，startNo表设从第几个结点开始报数，countNum表示需要数几下，nums表示圈中有多少个小孩。\n首先需要对数据进行一个校验，即判断环形链表是否为空，开始报数的位置不能低于1，也不能大于圈中的结点。\n代码实现如下：\n1 2 3 4  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; }   然后需要创建一个辅助指针helper，帮助完成小孩出圈。接下来我们需要将helper先指向链表的最后这个结点，即helper的下一个结点就是first结点。紧接着通过while循环，我们再将first和helper指针同时移动countNum - 1次，到达需要出圈结点的位置。\n最后也是最关键的一步，完成小孩结点出圈。先让first结点指向它的下一个结点，即first = first.getNext();，然后再将helper的下一个结点设置为当前first所指向的结点，即helper = helper.setNext(first);，这样first原来所指向的结点没有任何引用，就会被回收。\n如果helper == first,则说明圈中只有一个结点。输出这个结点的信息，就完成了出圈的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /** * 根据用户的输入，计算出小孩出圈的顺序 * * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少个小孩在圈中 */ public void countNum(int startNo, int countNum, int nums) { // 先对数据进行校验  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; } // 创建一个辅助指针，帮组完成小孩出圈  Boy helper = first; //需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这结点  while (true) { if (helper.getNext() == first) {// 说明helper指向最后小孩结点  break; } helper = helper.getNext(); } // 当小孩报数前，先让first和helper指针同时移动 startNo - 1 次，到达需要报数的位置  for (int j = 0; j \u003c startNo - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 当小孩报数时，让first和helper指针同时移动countNum - 1次，然后出圈  // 这里使用循环操作，直到圈中只有一个结点  while (true) { if (helper == first) {// 说明圈中只有一个结点  break; } // 让first和helper指针同时移动countNum - 1次  for (int j = 0; j \u003c countNum - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 这时first指向的结点，就是要出圈的小孩结点  System.out.printf(\"小孩%d出圈\\n\",first.getNo()); first = first.getNext(); helper.setNext(first); } System.out.printf(\"最后留在圈中的小孩编号%d\\n\",first.getNo()); }    三、结束语 在此，更新了环形链表，关于链表的所有基础知识也就要告一段落咯。谈谈我一开始学习链表的感觉吧，从一个小白，刚开始接触数据结构，就被其中各种复杂的结构所惊讶到。特别在学习到链表的时候，更加感觉到举步维艰，似乎很玄学，说不懂，但其实还是有一点点明白大概的结构。但是距离能够独立写出一个链表的结构还有很长一段路要走。因此我查阅了一些相关博客，只看代码和文字描述，总感觉少了点什么，写得再好的代码和文字，倒不如一张图来得实在，所以在学习的时候，我建议可以结合画图来实际操作，这样更方便理解，还有利于记忆。\n环形链表源码—\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——约瑟夫环","uri":"/tech/circlelinkedlistdemo/"},{"categories":null,"content":"关于我？ 叫我二夕就好，可能看到这里，你会好奇，为啥起一个这么怪的名字呢？？\n当时在想昵称的时候一直找不到合适的，打算叫“无名”，但总感觉有点落了俗套。还好，中文是比较有意思的，把“无”和“名”下面的部分拿了，不就是“二夕”了嘛。。。。。哈哈哈哈哈哈\n 玩什么？？ 常常会感慨自己是个老年人了，过了打游戏的年龄。在大学生活中，不打游戏，时间就多了起来。无聊的时候，总想找些东西打发时间。慢慢的，找到新的伙伴——悠悠球。停停停！！！我知道你想说：刚刚还感慨自己是老年人，现在又玩起小孩子的东西。\n大多数人对于悠悠球的印象可能还停留在儿时的玩具，是的，重新开始接触的时候，我也是那么认为的。但随着技术的提升，认识的玩家越来越多，会发现一个全新的世界。你会发现，有很多人都在为之而共同努力。只想把悠悠球，一种玩具，小众文化，推向大众。想得到大众的认可。\n 除了玩？？ 除了玩，那肯定就是吃和睡咯……呸呸呸，这不是我！！！\n学的专业是软件工程，所以平时最多打交道的就是代码，哪还有时间吃吃睡睡的，捋了捋自己的头发。作为一个日常摸鱼的当代大学生，平时无非就是看看书，写写代码，听听歌。就这？？\n","description":"","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"双向链表  一、基本介绍 在上一篇博客中，我们提到了单链表，它只有一个next指针，指向下一个结点，所以我们要查找下一个结点是很容易做到的，但是要想查找上一个结点就复杂的多了。因此有了双向链表。\n双向链表有两个指针域，除了有next域指向下一个结点之外，还有pre域指向上一个结点。这样使得双链表可以双向遍历。节省了时间成本，但相比于单链表插入数据和删除数据就相对复杂一些。下面我们对双链表进行简单学习一下吧。\n 二、算法实现 双链表和单链表一样，需要创建一个类用于存放结点信息，再创建一个类用于管理结点，对双链表进行相关的操作。\n1、定义节点类 我们需要在HeroNode2类中实现相关变量的定义、赋值以及显示信息的方法。\n①相关变量 这里我们使用双链表存储水浒英雄，和单链表相同，还得增加一个pre指针，指向前一个结点。\n代码实现如下：\n1 2 3 4 5  public int no; public String name; public String nickname; public HeroNode2 pre;// 指向下一个结点，默认为null  public HeroNode2 next;// 指向前一个结点，默认为null   ②构造器 利用构造器，对相关变量进行赋值。\n代码实现如下：\n1 2 3 4 5  public HeroNode2(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 这里利用toString方法，返回链表的信息。\n1 2 3 4 5 6 7 8 9  // 为了显示方法，重写toString  @Override public String toString() { return \"HeroNode2{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }    2、定义一个DoubleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，同样需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  // 先初始化一个结点，头结点不要动，不存放具体的数据  private HeroNode2 head = new HeroNode2(0, \"\", \"\");   ①添加数据到队列尾 与单链表相同，需要先定义一个辅助变量temp，利用while循环遍历到链表的最后。当退出while循环时，即temp指向了链表的最后。这时我们需要将temp的next域指向需要添加的结点，然后再将需要添加的结点的pre域指向temp，完成添加。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 添加一个结点到双向链表的最后  public void add(HeroNode2 heroNode2) { // 因为head结点不能动，因此我们需要添加一个辅助变量temp  HeroNode2 temp = head; // 遍历链表，知=找到链表的最后  while (true) { if (temp.next == null) {// 遍历到链表的最后  break; } // 如果没有找到将temp后移  temp = temp.next;// 后移  } // 当退出while循环时，temp就指向了链表的最后  // 形成了一个双向链表  temp.next = heroNode2; heroNode2.pre = temp; }   ②根据编号顺序添加结点 与单链表相同，需要先找到需要添加结点(heroNode2)的前一个结点（temp），这里不做过多赘述。当找到需要添加的结点的前一个结点之后，需要进行如下操作：\n需要先将heroNode2完成拼接，即先将heroNode2的next域指向temp.next;（新插入节点的前一个结点指向它的下一个结点），再将heroNode的pre域指向temp（将新插入的结点指向它的前一个结点），这时heroNode的pre域和next域已经分别指向了heroNode的前驱结点和后继结点；剩余需要做的就是让heroNode的前驱结点的next域和后继结点的pre域指向heroNode，但需要注意的是：如果添加的位置刚好是最后一个结点，则heroNode没有后继结点，也就是不用执行temp.next.pre = heroNode2。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 根据编号顺序添加结点  public void addByOrder(HeroNode2 heroNode2) { HeroNode2 temp = head; boolean flag = false; while (true) { if (temp.next == null) { break; } if (temp.next.no \u003e heroNode2.no) { break; } else if (temp.next.no == heroNode2.no) { flag = true; break; } temp = temp.next; } if (flag) { System.out.printf(\"需要插入的英雄编号%d已存在，添加失败\\n\", heroNode2.no); } else { heroNode2.next = temp.next;// 将新插入的结点指向它的下一个结点  heroNode2.pre = temp;// 将新插入的结点指向它的前一个结点  // 注：如果不是最后一个结点，则不需要执行下面这块代码，否则会出现空指针  if (temp.next != null) { temp.next.pre = heroNode2; } temp.next = heroNode2; } }   ③修改结点信息 修改结点信息的方法和单链表如出一辙，通过遍历找到需要修改结点所在的位置即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 修改结点信息（可以看待双向链表的结点内容修改和单向链表一样）  public void update(HeroNode2 newHeroNode2) { // 判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 找到需要修改的结点，根据no编号  HeroNode2 temp = head.next;// 定义一个辅助变量  boolean flag = false; while (true) { if (temp == null) { break; } if (temp.no == newHeroNode2.no) {// 找到  flag = true; break; } temp = temp.next; } //根据flag判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode2.name; temp.nickname = newHeroNode2.nickname; } else {//没有找到  System.out.printf(\"没有找到 编号%d的节点，不能修改\", newHeroNode2.no); } }   ④删除结点 从双向链表中删除一个结点，我们只需直接找到需要删除的结点，找到后，双链表可以实现自我删除。\n具体操作如下：定义一个辅助变量temp = head.next;这里我们直接找到该结点所在的位置，所以temp直接等于head.next;还需要一个flag标记是否找到待删除结点。通过遍历找到链表的最后，然后让temp的前驱结点的next域直接指向temp的下一个结点，即temp.pre.next = temp.next;如果待删除结点不是最后的结点，则还需要执行下列操作：让temp的下一个结点的pre指向temp的前一个结点，即temp.next.pre = temp.pre;完成上述操作之后，待删除结点的前后指针都指向null，也就完成了删除。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public void del(int no) { // 判断当前链表是否为空  if (head.next == null) {// 空链表  System.out.println(\"链表为空，无法删除~\"); return; } HeroNode2 temp = head.next; // 辅助变量(指针)  boolean flag = false; // 标志是否找到待删除节点的  while (true) { if (temp == null) { // 已经到链表的最后  break; } if (temp.no == no) { // 找到的待删除节点的前一个节点temp  flag = true; break; } temp = temp.next; // temp后移，遍历  } // 判断flag  if (flag) { // 找到  // 可以删除  temp.pre.next = temp.next; // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针  if (temp.next != null) { temp.next.pre = temp.pre; } } else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } }   ⑤输出链表信息 和单链表操作相同。。。。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 遍历打印输出链表信息  public void show() { // 先判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 因为头结点不能动，定义一个辅助变量用于遍历  HeroNode2 temp = head.next; while (true) { // 判断是否到链表最后  if (temp == null) { break; } // 输出结点信息  System.out.println(temp); temp = temp.next;// 将temp后移！！！  } }    三、结束语 到这里，我们完成了对于双链表的相关操作。双向链表相对于单链表来说，要更复杂一些，毕竟它多了pre指针，进行删除和操作的时候需要格外小心。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点操作带来了方便，可以有效提高算法的时间性能。说白了，就是用空间换时间。\n源代码——\u003e数据结构\n 《大话数据结构》 ——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构——双向链表","uri":"/tech/doublelinkedlist/"},{"categories":null,"content":"单链表的应用举例 一、前言 在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操作：\n 获取单链表的有效结点 查找单链表中的倒数第k个结点 逆序打印单链表（从尾到头打印） 反转单链表   二、算法介绍 1、获取单链表的有效结点 作为使用的第一个方法难度不是很大。因为需要求出单链表中有效结点的个数，所以我们可分为带头结点和不带头结点两种情况。\n我们这边考虑的是不带头结点的单链表，（如果是带头结点的链表需要再加上头结点即可）。需要的变量有length(统计链表的长度)和cur(辅助变量，用于遍历)，可以通过传入一个头结点，然后依次遍历该链表，当链表遍历到最后的时候，即cur.next == null，每一次遍历链表的长度加一，即length++。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // head链表的头结点，返回的就是有效结点的个数  public static int getLength(HeroNode head) { if (head.next == null) {// 链表为空  return 0; } int length = 0; HeroNode cur = head.next;// 定义一个辅助变量  while (cur != null) { length++; cur = cur.next; } return length; }   2、查找单链表中的倒数第k个结点 因为单链表是单向的，只能从头到尾开始遍历，而无法从后往前遍历，所以我们需要传入一个头结点head（遍历的起始位置）和index(倒数第k个结点)。\n定义一个size表示链表的长度，也就是链表有效结点的个数，可以通过方法一来获取。即size = getLength(head)，然后需要定义一个辅助变量用于遍历。然后通过for循环定位到倒数的index，即size - index的位置，也就是需要查找的倒数第k个结点。最后返回当前的辅助变量，完成查找。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static HeroNode findLastIndexNode(HeroNode head, int index) { // 判断链表是否为空，如果是则返回null  if (head.next == null) { return null;// 没有找到  } // 第一次遍历得到链表对的长度（结点个数）  int size = getLength(head); // 先做一个index校验  if (index \u003c 0 || index \u003e size) { return null; } // 定义一个辅助变量，for循环定位到倒数的index  HeroNode cur = head.next; // 第二次遍历 size - index位置，就是倒数的第k个结点  for (int i = 0; i \u003c size - index; i++) { cur = cur.next; } return cur; }   3、逆序打印单链表 在不改变链表结构的情况下，进行逆序打印，我们可以利用栈这个数据结构来实现。栈的特点就是先进后出。先把链表push压入栈中，再pop出栈即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public static void reversePrint(HeroNode head) { if (head.next == null) { return;// 空链表，不能打印  } // 创建一个栈，将各个结点压入栈  Stack\u003cHeroNode\u003e stack = new Stack\u003c\u003e(); HeroNode cur = head.next; // 将链表的所有结点压入到栈  while (cur != null) { stack.push(cur); cur = cur.next; } // 将栈中的结点进行打印，pop出栈  while (stack.size() \u003e 0) { System.out.println(stack.pop());// stack的特点就是先进后出  } }   4、反转单链表（有点难度） 对单链表进行反转，表示的意思是：将最后的结点变成最前端的结点，以此类推。所以我们需要分为两种情况：\n 当前链表为空，或者当前链表只有一个结点，无需反转，直接返回即可。 有多个结点时：  需要的变量有：cur(用于遍历原来的链表)，nextNode(指向当前结点[cur]的下一个结点)，reverseHead(结点，新链表的最前端)。\n具体操作过程如下：先将nexNodet指向cur的下一个结点，用于保存当前结点的下一个结点，然后将cur的下一个结点指向新链表的最前端，即cur.next = reverseHead.next,然后再将cur连接到新的链表上，这样才能形成一个完成的链表（一个回路）。然后后移，遍历下一个结点，即cur = nextNode;在进行上述操作之后，我们已经将链表的所有结点取出，并存放在新的链表下，这时我们需要将head.next 指向 reverseHead.next，实现单链表的反转，即 head.next = reverseHead.next; 完成单链表的反转。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void reverseList(HeroNode head) { // 如果当前链表为空，或者只有一个结点，无需反转，直接返回  if (head.next == null || head.next.next == null) { return; } HeroNode cur = head.next;// 定义一个辅助变量，帮助遍历原来的链表  HeroNode nextNode = null;// 指向当前结点[cur]的下一个结点  HeroNode reverseHead = new HeroNode(0, \"\", \"\"); // 遍历原来的链表，每遍历一个结点，将其取出，并放在新的链表reverseHead的最前端  while (cur != null) { nextNode = cur.next;// 先暂时保存当前结点的下一个结点，  cur.next = reverseHead.next;;// 将cur的下一个结点指向新的链表的最前端  reverseHead.next = cur;// 将cur连接到新的链表上  cur = nextNode;// 让cur后移  } // 将 head.next 指向 reverseHead.next，实现单链表的反转  head.next = reverseHead.next; }    三、结束语 其实我们不难发现，数组也好，链表也罢，都只是存储信息的不同方式，最重要的还是对其的理解和使用，只有这样才能更好的掌握。对于一个刚接触数据结构的小白来说，学到这里的时候，信息量已经远远超过之前所学的知识，但并不应该气馁，数据结构多而且难，所以更需要我们耐下性子，去慢慢琢磨、回顾，愿成长路上，与君共勉！\n源码地址——\u003e数据结构\n","description":"","tags":null,"title":"单链表的使用","uri":"/tech/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"单向链表 一、基本介绍 1、相关定义 链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的，且链表的长度不是固定的。链表的每个元素称为一个结点，每个结点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑关系，以便构成“一个结点链着一个结点”的链式存储结构，为了保持每个结点之间的链接，所以链表除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个结点都包含两个部分，第一部分用于存储元素本身的数据信息，称为数据域，它不局限于一个成员数据，也可是多个成员数据；第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的结点信息，这里用next表，next的值实际上就是下一个结点的地址，当前结点为末结点时，next的值设为空指针，即为null。链表在使用过程中，可以根据实际需求来判断是否需要添加头结点。\n2、链表与数组比较 数组（包括结构体数组）的实质是一种线性表的顺序表示方式，它的优点是使用直观，便于快速、随机地存取线性表中的任一元素，但缺点是对其进行插入和删除操作时需要移动大量的数组元素，同时由于数组属于静态内存分配，定义数组时必须指定数组的长度，程序一旦运行，其长度就不能再改变，实际使用个数不能超过数组元素最大长度的限制，否则就会发生下标越界的错误，低于最大长度时又会造成系统资源的浪费，因此空间效率差。\n 二、算法实现 我们需要定义一个类用来存放结点信息，同时也还需要定义一个类用于管理结点，实现单链表的增删改查。\n1、定义一个HeroNode类表示结点 我们需要在HeroNode类中实现相关变量的定义、赋值以及显示信息的方法。\n① 相关变量 这里我们使用单链表来存储水浒英雄，需要存储的信息有：编号、姓名和昵称。还需要定义一个next域用于指向下一个结点。\n代码实现如下：\n1 2 3 4  public int no;// 编号  public String name;// 姓名  public String nickname;// 昵称  public HeroNode next;// next域，指向下一个节点   ②构造器 可以利用构造器对相关变量进行赋值。\n代买实现如下：\n1 2 3 4 5  public HeroNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 我们可以使用toString方法来显示链表的信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 利用toString显示信息  @Override public String toString() { return \"HeroNode{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }   2、定义一个SingleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  //先初始化一个头节点，头节点不要动，不存放具体的数据  private HeroNode head = new HeroNode(0, \"\", \"\");   ①直接添加数据到单链表 直接添加数据到队列尾，即不考虑编号按照添加顺序，入链表。因为头结点不能动，所以需要定义一个临时变量temp用于遍历。通过后移temp实现遍历，temp = temp.next 。遍历的目的在于，找到当前链表最后的结点，然后将最后这个结点的next指向新的结点，便完成了添加的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public void add(HeroNode heroNode) { //因为head节点不能动，因此我们需要一个辅助变量temp  HeroNode temp = head; //遍历链表，找到最后  while (true) { //找到链表的最后  if (temp.next == null) { break; } //如果没有找到最后，将temp后移  temp = temp.next; } //当退出while循环时，temp指向了链表的最后  //将最后这个节点的next指向新的节点  temp.next = heroNode; }   ②根据编号添加结点 这次我们使用按照编号顺序添加结点，如果该编号已经存在，则添加失败，并给出提示。按照编号添加结点，使用的方法是通过 后移temp 遍历，找到该编号的前一个结点，然后让需要的添加结点先指向前一个结点的下一个结点，然后再让前一个结点指向需要添加的结点。所以需要一个flag变量来标记是否找到当前结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public void addByOrder(HeroNode heroNode) { //因为头节点不能动，因此仍然需要通过一个辅助指针（变量）来帮助找到添加的位置  //因此我们找的temp是位于添加位置的前一个节点，否则插入不了  HeroNode temp = head; boolean flag = false;//标志添加的编号是否存在，默认为false  while (true) { if (temp.next == null) {//说明temp已经在链表的最后  break; } if (temp.next.no \u003e= heroNode.no) {//位置找到，就在temp的后面插入  break; } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode编号已经存在  flag = true;//说明编号存在  break; } temp = temp.next;//后移，遍历当前链表  } //判断flag的值  if (flag) {//不能添加，说明编号已经存在  System.out.printf(\"准备插入的英雄编号%d已经存在，添加失败\\n\", heroNode.no); } else { //插入到链表中，temp的后面  heroNode.next = temp.next; temp.next = heroNode; } }   ③修改结点信息 这里我们通过根据编号来修改结点信息，即编号不能改。同时需要传入一个新的结点 newHeroNode ，用于存储修改结点的信息。在进行修改之前，需要先判断单链表是否为空，head.next == null 链表为空。然后定义一个辅助变量temp和flag分别用于遍历和标记是否找到当前结点。如果 temp.no == newHeroNode.no 表示找到当前需要修改的结点。赋予新的name和nickname完成修改结点的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //1、根据newHeroNode的no来修改即可  public void update(HeroNode newHeroNode) { //判断是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //2、找到需要修改的节点，根据num编号修改  HeroNode temp = head.next;//定义一个辅助变量  boolean flag = false;//表示是否找到该节点  while (true) { if (temp == null) { break;//已经遍历结束  } if (temp.no == newHeroNode.no) {//找到  flag = true; break; } temp = temp.next; } //3、根据flag，判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; } else {//没有找到  System.out.printf(\"没有找到编号%d的节点，不能修改\\n\", newHeroNode.no); } }   ④删除结点 在进行删除结点的操作的时候，我们仍然根据编号来进行寻找需要删除的结点。找到需要删除结点的前一个结点，让前一个结点的next跨过需要删除的结点，直接指向下一个结点，即 temp.netx = temp.next.next ，完成删除。在进行删除之前仍然需要定义temp和flag用于遍历和标记是否找到需要删除结点的前一个结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public void del(int no) { HeroNode temp = head; boolean flag = false;//标志是否找到待删除节点  while (true) { if (temp.next == null) { break;//已经到链表的最后  } if (temp.next.no == no) {//找到待删除节点的前一个节点temp  flag = true; break; } temp = temp.next;//temp后移，遍历  } //判断flag  if (flag) {//找到  //可以删除  temp.next = temp.next.next; } else { System.out.printf(\"需要删除的%d节点不存在\\n\", no); } }   ⑤显示链表信息 在显示链表信息之前，需要先判断链表是否为空，并给出相关信息。通过后移临时变量temp完成遍历。先输出结点信息，每当输出一个结点信息，就需要后移一次。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //显示链表，遍历  public void show() { //判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //因为头节点不能动，因此我们需要一个辅助变量来遍历  HeroNode temp = head.next; while (temp != null) {// 判断是否到链表最后  //输出节点的信息  System.out.println(temp); //将temp后移  temp = temp.next; } }    三、结束语 到此，我们了解了有关单链表的相关操作。在算法实现过程中，可能不少小朋友会发现一些问题，比如为什么有时候临时变量 temp = head.next ， 而有时却变成了temp = head 了呢？？其实仔细阅读一遍代码，我们不难发现，当进行增删操作的时候，temp = head ，那是因为需要增删的结点刚好是直接添加到头结点之后的，如果变成了 head.next ， 则会造成覆盖结点的情况；而在进行修改和遍历的时候，临时变量 temp = head.next ，那是因为我们这里定义头结点为空，不存放任何数据，所以修改和遍历的时候，需要从真正的有效结点开始。\n源码已经push到 ——\u003e数据结构\n","description":"","tags":null,"title":"数据结构--单向链表","uri":"/tech/singlelinkedlist/"},{"categories":null,"content":"数组模拟环形队列  一、前言 在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。\n 二、算法实现 1、初始化相关变量 需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对front和rear做以下调整：front由原来指向队列的前一个位置，改变为队列的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；rear从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为maxSize - 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  private int maxSize;// 表示数组的最大容量  private int front;// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素  private int rear;// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0  private int[] arr;// 该数组用于存放数据，模拟队列  // 构造器  public CircleArray(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = 0; rear = 0; }   2、判断队列是否为满 我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针下一个位置是头指针的时候，表示队列满。（在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 (rear + 1) % maxSize == front 。( 这里取模的目的就是为了整合rear和front大小为一个问题 )\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return (rear + 1) % maxSize == front; }   3、判断队列是否为空 因为front和rear的初始值相同，所以判断队列空的方法与之前一样。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return rear == front; }   4、求出当前队列的有效数据个数 这个方法与之前相比是新添加的，其目的是为了判断遍历队列的长度。队列的有效数据的个数 = 尾队列 - 头队列，但有时front比rear大，有时front比rear小，所以可以通过取模的方式来实现。\n代码实现如下：\n1 2 3 4  // 求出当前队列的有效数据的个数  public int size() { return (rear + maxSize - front) % maxSize; }   5、入队列 添加数据入队的操作和之前相类似，只不过该队列front指向队列的第一个元素的位置，所以需要进行先赋值，然后再后移。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 添加数据入队列  public void addQueue(int n) { if (isFull()) { System.out.println(\"该队列已满，，无法添加任何数据~\"); return; } arr[rear] = n;// 直接将数据加入  rear = (rear + 1) % maxSize;// 将rear后移，这里必须考虑取模  }   6、出队列 之前由于头指针指向队列的前一个位置，所以先后移，到达需要取出数据的位置，从而返回即可 。但此时头指针所在的位置就是需要取出的位置，如果直接返回则无法进行后移，如果先后移，则取出的数据就是下一个位置的数据。我们可以做一下处理，从而达到想要的效果：\n 先把front对应的值保留到一个临时变量； 将front后移，考虑取模 将临时保存的变量返回  代码实现如下：\n1 2 3 4 5 6 7 8 9  // 从队列中取出数据  public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无任何数据可以取出~\"); } int val = arr[front]; front = (front + 1) % maxSize; return val; }   7、显示队列的所有数据 在遍历的时候，我们需要注意到因为是环形队列，需要从front开始遍历，遍历到什么位置结束呢？？ 在之前我们已经求出了有效数据的个数，所以遍历元素为 front + size()。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 显示队列的所有数据  public void show() { if (isEmpty()) { System.out.println(\"该队列为空，无任何数据可以显示~\"); return; } // 遍历时，从front开始遍历，遍历元素为 front+有效数据的个数  for (int i = front; i \u003c front + size(); i++) { System.out.printf(\"arr[%d]=%d\\n\", i % maxSize, arr[i % maxSize]); } }   8、显示队列的头数据 因为front指向的队列的一个元素的位置，所以直接返回即可。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示队列的头数据  public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无头数据可显示~\"); } return arr[front]; }    三、结束语 到此，我们了解了关于数组模拟循环队列的相关操作，在判断队列是为满的时候，可以尝试画图理解，（记住要队列要空出一个位置，留作约定哦！）还有一个难点，求出有效数据个数。其余方法，根据数组模拟队列做出相应的调整即可（由于front和rear指向的位置不同而做出的改变）。\n源码地址 ——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构--数组模拟环形队列","uri":"/tech/circlearrayqueue/"},{"categories":null,"content":"数组模拟队列  一、基本介绍 1、队列介绍：   队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用数组或是链表来实现。\n  遵循先入先出的原则，允许插入的一端称为队尾，允许删除的一端称队头。\n  2、举例说明： 队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是先入先出的原则。\n二、算法实现 1、所需元素及其方法 在实现数组模拟队列的时候，我们需要先定义一个ArrayQueue类来存放所需的元素以及相关方法，所需元素有：数组arr[]：用于存放数据，模拟队列；数组的最大容量maxSize；队列头front；以及队列尾rear。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。\n代码实现如下：\n1 2 3 4  private int maxSize;// 表示数组的最大容量  private int front;// 队列头  private int rear;// 队列尾  private int[] arr;// 该数组用于存放数据，模拟队列   2、初始化相关变量 在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量maxSize，这时数组可以存放maxSize的数据，但数组下标的范围为arr[0]--arr[maxSize - 1]。为front和rear赋值为-1，即队列的前一个位置。\n代码实现如下：\n1 2 3 4 5 6 7  // 创建队列的构造器  public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1;// 指向队列头部，front是指向队列头的前一个位置  rear = -1;// 指向队列的尾部，rear是队列最后一个数据  }   3、判断队列是否为满 ​\t在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在不断变大。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即rear == arr[maxSize - 1]。\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return rear == maxSize - 1; }   4、判断队列是否为空 ​\t在初始状态下，front和rear均指向下标为-1的同一个位置，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向同一个下标的时候，表示所有数据已经全部出队列。所以当rear == front时，队列空。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return front == rear; }   5、添加数据到队列 在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 添加数据到队列  public void addQueue(int n) { // 首先判断队列是否为满  if (isFull()) { System.out.println(\"该队列已满，无法添加任何数据~\"); return; } rear++;// 让rear后移  arr[rear] = n; }   6、取出队列的数据 在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 获取队列的数据，出队列  public int getQueue() { // 首先判断队列是否为空  if (isEmpty()) {// 这里可以通过抛出异常处理  throw new RuntimeException(\"该队列为空，无法取出任何数据\"); } front++;// 让front后移  return arr[front]; }   7、显示队列所有数据 我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。注意在执行出队列的操作之后，front的值也随之后移，而且front指向的位置为队列的前一个位置，所以遍历的起始位置应该为front + 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示队列所有数据  public void showQueue() { // 先判断是否为空  if (isEmpty()) { System.out.println(\"该队列为空，无数据可显示~\"); return; } // 遍历  for (int i = front + 1; i \u003c arr.length; i++) { System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); } }   8、显示队列头的信息 需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要front + 1。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示头队列的信息，注意不是取出数据  public int headQueue() { // 先判断是否为空  if (isEmpty()) { throw new RuntimeException(\"队列为空，无数据可显示\"); } return arr[front + 1]; }   三、结束语 至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——\u003e 数据结构。\n 《大话数据结构》——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构--数组模拟队列","uri":"/tech/arrayqueue/"},{"categories":null,"content":"稀疏数组  一、基本介绍 1、实际需求 假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：\n0 0 0 2 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用稀疏数组来保存该数组。\n2、相关概念 基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：\n   行 列 值     A B C   E F G     A：表示总行数 B：表示总列数 C：表示真正有效数值的个数（除0外的数值） E：表示该元素所在的行 F：表示该元素所在的列 G：表示该元素的数值  所以上述原始的二维数组转化成稀疏数组，应该如下：\n   row col value     10 10 4   0 3 2   1 3 1   1 4 2   2 2 1    ​\n 二、算法实现 1、创建并输出原始二维数组 ①创建原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  // 0表示没有棋子，1表示黑子，2表示白子  int chessArr1[][] = new int[10][10];// 创建一个原始的二维数组 10*10  chessArr1[1][3] = 1; chessArr1[1][4] = 2; chessArr1[2][3] = 1; chessArr1[0][3] = 2;\t  ②打印输出原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr1) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); }   2、将二维数组转换成稀疏数组 ①先遍历二维数组，记录非0数值的个数 ​\t遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8  int sum = 0;// 用于记录非0数值的个数  for (int i = 0; i \u003c chessArr1.length; i++) { for (int j = 0; j \u003c chessArr1.length; j++) { if (chessArr1[i][j] != 0) { sum++; } } }   ②创建对应的二维数组 ​\t在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。\n代码实现如下：\n1 2 3 4 5  int sparseArr[][] = new int[sum + 1][3]; // 给稀疏数组赋值  sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = sum;   ③遍历二维数组，将非0的值存放到 sparseArr 中 ​\t在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int count = 0;// count用于记录是第几个非0数据  for (int i = 0; i \u003c sparseArr.length; i++) { for (int j = 0; j \u003c sparseArr.length; j++) { if (chessArr1[i][j] != 0) { count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } } }   ④打印输出稀疏数组 代码实现如下：\n1 2 3  for (int i = 0; i \u003c sparseArr.length; i++) { System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); }   3、将稀疏数组恢复成原始的二维数组 ①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 ​\t将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小\n代码实现如下：\n1  int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];   ②再读取稀疏数组后后几行的数据 （从第二行开始！！！） ​\t因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i = 1; 读取所有非0数据即可，其余的位置，默认值为0。\n代码实现如下：\n1 2 3  for (int i = 1; i \u003c sparseArr.length; i++) { chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; }   ③输出恢复后的二维数组 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr2) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); }    三、结束语： ​\t第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！\n​\t源码我已push到我的Github仓库，数据结构，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！\n","description":"","tags":null,"title":"数据结构--稀疏数组","uri":"/tech/sparsearray/"},{"categories":null,"content":"前言 大政的Blog就这样稀里糊涂的开通了。\n 有时候闲着无聊，总想着写点什么，可能是乱七八糟的想法，可能是一段书评，也有可能是一段歌词。因为相对于话语的直白，文字能表达的情感是更加细腻的，它也可以将有些事情一直保存下去。\n也有可能是我天生就有点内向，甚至比较丧，不太喜欢说话。\n 当时之所以想开通Blog最主要是想督促自己保持学习的习惯，并且可以在这里记录一些关于学习的笔记。也有一部分原因是在这段时间接触了许多之前没有接触过的人和事，总想着这些美好的事和可爱的人更应该被文字所记录，而不是埋藏在我的心里。\n所以博客的内容可能是一串代码，一行文字，一条书评，一段歌词，或许是一句心里话。\n我既做不上神明，那当个野兽也好。\n","description":"","tags":null,"title":"Hello World ! Hello Blog !","uri":"/life/hello/"}]
