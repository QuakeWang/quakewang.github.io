[{"categories":null,"content":"堆排序 一、前言 0、牢骚话 说实话，有点惭愧，十月份真的咕咕了好久。。。可能是因为真的比较忙，忙着参加比赛，忙着开源年会，其实这都是借口、要是想更，时间总是可挤得出来的。也许是越往后，牵涉到的内容也就越多，可能是知识点掌握的不太牢固，就一直懒得水文章（其实前面几篇文章已经暴露这个问题，只不过还是硬着头皮在做）。针对以上出现的问题，我就毅然决然的选择先缓，静下心来，再好好琢磨琢磨。\n1、堆的基本介绍 说到堆排序，大家可能会想到“堆”，为什么叫堆排序呢？其实不难不理解，我们都见过“堆”型的东西，比如金字塔。。那么这个和排序有什么关系呢？？下面我们来看一下关于堆的定义：\n 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：\n 对吧，是不是堆形的。其实我们利用上一节说过线索化二叉树，将其存放在数组中进行操作，如下：\n这个数组从逻辑上说就是一个堆的结构，经过前人的总结，我们可以使用简单的公式描述一下堆：\n  大顶堆：arr[i] \u003e= arr[2i+1] \u0026\u0026 arr[i] \u003e= arr[2i+2]\n  小顶堆：arr[i] \u003c= arr[2i+1] \u0026\u0026 arr[i] \u003c= arr[2i+2]\n  说到这儿，想必大家对于堆这种结构已经有了简单的了解，接下来我们来一探究竟，看看如何来实现排序的。\n3、堆排序的基本思想 注：一般升序采用大顶堆，降序采用小顶堆。\n **堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列 **\n ①步骤一：构造初始堆 将给定无序序列构造成一个大顶堆\na.假设给定无序序列结构如下： b.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。 c.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。 d.这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。 此时，如此反复通过上述步骤，我们就将一个无序序列构建成了一个大顶堆。\n②步骤二：将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 a.将堆顶元素9和末尾元素4进行交换 b.重新调整结构，使其继续满足堆定义 c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8. d.后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序 ③小结 再简单总结下堆排序的基本思路：\n　a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;\n　b.将堆顶元素与末尾元素交换，将最大元素\"沉\"到数组末端;\n　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。\n 二、算法实现 经过上述的介绍，大致对于堆排序都有了一个简单的了解，但是具体一点，可能还是比较迷，最起码应该知道两个步骤：①构建一个大顶堆（或小顶堆）；②进行排序。下面我们上手代码，通过代码和图解效果可能会好点。\n1、构建大顶堆 将一个数组（二叉树），调整成一个大顶堆。（功能：完成将以i对应对的非叶子结点的树，调整成大顶堆）这里我们对传入的数组进行升序操作，所以采用大顶堆，反之使用小顶堆即可。\n首先需要有传入的待排序数组int[] arr、非叶子结点在数组中的索引int i 、对应多少个元素进行调整int length，我们需要注意的是随着构建的过程length是在逐渐减少的。好了，知道了应该传入哪些变量之后，我们开始动工！！！（可能比较难理解，我会尽量按照我理解的思路来阐述）\n我们知道i表示的是一个非叶子结点，所以先把这个结点的值取出临时保存在一个临时变量中（后期有用的）int temp = arr[i]; 然后我们依次遍历该结点的左右子结点并比较其大小，选出较大的一个与当前i对应的结点进行比较，最后把最大的值放在顶部，注意哦这里是局部顶部，因为对应的是该非叶子结点的一颗树。\n这时，我们知道了无非就是比较一个非叶子结点的左右子树与该结点的大小，然后选出一个最大的放在顶部嘛，但是具体一点该怎么操作呢？？看下去咯。。\n这里使用for循环来遍历其该结点的左右子树，for(int k = i * 2 + 1; k \u003c length; k = k * 2 + 1) 。k通过执行 k = i * 2 + 1之后，这是的k指向的是i结点的左子结点。然后比较其与右子树的大小arr[k] \u003c arr[k + 1]，这时我们将k指向较大的一颗子树即可，通过k++来实现，（因为右子树的下标比左子树大一）。这是我们已经选取了左右子树中较大的一个，然后将其与i结点所在的元素比较。然后子结点大于父结点arr[k] \u003e temp ，把较大的值赋给当前结点arr[i] arr[k]，别忘了还要将i指向ki = k ，继续循环比较；如果父结点最大，我们直接break即可。因为是从左至右，从下至上调整的，所以不会出现漏判的情况。当for循环结束后，已经将i为父结点的树的最大值，放在了最顶（局部）。这时我们还需要把temp临时保存的值放置到调整后的位置arr[i] = temp 。如此反复就能成功构建出一个大顶堆。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * 将一个数组（二叉树），调整成一个大顶堆 * 功能：完成将以i对应的非叶子结点的树，调整成大顶堆 * * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中的索引 * @param length 表示对应多少个元素进行调整，length是在逐渐的减少 */ public static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i];// 先取出当前元素的值，保存在临时变量  // 说明：k = i * 2 + 1 k是i结点的左子结点  for (int k = i * 2 + 1; k \u003c length; k = k * 2 + 1) { if (k + 1 \u003c length \u0026\u0026 arr[k] \u003c arr[k + 1]) { k++;// k指向右子结点  } if (arr[k] \u003e temp) {// 如果子结点大于父结点  arr[i] = arr[k];// 把较大的值赋给当前结点  i = k;// i指向k，继续循环比较  } else { break; } } // 当for循环结束后，已经将i为父结点的树的最大值，放在了最顶（局部）  arr[i] = temp;// 将temp值放到调整后的位置  }   2、堆排序的方法 根据上文提到的堆排序的思想有：\n①将无序序列构建成一个堆 1 2 3  for (int i = arr.length / 2 - 1; i \u003e= 0; i--) { adjustHeap(arr, i, arr.length); }   根据线索化二叉树可知，该树中非叶子结点的位置在arr.length / 2 - 1 的位置，调用adjustHeap(arr, i, arr.length); 即可。\n②将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端 ③重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整，直到整个序列有序 1 2 3 4 5 6 7  for (int j = arr.length - 1; j \u003e 0; j--) { // 交换  temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); }   在完成上述操作之后，我们也就有了一个完成的有序序列。\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 编写一个堆排序的方法  public static void heapSort(int[] arr) { int temp = 0; // 1、将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆  for (int i = arr.length / 2 - 1; i \u003e= 0; i--) { adjustHeap(arr, i, arr.length); } // 2、将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端  // 3、重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整，直到整个序列有序  for (int j = arr.length - 1; j \u003e 0; j--) { // 交换  temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } }    三、结束语 堆排序确实有点难度，但其本质还是以二叉树的形式存储的数组，如果有不理解的地方可以debug然后结合画图来理解，文字描述确实太难了。。。。\n源码地址 ——\u003e 堆排序\n","description":"","tags":null,"title":"排序——堆排序","uri":"/tech/heapsort/"},{"categories":null,"content":"我与开源的那些事儿。  很幸运！！！是的，很幸运，除了幸运，我不知道该怎么形容我和 开源 的缘分。感觉就好像在冥冥之中，肯定会走上这条道路一样。\n 缘起 2020注定是特别的一年，年初，谁也没想到，一场疫情把我们牢牢的困在家里，哪也去不了。。说实话，或多或少有点抱怨吧。但伴随而来的，是一场灾难。那个时候每天一早醒来，看见手机屏幕刷新的数据，冰冷的可怕，红线一直在升。。。当时就在想，为什么我不是学医的，待在家里什么都做不了，似乎捐钱变成了最可悲的方式。\n偶然一次，在知乎上看见关于开发者抗疫的活动——“Wuhan2020”。本身就是学计算机专业的我，对于技术方面的文章也比较感兴趣，就随手点了进去。（ 其实当时内心所想的是，可能有是一个营销号在做文章 ）。在大致了解了Wuhan2020整个项目之后，便开始搜集更多的与之相关的信息。最后偶然在一个公众号中，看见了“黑客松活动”。就水群，进去了，，哈哈哈哈。但当时还是个技术小白，啥都不懂，可以理解成比会写“hello world“强那么一点点。在那之后，也找到了Wuhan2020的官方公众号。那时，想着尽自己的一份力，但是无论是对于开源文化上还是技术上都感到了很大的局限性，说俗点，大概就是心有余而力不足吧。随后大约在四月份（ 精确点是4月4号，因为那一天整个世界都是灰色的 ），看见了Wuhan2020公众号招人，我想了想自己对于做图剪视频之类的，还算是比较擅长的，就去试试水。进入了设计组。这也算是我第一次真正接触到开源吧。\n 幸运 说实话，除了幸运我不知道该怎么来形容这段经历。当时在设计组群里，几乎什么都没做，就发了一份作品＋自我介绍，然后有一位华师大的学姐，就加我为好友，说是带我一起和一位大佬做Apache相关的推广。哈？？Apache是什么？？当时的我是一脸问号。。。。然后就抱着试一试的心态跟着去了。。。（ 现在想想当时真的是有趣，如果我说我什么都不了解，甚至拒绝的话还会有现在的我么。。而且群里那么多人咋就单单选中了我呢，哈哈哈哈）然后和Apache的姜宁老师简单聊了一下，说到hugo啥的。我心里想hugo？？雨果还搞开源？？随后查了一下，是一款搭建静态博客的框架，这也是我正式使用github的起点吧，更新博客。学了点东西总要找点事情做的，要不然时间一长，不就那也记不住了，哈哈哈。\n慢慢的跟着学姐运营ALC-Beijing和Wuhan2020的公众号，也一起了解到更多有关开源的文化。习惯也由之前的天天逛CSDN、知乎变成Github、掘金之类的。成功搭建博客，给我学习新的知识也树立了信心。似乎一切都好了起来，那个时候武汉已经宣布解封。\n 当时接触开源之前，总感觉自己怀才不遇，明明会的不少，懂得知识也挺多的，为什么就还只是一个普普通通的大学生呢？？还是做不到出圈，每天混学分，做着毫无疑义的事情。但当皓月姐姐加我好友的那一刻开始，就感觉那份属于我的运气该来了，还撞的特别准。\n 随后也加入了开源社，慢慢认识了更多的小伙伴，一群人不认识也不了解，分布在各个地方，做着一件共同的事情，可能这就是我当时所理解的开源吧。\n 受阻 当时想着为一些顶级的开源项目做贡献，就开始学会主动去吸取知识，那种学习给我的感觉是由心而发的，主动的。如果问我那时为什么想参与开源，大概是开源本身就具有向善的属性，也认为那是一种体现自己价值的方式。\n当五月份学校宣布返校的时候，回头学校之后，就开始感觉自己有出圈的能力了，也有出圈的想法，可能是技术层面，学校没有需要学习的，也可能是真正意识到现在的自己可以做一些更有意义的事情了。就逐渐向周围的同学唠叨着自己接触开源的事情，很多人的情况和我一样，一开始都是一脸懵圈，但遗憾的是懵圈之后，就什么都没了。这就好比一个主动跳入坑里的人，很难再拉下一个人主动入坑。其实准确点来说，都感觉开源离自身太远。从学生角度来思考，学好文化课，在课余时间参加活动、比赛之类的，赚学分，才是本职工作。至于开源，第一是不了解（不直接和自己的利益挂钩），第二是技术层面达不到。可以发现github上面的顶级项目几乎大多数都不适合学生来做，而且更多的是面向求职者或者说是已经工作了的，这样一来，即使有一腔热血，但是也被挡在门外。（回头想想自己，能想到把blog部署到github上，这样一来，几乎就和github捆绑在一起了，也就是这样能有更多的机会接触更多的项目。）带着这样的问题，我就在思考如何才能让身边的人参与开源，其实参与开源也不一定是技术层面，是不是？？\nCOSCon‘20 期盼已久的开源年会终于来了，尤其是今年年会的主题——“开源向善“ 。这可能也是我接触到开源的初衷。当时去之前，就在脑子里构想了很多有关开源的问题，在自身深入了解开源之后，总感觉没有自己想的那么简单，说大点可以是一种哲学，甚至是一种信仰。这是开源带给我最直观的感受。\n年会现场，也可谓是大型的网友见面会，虽然每个人都不一样，学着不同的专业、不同的城市、不同的年龄段，但是却都可以在彼此身上找到各自的影子，有时候有些事确实挺奇妙的。在第二天，无论是和庄表伟老师的聊天学习，还是和王伟老师的沟通交流，都刷新了我对于开源的认识，就好像是打破之前的定义，更深入的思考，对，这次是思考，不再是了解。如果说皓月姐姐是我接触开源的引路人，这大概就是遇见了自己的伯乐。\n天下没有不散的宴席，虽然很不舍，但是离别是必然的，愿下次再遇见，那个时候的自己更优秀。\n","description":"","tags":null,"title":"我与开源的那些事儿","uri":"/life/coscon/"},{"categories":null,"content":"线索化二叉树 一、前言 1、问题引入 现如今我们在生活上都提倡节约环保，所以对于我们的所写的代码也不例外，能节省时间或空间，我们就应该去考虑节省。我们来思考一下二叉树的结构：\n二叉树的中序遍历结果为HDIBJEAFCG，可以得知A的前驱结点为E，后继结点为F。但是，这种关系的获得是建立在完成遍历后得到的，那么可不可以在建立二叉树时就记录下前驱后继的关系呢，那么在后续寻找前驱结点和后继结点时将大大提升效率。\n还有就是我们可以观察到，EFGHIJ等结点都存在空的指针域，这样的话会造成空间上的浪费，所以该如何做，才能有效的处理这些问题呢？？\n那也就是我们今天的重点内容—— 线索化二叉树 。\n2、线索化二叉树基本介绍  n个结点的二叉链表含有 n + 1 个空指针域。利用二叉链表中的空指针域存放指向该结点在某种遍历次序下的前驱和后继结点的指针，这种附加的指针称为“线索”； 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索化二叉树，根据线索性质不同，可以分为：前序线索二叉树、中序线索二叉树（ 我们这里使用中序进行讲解 ）以及后序线索二叉树三种； 一个结点的前一个结点，称为 前序结点 ； 一个结点的后一个结点，称为 后继结点 。  3、线索化规则 现将某结点的空指针域指向该结点的前驱后继，定义规则如下：\n 若结点的左子树为空，则该结点的做孩子指针指向其前驱结点；\n若结点的右子树为空，则该结点的右孩子指针指向其后继结点。\n 根据这个规则，我们将上图线索化之后，如下：\n图中黑色虚线为指向后继的线索，紫色虚线为指向前序的线索。可以看出通过线索化，即解决了空间浪费问题，又解决了前驱后继的记录问题。\n 二、算法实现 1、创建结点 既然我们需要实现线索化二叉树，所以需要先创建一个HeroNode类表示结点，包含的属性有：int no;// 表示编号 、String name;// 表示姓名、HeroNode left;// 表示左子结点，默认为null 、HeroNode right;// 表示右子结点，默认为null 。\n除了上述的基本变量之外，我们还要定义两个类型变量，用于判断指向的是左子树（右子树）还是前驱（后继）结点。我们在这里规定0表示指向树，1表示指向结点。\n定义好上述变量之后，还有就是相关的get以及set方法，外加一个toString方法用于显示信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  // 创建HeroNode结点 class HeroNode { private int no; private String name; private HeroNode left;// 默认为null  private HeroNode right;// 默认为null  /* 说明： 1、如果leftType == 0 表示指向的是左子树，如果1则表示是前驱结点 2、如果rightType == 0 表示指向的是右子树，如果1则表示指向后继结点 */ private int leftType; private int rightType; // 构造器  public HeroNode(int no, String name) { this.no = no; this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public int getLeftType() { return leftType; } public void setLeftType(int leftType) { this.leftType = leftType; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } public int getRightType() { return rightType; } public void setRightType(int rightType) { this.rightType = rightType; } @Override public String toString() { return \"HeroNode{\" + \" name='\" + name + '\\'' + \", no=\" + no + '}'; } }   2、实现线索化 为了实现线索化，我们首先需要创建一个指向当前结点的前驱结点的指针pre（默认为null），这样从而使得，在递归进行线索化的时候，pre总是保留前一个结点。以及定义一个根结点root。\n下面开始执行线索化方法体threadedNodes：先判断传入的结点是否为空，如果为空，则无法进行线索化；由于中序遍历的顺序为：左、中、右。所以我们按照这个顺序编写代码，使用递归的方式。\n①线索化左子树 ：threadedNodes(node.getLeft());\n②线索化当前结点 ：这个是重中之重，也是难点所在。先处理当前结点的前驱结点（ 先将当前结点的左指针设置为pre，然后再修改左指针的类型，指向前驱结点 ），接着处理后继结点（ 先将当前结点的右指针指向当前结点，然后再修改右指针的类型 ），在完成以上步骤之后，也就处理完成一个结点，然后让当前结点指向下一个结点的前驱结点 pre = node；\n③线索化右子树 ：threadedNodes(node.getRight()); 。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 定义ThreadedBinaryTree class ThreadedBinaryTree { private HeroNode root; // 为了实现线索化，需要创建要给指向当前结点的前驱结点的指针  // 在递归进行线索化时，pre总是保留前一个结点  private HeroNode pre = null; public void setRoot(HeroNode root) { this.root = root; } //重载threadNodes方法  public void threadedNodes() { this.threadedNodes(root); } public void threadedNodes(HeroNode node) { // 如果node == null 不能线索化  if (node == null) { return; } // （一）先线索化左子树  threadedNodes(node.getLeft()); // （二）线索化当前结点【难点】  // 处理当前结点的前驱结点  if (node.getLeft() == null) { // 当前结点的左指针  node.setLeft(pre); // 修改当前结点的左指针的类型，指向前驱结点  node.setLeftType(1); } // 处理后继结点  if (pre != null \u0026\u0026 pre.getRight() == null) { // 让前驱结点的右指针指向当前结点  pre.setRight(node); // 修改前驱结点的右指针类型  node.setRightType(1); } // ！！！每处理一个结点后。让当前结点指向下一个结点的前驱结点  pre = node; // （三）再线索化右子树  threadedNodes(node.getRight()); } }    三、结束语 从上面的分析我们可以看出，由于它充分利用空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着省了时间）。所以在实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前序和后继，那么采用线索化二叉树就是一个非常不错的选择咯！\n源码 ——\u003e线索化二叉树\n","description":"","tags":null,"title":"树——线索化二叉树","uri":"/tech/threadedbinarytree/"},{"categories":null,"content":"大三了，二夕回来了？？ 转眼间，大学生活已经过去两年了，一切总感觉一切都还早，一切都不用那么着急，反正很多事情也不是着急的事。这学期临近开学，忽然不知怎么就有了一种无形的压迫感。这种压迫感似乎在怒斥着自己，你前两年都学了些什么？？ 仔细想想，好像什么都没有。。。。\n是的，什么都没有！代码写得还是一如既往的差劲，缺少能够独立思考的能力、做不到举一反三，一切的一切都只会按部就班。在台上依旧会紧张，更少了刚踏入大学门时的斗志。失败吧？？确实挺失败的。\n一开始一直想着考研，感觉打着考研的口号，就能贴上好学生的标签，就不会变得浑浑噩噩，但是环境的影响是必然的，因为自身所处的氛围，从而间接的决定了你所看到的上限。很多人，在大学阶段都在乎名利、奖学金啊之类的，说实话，当时我的也是。恨不得把所有的荣誉都贴在身上。随着时间的推移，慢慢接触了更多的大佬，了解到上一个层面，才知道这一切是多么可笑的事情。从我现在的自己看着两年前的自己，说成降维打击也不为过。当时忙来忙去的，说好听点叫做锻炼自己，实际上谁还不是为了那点可笑的学分呢？？学分有用嘛？？也许有吧，没用怎么才能拿奖学金呢？？那么问题来了，奖学金有用吗？？似乎没吧，能写到简历上吗？？搞笑的嘛？？所以现在回头来看，似乎才知道当时的自己做了许多毫无意义还徒添烦恼的事情。上了大学，很少有人为了学习烦心过，更多的在于这些组织关系的一些杂七杂八的事情，毫无意义且浪费时间。所以从大三开始，我要撕去前两年亲手为自己贴上的标签，做个简简单单的普通大学生。\n但是想撕标签，说的简单，做的时候还是顶着很大的压力，等于摧毁以前苦心营造出来的一个人设，再树立一个与之不同甚至相反的，周围人怎么看？？重新树立的我 还是我吗？？谁知道呢？？往下走就完事了。这也算是对于两年的自己一个交代。\n高三的高考失利，就注定在心里埋下考研的萌芽。当时看着各个高校的专业排名，最中意的是华东师范大学，其次是我喜欢上海这个城市。但是呢，上了大学之后，周围的人都在告诉你，像文达这种学校能考个安大就不错了。。。是呀，安大还是211呢，你稀罕嘛？？反正我可不想。随着最近的忧虑，我恍惚和当时的自己进行了一次对话。大政笑二夕多么的颓废，而二夕却在感叹当时的大政多么心高气傲。如果可以，我更想做回以前的自己。那个做出一点点成绩，就引以为傲的大政。那个血气方刚的中二少年。\n现在，我 回 来 了！！！先从目标开始，考研目标： 华东师范大学 ，说难听点，窝窝囊囊从中学到大学上的都是垃圾学校，考研再不翻身更待何时！！！ 我想把高三时候陪伴大政的一句话，送给现在的二夕： 我不去想是否能够成功，既然选择了远方，便只能风雨兼程。\n现在回答开头提出的问题：我回来了吗？？是的，一个全新的我回来了。\n","description":"","tags":null,"title":"我回来了？？","uri":"/life/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/"},{"categories":null,"content":"顺序存储二叉树遍历 一、前言 1、顺序存储二叉树的概念 ①基本说明 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即 数组可以转换成数。数也可以转换成数组 ，如下图：\n②要求  上图的二叉树的结点，要求以数组的方式来存放，arr = [1,2,3,4,5,6,7]； 要求在遍历数组arr时，仍然可以使用前序遍历、中序遍历和后序遍历的方式完成结点的遍历。  2、顺序存储二叉树的特点  顺序二叉树通常只考虑完全二叉树； 第n个元素的左子结点为 2*n + 1； 第n个元素的右子结点为 2*n + 2； 第n个元素的父结点为 (n - 1) / 2； n：表示二叉树中的第几个元素（按0开始编号如上图）。   二、算法实现 1、顺序存储二叉树的前序遍历 首先，我们需要判断所给的数组是否符合条件，如果 数组为空 则，无法完成遍历，并给出相关提示；接下来，我们就按照前序遍历的法则，先输出当前这个元素，再向左递归遍历，最后向右递归遍历即可。\n需要注意的是：在向左和向右遍历的时候需要先判断索引所在的位置，是否在数组之内，如果是数组之外，就无法完成遍历；其次就是需要注意递归时候开始的索引。根据顺序存储二叉树的特点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /** * 编写一个方法，实现顺序存储二叉树的前序遍历 * * @param index 数组的下标 */ public void preOrder(int index) { // 先判断数组是否为空  if (arr == null || arr.length == 0) { System.out.println(\"数组为空，无法完成相关遍历\"); } // 输出当前这个元素  System.out.println(arr[index]); // 向左递归遍历  if ((index * 2 + 1) \u003c arr.length) { preOrder(index * 2 + 1); } // 向右递归遍历  if ((index * 2 + 2) \u003c arr.length) { preOrder(2 * index + 2); } }   2、顺序存储二叉树的中序遍历 和前序遍历相类似，只不过在进行输出和递归时候的位置发生交换。先进行左递归，然后输出当前结点，最后向右递归遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 顺序存储二叉树的中序遍历  public void infixOrder(int index) { // 先判断数组是否为空  if (arr == null || arr.length == 0) { System.out.println(\"数组为空，无法完成相关遍历\"); } // 向左递归遍历  if ((index * 2 + 1) \u003c arr.length) { infixOrder(index * 2 + 1); } // 输出当前这个元素  System.out.println(arr[index]); // 向右递归遍历  if ((index * 2 + 2) \u003c arr.length) { infixOrder(index * 2 + 2); } }   3、顺序存储二叉树的中序遍历 和前序、中序遍历一样，顺序更改为：先向左递归遍历，然后向右递归遍历，最后输出当前结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 顺序存储二叉树的后序遍历  public void postOrder(int index) { // 先判断数组是否为空  if (arr == null || arr.length == 0) { System.out.println(\"数组为空，无法完成相关遍历\"); } // 向左递归遍历  if ((index * 2 + 1) \u003c arr.length) { postOrder(index * 2 + 1); } // 向右递归遍历  if ((index * 2 + 2) \u003c arr.length) { postOrder(index * 2 + 2); } // 输出当前这个元素  System.out.println(arr[index]); }    三、结束语 利用数组的顺序存储来实现二叉树，其遍历方法和普通的二叉树来说，并无差别需要注意的就是索引的起始位置。，牢记顺序存储二叉树的特点即可。\n源码 ——\u003e 顺序存储二叉树\n","description":"","tags":null,"title":"树——顺序存储二叉树遍历","uri":"/tech/arraybinarytree/"},{"categories":null,"content":"二叉树查找以及删除结点 一、前言 在上一篇blog中，我们了解了有关二叉树遍历的实现方法，其实，二叉树还可以用于查找关键字，和遍历一样，同样分成前中后三种方法查找。\n本次内容除了介绍二叉树的遍历查找算法之外，考虑到由于篇幅不是很多，所以又增加了在二叉树中删除结点的方法。\n 二、算法实现 1、前序查找 思路：首先判断当前结点的关键字是否等于要查找的；如果是相等的，则返回当前结点，该结点，也就是我们所要查找的结点；如果不等， 则判断当前结点的左子结点是否为空 ，如果不为空，则递归前序查找；如果左递归前序查找，找到结点，则返回，否则继续判断，当前结点的右子结点是否为空，如果不为空，则继续向右递归前序查找。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /** * 前序遍历查找 * * @param no 查找no * @return 如果找到就返回该Node，如果没有找到返回null */ public HeroNode preOrderSearch(int no) { // 比较当前结点是不是  if (this.no == no) { return this; } // 1、判断当前结点的左子结点是否为空，如果不为空，则递归前序查找  // 2、如果做递归前序查找，找到结点，则返回  HeroNode resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } if (resNode != null) {// 说明左子树找到  return resNode; } // 3、左递归前序查找，找到结点，则返回，否则继续判断  // 4、当前结点的右子结点是否为空，如果不空，则继续向右递归前序查找  if (this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; }   2、中序查找 思路：判断当前结点的左子结点是否为空，如果不为空，则递归中序查找；如果找到，则返回。如果没有找到。就和当前结点比较，如果是则返回当前结点，否则继续进行右递归的中序查找；如果右递归中序查找，找到返回该结点，否则返回null。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 中序遍历查找  public HeroNode infixOrderSearch(int no) { // 判断当前结点的左子结点是否为空，如果不为空，则递归中序查找  HeroNode resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } if (resNode != null) { return resNode; } // 如果找到，则返回，如果没有找到就和当前结点比较，如果是则返回当前结点  if (this.no == no) { return this; } // 否则继续进行右递归的中序查找  if (this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; }   3、后序查找 思路：判读当前结点的左子结点是否为空，如果不为空，则递归后序查找；如果找到，就返回，如果没有找到，就判断当前结点的右子结点是否为空，如果不为空，则右递归进行后序查找，如果找到，就返回；否则 就和当前结点进行比较，如果是则返回该结点，否则返回null。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 后序遍历查找  public HeroNode postOrderSearch(int no) { HeroNode resNode = null; // 判断当前结点的左子结点是否为空，如果不为空，则递归后序查找  if (this.left != null) { resNode = this.left.postOrderSearch(no); } if (resNode != null) {// 说明左子树找到  return resNode; } // 如果左子树没有找到，则向右子树递归进行后序遍历查找  if (this.right != null) { resNode = this.right.preOrderSearch(no); } if (resNode != null) { return resNode; } // 如果左右子树都没有找到，就比较当前结点是不是  if (this.no == no) { return this; } return resNode; }   4、删除结点 分析：\n在删除之前，我们要思考一个问题，那就是所需要删除的结点时叶子结点还是非叶子结点，如果是叶子结点，则直接删除即可；对于非叶子结点我们在这里做如下处理：那就是删除连同该结点的一棵树。\n思路：\n①因为该二叉树是单向的，所以判断的是当前结点的子结点是否为需要删除的结点，而不是直接判断需要删除的当前结点（如果直接判断需要删除的当前结点，那么当指针指向该结点的时候，由于是单向的二叉树，则已经错过了删除的机会。）\n②如果当前结点的左子结点不为空，并且左子结点就是需要删除的结点，就将 this.left = null 并且返回（结束递归删除）；\n③如果当前结点的右子结点不为空，并且右子结点就是需要删除的结点，就将 this.right = null 并且返回（结束递归删除）；\n④如果第2和第3步没有删除结点，那么就需要向左子树进行递归删除；\n⑤如果第4步也没有删除结点，则应当向右子树进行递归删除。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public void delNode(int no) { if (this.left != null \u0026\u0026 this.left.no == no) { this.left = null; return; } if (this.right != null \u0026\u0026 this.right.no == no) { this.right = null; return; } if (this.left != null) { this.left.delNode(no); } if (this.right != null) { this.right.delNode(no); } }    三、结束语 利用递归来实现二叉树查找关键字，总体上来说，还是比较便于理解的。在查找的基础上新加了删除结点的方法。\n源码 ——\u003e 二叉树查找\n","description":"","tags":null,"title":"树——二叉树查找以及删除结点","uri":"/tech/binarytreesearch/"},{"categories":null,"content":"遍历二叉树 一、前言 在上一篇blog中，我们了解了有关树的基础知识，特别的是重点介绍了一下二叉树。这里，我们就来探究一下关于二叉树的遍历方法。\n二叉树的遍历方法有三种，分别是：\n 前序遍历：先输出父结点，在遍历左子树和右子树； 中序遍历：先遍历左子树，再输出父结点，再遍历右子树； 后序遍历：先遍历左子树，再遍历左子树 ，再输出父结点。  小结：看输出父结点的顺序，就确定是前序，中序还是后序。\n 二、算法实现 1、前序遍历  先输出当前结点（初始的时候是根节点）； 如果左子结点不为空，则递归继续前序遍历； 如果右子结点不为空，则递归继续前序遍历。  代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 编写前序遍历的方法  public void preOrder() { System.out.println(this);// 先输出父结点  // 递归向左子树前序遍历  if (this.left != null) { this.left.preOrder(); } // 向右子树前序遍历  if (this.right != null) { this.right.preOrder(); } }   2、中序遍历  如果当前结点的左子结点不为空，则递归中序遍历； 输出当前结点； 如果当前结点的右子结点不为空，则递归中序遍历。  代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 中序遍历  public void infixOrder() { // 递归向左子树中序遍历  if (this.left != null) { this.left.infixOrder(); } // 输出父结点  System.out.println(this); // 递归向右子树中序遍历  if (this.right != null) { this.right.infixOrder(); } }   3、后序遍历  如果当前结点的左子结点不为空，则递归后序遍历； 如果当前节点的右子结点不为空，则递归中序遍历； 输出当前结点。  代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 后序遍历  public void postOrder() { if (this.left != null) { this.left.postOrder(); } if (this.right != null) { this.right.postOrder(); } System.out.println(this); }    三、结束语 其实遍历二叉树，可以进行利用递归和非递归两种方式来处理，我们这里使用的是递归的方式，个人感觉，在明白递归机制之后，递归实现更容易理解点吧。\n源码 ——\u003e二叉树\n","description":"","tags":null,"title":"树——二叉树遍历","uri":"/tech/binarytree01/"},{"categories":null,"content":"可能自己就是天生比较丧的原因，当第一次僵尸的《网易云》就入了坑，这几天，听见了他的《淹没》，就开始单曲循环。\n其实，说到底，rapper也好，yoer也罢，都是小众文化，想要的到大众的认可，谈何容易。但往往就是这种小众的圈子，入圈的人更能找到共鸣，因为有些话，只有小众人才能明白。\n以下内容是根据歌词所想所写：\n 想去冒险，结果一直没有真正的去实践过。我也曾一个人做地铁坐公交到底站，带上耳机的惆怅感只有自己能懂。喝酒吗？？我不喝酒，喝酒伤身体，多喝点奶。有时自己的抑郁的时候，通常是手机开飞行模式，不想遭到任何事情打扰，关上房门，带上耳机，拿起悠悠，就进入另外一个世界了。\n你高考了没？？学习成绩怎么样啊？？对于自己的未来有想法嘛？？考不上大学是不是打算直接就去打工啊？？ 反正谁知道呢，走一步看一步就好。\n我是个yoer，但不是火力少年王那种，电视上面的都是基础招，都是垃圾，哎哟、好吧，其实大家玩的都差不多吧。反正你们也不懂，只是看看热闹罢了。玩的也就一般嘛 在圈子算低端吧。从来没指望这玩意能够赚钱，还不是因为自己喜欢啊。家里啊、家里人一开始最多认为我是三天的新鲜劲，过去就没了，支持嘛？？说不上吧，你想想你儿子整天玩个悠悠球，难不成你还供着他啊……至于现在，不反对就好。\n有时候，就很烦，玩悠悠球毕竟不是未来，鸡汤现在都烂大街咯，成功一定会来，就**放屁。我会不会坚持？？不知道，反正我没想过放弃。\n  凌晨的卧室它会变成汪洋 在每晚一点半准时的重逢\n手机屏散发出微弱的光芒 抵抗这无形中巨浪的重重\n连秒针都变得肆意而猖狂 嘲弄他理想的荒唐\n苦笑的祭奠那逝去的张扬 还有他已不知去向的从容\n我想做到给他们看见 我想成为他们口中特例\n我想做到给他们看见 吐出这口憋了无数年的恶气\n失魂落魄的那个人啊，这个世界又何曾让他选\n一开始就只有这一条路给他走，死不悔改的丧家犬\n暴风雨并不会让人绝望，杀人的不是狂风\n遍体鳞伤的人 绝不会倒在最艰苦的长征\n积压的情绪爆发后 突入其来的平静让人惊讶\n生的了结最可能出现在某个无限美的黄昏\n嘴里说我知道我明白我会照做，心里说死也不要\n他们总逼着你喝下去有一种名字叫为了你好的毒药\n成功竟然比存在本身还重要 他们指着那些伟人\n时至今日我发现哪里有人群 入眼处尽是鬼魂\n 愿世界没有歧视，小众文化forever！\n","description":"","tags":null,"title":"听姜云升——《反抗》","uri":"/life/%E5%90%AC%E5%A7%9C%E4%BA%91%E5%8D%87%E5%8F%8D%E6%8A%97/"},{"categories":null,"content":"树 一、树的相关概念 1、引入 之前我们所提到的数组也好、链表也罢，其实都是一对一的线性结构，但是在日常生活当中还存在许多一对多的非线性结构 —— “树”。\n 树（Tree） ：是n （n≥0）个结点的有限集。n=0时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根，root的结点；（2）当 n\u003e1时，其余结点可分为m（m\u003e0）个互相不相交的有限集T1、T2……Tm,其中每一个集合本身又是一棵树，并且称为根的子树。\n 如下图所示：\n2、树的结点 结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，上图中，数据元素 A 就是一个结点；\n父结点（双亲结点）、子结点和兄弟结点：对于上图中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。\n树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。上图中，结点A就是整棵树的根结点。\n树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。\n叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。例如上图中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。\n3、子树和空树 子树：如上图中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且结点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。\n 注意：单个结点也是一棵树，只不过根结点就是它本身。上图中，结点 K、L、F 等都是树，且都是整棵树的子树。\n 知道了子树的概念后，树也可以这样定义：树是由根结点和若干棵子树构成的。\n空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。\n补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，上图中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。\n4、结点的度和层次 对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，上图中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。\n一棵树的度是树内各结点的度的最大值。上图表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。\n结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于上图来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。\n一棵树的深度（高度）是树中结点所在的最大的层次。上图树的深度为 4。\n如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，上图中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。\n5、有序树和无序树 如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。\n在有序树中，一个结点最左边的子树称为\"第一个孩子\"，最右边的称为\"最后一个孩子\"。\n拿上图来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。\n6、森林 由 m（m \u003e= 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。\n前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：\nTree =（root,F）\n其中，root 表示树的根结点，F 表示由 m（m \u003e= 0）棵树组成的森林。\n 二、二叉树 在上文，我们简单的了解了一下关于树的基本内容，那么在以上的概念继续细化，也就得到了二叉树。\n 简单地理解，满足以下两个条件的树就是二叉树：   本身是有序树； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；   例如，下图a) 就是一棵二叉树，而图 b) 则不是。\n2、二叉树的性质 经过前人的总结，二叉树具有以下几个性质：\n 二叉树中，第 i 层最多有 2i-1 个结点。 如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。   性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。 同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2*n2+1。 两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。   3、满二叉树 二叉树还可以继续分类，衍生出满二叉树和完全二叉树。\n 如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。\n 满二叉树除了满足普通二叉树的性质，还具有以下性质：\n 满二叉树中第 i 层的节点数为 2n-1 个。 深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。 具有 n 个节点的满二叉树的深度为 log2(n+1)。  4、完全二叉树  如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n 上图 所示是一棵完全二叉树，图中由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。\n完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。\n⌊ log2n ⌋ 表示取小于 log2n 的最大整数。例如，⌊log2 4⌋ = 2，而 ⌊log2 5⌋ 结果也是 2。\n对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：\n 当 i\u003e1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点） 如果 2i\u003en（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2i 。 如果 2i+1\u003en ，则结点 i 肯定没有右孩子；否则右孩子是结点 2i+1 。  5、总结 本节介绍了什么是二叉树，以及二叉树的性质，同时还介绍了满二叉树和完全二叉树以及各自所特有的性质，初学者需理解并牢记这些性质，才能更熟练地使用二叉树解决实际问题。\n","description":"","tags":null,"title":"树及其相关概念","uri":"/tech/abouttree/"},{"categories":null,"content":"哈希表 待更新……\n源码地址 ——\u003e 哈希表\n","description":"","tags":null,"title":"数据结构——哈希表","uri":"/tech/hashtab/"},{"categories":null,"content":"源码测试案例失败，求助大佬！！！\nissue ——\u003e 斐波那契查找\n","description":"","tags":null,"title":"查找——斐波那契查找","uri":"/tech/fibonaccisearch/"},{"categories":null,"content":"插值查找 一、前言 1、问题引入 在了解过折半查找 之后，可能有些人会有些疑问，为什么选择的是1/2，而不是 1/3 、1/4 呢？？或者说折更多呢？？\n举个例子，比如说我们在26个英文字母中寻找A，你还会选择折半么，从中间开始向左边部分进行递归？？还是直接从头开始查找、 在这种情况下，折半查找就显得不是那么的好用咯，还存在可以优化的地方。\n2、基本介绍 我们来看一下折半查找的中间值 mid = (left + right) / 2; 通过我们小学一年级学过的数学知识，可以得出 =\u003e mid = left + (right - left) / 2; 也就是mid等于最底下标left加上最高下标right与left差的一半。然后再次利用小学一年级的知识，对于这个 1/2 进行优化，得出 mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);\n将 1/2 改成 (findVal - arr[left]) / (arr[right] - arr[left]) 有什么好处呢？？假设arr[10] = {1, 2, 3, 4 ,5 6, 7, 8, 9}，则left = 0、right = 8、arr[left] = 1、arr[right] = 9。需要查找关键字1，代入上述公式可得 mid = 0，那么就说明只需要一次，感兴趣的可以自己使用折半查找计算一下， 从而可以发现在这种情况下，还是插值查找好使。\n 插值查找： 是根据要查找的关键字findVal与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的计算公式 (findVal - arr[left]) / (arr[right] - arr[left])。\n  二、算法实现 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /** * 说明：差债查找算法，也要求数组是有序的 * * @param arr 数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 查找值 * @return 如果找到，就返回对应的下标，如果没有找到就返回-1 */ public static int insertValueSearch(int[] arr, int left, int right, int findVal) { //注意：findVal \u003c arr[0] 和 findVal \u003e arr[arr.length - 1]必须需要，否则得到的mid可能会越界  if (left \u003e right || findVal \u003c arr[0] || findVal \u003e arr[arr.length - 1]) { return -1; } // 求出mid  int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal \u003e midVal) { return insertValueSearch(arr, mid + 1, right, findVal); } else if (findVal \u003c midVal) { return insertValueSearch(arr, left, mid - 1, findVal); } else { return mid; } }    三、结束语 插值查找一般适用于表长较大的，而且关键字分布又比较均匀的查找表来说，插值查找算法的平均性能是优于折半查找的，但如果是表长较小的情况、或者关键字分布不均与的情况，再使用插值查找或许就不是那么合适的了。\n源码 ——\u003e 插值查找\n","description":"","tags":null,"title":"查找——插值查找","uri":"/tech/insertvaluesearch/"},{"categories":null,"content":"折半查找 一、前言 1、基本介绍 折半查找（BinarySearch）： 又称二分查找。它的前提是线性表的记录必须是关键码有效（通常从小到大有序），线性表必须采用顺序存储。\n基本思想 ：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。\n2、举栗子 现在有一个有序数组 {1，8，10，89，100，123}，假设我们需要寻找数字8这个数，步骤如下：\n  首先确定该数组的中间值的下标，即 mid = (left + right) / 2;\n  然后让需要查找的数findVal和arr[mid]比较；\n 1）findVal \u003e arr[mid] 说明要查找的数在mid的右边，因此需要递归的向右查找； 2）findVal \u003c arr[mid] 说明要查找的数在mid的左边，因此需要递归的向左查找； 3）findVal == arr[mid] 说明找到，就返回下标    3、思考 什么时候需要结束递归呢？？\n 找到就结束递归； 遍历完整个数组，仍然没有找到findVal，也需要结束递归，结束条件为： 左边的索引 大于 右边的索引，即 left \u003e right 。   二、算法实现 1、非递归实现 折半查找既可以使用递归，也可以使用非递归来实现，这里我们先来了解一下非递归。left表示左边的索引，初始位置为数组的第一个元素；right表示右边的索引，初始位置为数组的最后一个元素。然后利用while循环进行遍历。当左边的索引大于右边的索引的时候，表示查找结束，没有查找到关键字，则返回-1，否则，返回该元素所在的下标。\n中间值 mid初始值为 mid = (left + right) / 2; 若查找值比中值小，则最高下标调整到中位下标小一位；若查找值比中值大，则最高下标调整到中位下标大一位；依次类推。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 非递归实现折半查找  public static int binarySearch03(int[] arr, int left, int right, int findVal) { int mid = 0; int midVal = arr[mid]; while (left \u003c= right) { mid = (left + right) / 2; if (findVal \u003c midVal) { right = mid - 1; } else if (findVal \u003e midVal) { left = mid + 1; } else { return -1; } } return mid; }   2、递归实现 与非递归实现想类似，即根据关键字与中间值的大小，然后做出相应的判断，再分别向左或者向右进行递归。需要注意的是，要避免出现“死龟”的情况，也就是没有查找到所需要的关键字，但仍没有结束递归。因此，当左边的索引大于右边的索引时，即 left \u003e right表示递归完整个数组，需要结束递归。还有就是需要注意每次递归的起始位置的变化。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /** * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 需要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回-1 */ public static int binarySearch01(int[] arr, int left, int right, int findVal) { // 当 left \u003e right 时，说明递归完整个数组，但是没有找到  if (left \u003e right) { return -1; } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal \u003e midVal) {// 向右递归  return binarySearch01(arr, mid + 1, right, findVal); } else if (findVal \u003c midVal) {// 向左递归  return binarySearch01(arr, left, mid - 1, findVal); } else { return mid; } }   3、完善版折半查找 假设，需要查找的关键字，在数组中有多个相同数值时， 在上述两个方法中，都是查找到一个关键字就返回，如何才能够将所有的数值都查找到呢？？\n思路分析：\n 当查找到mid索引值时，先不要立刻返回； 向mid索引值的左边扫描，将所有满足元素的下标，加入到集合ArrayList； 向mid索引值的右边扫描，将所有满足元素的下标，加入到集合ArrayList； 最后将ArrayList返回即可。  代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  public static List\u003cInteger\u003e binarySearch02(int[] arr, int left, int right, int findVal) { if (left \u003e right) { return new ArrayList\u003cInteger\u003e(); } int mid = (right + left) / 2; int midVal = arr[mid]; if (findVal \u003e arr[mid]) { return binarySearch02(arr, mid + 1, right, findVal); } else if (findVal \u003c arr[mid]) { return binarySearch02(arr, left, mid - 1, findVal); } else { List\u003cInteger\u003e resIndexList = new ArrayList\u003c\u003e(); // 向mid索引值左边扫描，将所有满足元素的下标，加入到集合ArrayList中  int temp = mid - 1; while (true) { if (temp \u003c 0 || arr[temp] != findVal) {// 没有找到，退出  break; } // 否则，将temp放入到resIndexList中  resIndexList.add(temp); temp--;// temp左移  } resIndexList.add(mid); // 向mid索引值右边扫描，将所有满足元素的下标，加入到集合ArrayList中  temp = mid + 1; while (true) { if (temp \u003e arr.length - 1 || arr[temp] != findVal) { break; } resIndexList.add(temp); temp++;// temp右移  } return resIndexList; } }    三、结束语 折半查找的前提条件是需要有序顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。但是对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，就不建议使用咯。\n源码 ——\u003e 折半查找\n","description":"","tags":null,"title":"查找——折半查找","uri":"/tech/binarysearch/"},{"categories":null,"content":"线性查找 一、前言 假设我们需要在一个毫无顺序摆放的书架上，寻找一本书。但是由于书籍并没有分类，因此我们要找书只能从头到尾一本一本的对照书名，进行查找，直到找到或者全部查找完为止。实际上，这一个过程就是我们今天所要讲的线性查找。\n 线性查找（Sequential Search） ：又叫顺序查找，是最基本的查找技术，它的查找过程是：从表中第一个（ 或最后一个 ）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果知道最后一个（ 或第一个 ）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。\n  二、算法实现 线性查找较为简单，我们直接从数组的第一个元素依次开始遍历，然后与需要查找的关键字进行比较相同即可，如果比较成功，返回该元素所在的下标；否则，返回-1，表示遍历完也没有查找到该关键字。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 这里实现的线性查找是找到一个满足条件的值，就返回  public static int seqSearch(int[] arr, int value) { // 线性查找是注意逐一比对，发现有相同值，就返回下标  for (int i = 0; i \u003c arr.length; i++) { if (arr[i] == value) { return i; } } return -1; }    三、结束语 阅读完代码，大致感觉上没有什么问题，但是呢，如果一个数组有多个相同的关键字呢，返回的就是第一个查找到的关键字，就结束了查找。 因此我们可以定义一个集合用于存放查找结果，然后遍历完整个数组即可。\n源码 ——\u003e 线性查找\n","description":"","tags":null,"title":"查找——线性查找","uri":"/tech/seqsearch/"},{"categories":null,"content":"基数排序 一、前言 1、基本介绍  基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort），顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用； 基数排序是属于稳定性的排序，基数排序法的是效率高的 稳定性 排序法； 基数排序是桶排序的扩展； 基数排序是1887年赫尔曼·何乐礼发明的。实现如下：将整数按位数切割成不同的数字，然后按每个对应的位数进行分别比较。  2、基本思想 将所有待排序数值统一为同样数位长度（ 以最高位为主，位数短的数前面补零 ），然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数组就变成一个有序序列。\n3、图文说明 可能看到这里，大部分读者还是挺懵的，下面我们结合一个动态图来进行理解。\n因为这里所使用的数组元素都是两位数的，即个位和十位，首先先根据个位数的大小进行排序，依次放入对应的位置（ 也就是我们所讲的桶 ），然后根据放入的位置取出，然后再根据十位数的大小进行存放，这个顺序也就是排序之后的顺序。\n 二、算法实现 1、得到最高位数 根据基数排序的思想可知，是根据最大数的位数多少进行比较的，也就是说我们需要先找到最高位数，\n先假设最大数就是数组的第一个元素，然后使用for循环遍历整个数组，依次进行比较即可。然后再根据最大数，得到它是几位数，即可。\n1 2 3 4 5 6 7 8 9  // 得到数组中最大的数的位数  int max = arr[0];// 假设第一位数就是最大数  for (int i = 1; i \u003c arr.length; i++) { if (arr[i] \u003e max) { max = arr[i]; } } // 得到的最大数就是几位数  int maxLength = (max + \"\").length();   2、定义相关变量 我们需要一个二维数组，来表示10个桶，每个桶就是一个一维数组。这10个桶分别表示从0~9 这十个数，大小为待排序数组的大小（ 有可能会出现极端情况，即某个对应位数的数值是一样大的，就考虑取最大，也就是数组的大小 ）。int[][] bucket = new int[10][arr.length];\n再定义一个一维数组来记录各个桶的每次放入数据的个数，int[] bucketElementsCounts = new int[10];\n3、排序 ①放入对应的桶中 首先，我们要根据最大数的位数是多少进行排序，然后还要取出各个位数的对应的值，考虑使用for循环实现，同时增加一个变量n，表示步长，for(int i = 0, n = 1; i \u003c maxLength; i++, n *= 10) 再嵌套一个for循环用于取出元素，然后放入到对应的桶中。\n1 2 3 4 5 6 7  for (int j = 0; j \u003c arr.length; j++) { // 取出每个元素对应位的值  int digitOfElement = arr[j] / n % 10; // 放入对应的桶中  bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; }   bucket[] 数组 表示的意思如下：\n  比如：53和3 这两个数，所对应的就是bucket[3][2]表示的意思就是 个位数字为3的桶中有两个数；\n  其中digitOfElement对应的是3（个位数字），bucketElementCounts[digitOfElement]用于记录对应桶中的个数\n  ②按照桶进行排序 根据一维数组的下标依次取出数据，放入到原来的数组，int index = 0; 先定义一个index变量用作索引。然后依次遍历每个桶，如果桶中有数据，则取出放入到原数组中，注意index++，后移。每进行一轮操作之后，需要将bucketElementCounts[k]置空，以复用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //一维数组的下标依次取出数据，放入到原来的数组  int index = 0; //遍历每一个桶，并将桶中的数据放入到原数组  for (int k = 0; k \u003c bucketElementCounts.length; k++) { //如果桶中有数据，放入到原数组  if (bucketElementCounts[k] != 0) { //循环该桶即第k个桶（第k个一维数组），放入  for (int l = 0; l \u003c bucketElementCounts[k]; l++) { //取出元素放入到arr  arr[index] = bucket[k][l]; index++; } } //第i+1轮处理后，需要将每个bucketElementCounts[k] = 0  bucketElementCounts[k] = 0; }   4、完整版代码 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  // 基数排序方法  public static void radixSort(int[] arr) { // 得到数组中最大的数的位数  int max = arr[0];// 假设第一位数就是最大数  for (int i = 1; i \u003c arr.length; i++) { if (arr[i] \u003e max) { max = arr[i]; } } // 得到的最大数就是几位数  int maxLength = (max + \"\").length(); // 定义一个二维数组，表示10个桶，每个桶就是一个一维数组  /* 说明： 1、二维数组包含10个一维数组 2、为了防止在放入数的时候，数据溢出，则每个一维数组（桶），大小定位arr.length 3、基数排序是使用空间换时间的经典算法 */ int[][] bucket = new int[10][arr.length]; // 再定义一个一维数组来记录各个桶的每次放入的数据个数  int[] bucketElementCounts = new int[10]; for (int i = 0, n = 1; i \u003c maxLength; i++, n *= 10) { // 针对各个元素的对应位进行排序处理，第一次是个位，第二次是十位，以此类推  for (int j = 0; j \u003c arr.length; j++) { // 取出每个元素对应位的值  int digitOfElement = arr[j] / n % 10; // 放入对应的桶中  // 比如：53和3 这两个数，所对应的就是bucket[3][2] 表示的意思就是 个位数字为3的桶中有两个数  // 其中digitOfElement对应的是3（个位数字），bucketElementCounts[digitOfElement]用于记录对应桶中的个数  bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; } //按照这个桶的顺序（一维数组的下标依次取出数据，放入到原来的数组）  int index = 0; //遍历每一个桶，并将桶中的数据放入到原数组  for (int k = 0; k \u003c bucketElementCounts.length; k++) { //如果桶中有数据，放入到原数组  if (bucketElementCounts[k] != 0) { //循环该桶即第k个桶（第k个一维数组），放入  for (int l = 0; l \u003c bucketElementCounts[k]; l++) { //取出元素放入到arr  arr[index] = bucket[k][l]; index++; } } //第i+1轮处理后，需要将每个bucketElementCounts[k] = 0  bucketElementCounts[k] = 0; } } }    三、结束语 到这里，关于排序也就告一段落了，从我们最熟悉的冒泡排序到利用空间换取时间的基数排序，毫无疑问是先驱们对于算法的思考，我们虽然很难再设计出一种新的、高效率的算法，但是却可以做到在原算法的基础上，并对其进行改进。大家一起加油！！！\n源码 ——\u003e 基数排序\n","description":"","tags":null,"title":"排序——基数排序","uri":"/tech/radixsort/"},{"categories":null,"content":"归并排序 一、前言 1、基本介绍 归并排序（MergeSort）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略 （分治法将问题分（divide）成一些小的问题然后递归求解，而治（conquer）的阶段则将分的阶段得到的个答案“修补”在一起，即分而治之。）\n将两个的有序数列合并成一个有序数列，我们称之为\"归并\"。 归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括\"从上往下\"和\"从下往上\"2种方式。\n  从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)\n  从上往下的归并排序：它与\"从下往上\"在排序上是反方向的。它基本包括3步： ① 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2; ② 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。 ③ 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。\n  如下图所示： 2、具体操作 归并算法的实质在于把一个复杂的序列进行分解从而可以局部击破，变得简单化，下面我们举栗子，进行操作一把。在把数组进行分割之后，紧接着要做的事情就是 治 ，这里我们取最后一步做图解，实际上的操作过程是每 分 一次，就要进行 治 的操作。\n①分合操作 我们假设有一个数组如下：int[] arr = {5,4,7,9,3,8,2,1}; 那么我们根据前面所了解的规则，对其进行分 。\n②“治“ 实现规则如下：首先把一个数组分成左右两个部分，然后还要有一个空的数组，用作中转。在左右数组的两个部分，两边各还需要一个指针，分别进行扫描待排序的原始数组。在扫描的同时，把左右两个部分得到的元素进行比较，哪个较小则移入中转数组（这里我们是升序，降序反之即可），然后被移入元素的数组的指针依次后移，进行比较。\n 二、算法实现 由具体的实现操作可知，我们需要两个方法，一个进行 分+合 的操作，另一个进行 治 的操作。\n1、“治”（合并）的方法 该方法用于对被分割之后的数组进行排序的操作。\n①定义相关变量 首先我们需要有传入的变量：int[] arr 待排序的原始数组； int rigth 左边有序序列的初始索引； int right 右边有序序列的初始索引；int mid 中间索引；int[] temp 做中转的数组；以上是我们需要通过方法体传入的变量。\n接下来对其相关变量进行初始化：int i = left; 初始化i，左边有序序列的初始索引；int j = right; 初始化j，右边有序序列的初始索引；int t = 0; 指向temp数组的当前索引。\n②初步处理左右序列 步骤如下：先把左右两边（有序）的数据按照排序规则填充到temp数组，直到左右两边的有序序列，有一边处理完毕为止。\n所以我们可以利用while循环来实现。循环的条件是有只要有一边扫描完毕，即i \u003c= mid \u0026\u0026 j \u003c= right 。\n具体的填充规则为：如果左边有序序列的当前元素，小于等于右边有序序列的当前元素，则将左边的当前元素，填充到temp数组，然后指针后移，反之亦然，将右边有序序列的当前元素，填充到temp数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  while (i \u003c= mid \u0026\u0026 j \u003c= right) { // 如果左边的有序序列的当前元素，相遇小于右边有序序列的当前元素  // 即 将左边的当前元素，填充到temp数组  // 然后 t++ i++ 后移  if (arr[i] \u003c arr[j]) { temp[t] = arr[i]; t++; i++; } else {// 反之，将右边有序序列的当前元素，填充到temp数组  temp[t] = arr[j]; t++; j++; } }   ③填充剩余数据 在上个步骤，我们了解到，只要有一边的数据全部处理完毕则结束循环，所以我们需要把剩余数据的一边的数据依次全部填充到temp。这时就需要对于左右两边分别进行扫描。\n1 2 3 4 5 6 7 8 9 10  while (i \u003c= mid) {// 处理左边有序序列的剩余数据  temp[t] = arr[i]; t++; i++; } while (j \u003c= right) {// 处理右边有序序列的剩余数据  temp[t] = arr[j]; t++; j++; }   ④拷贝数据 我们当前对于待排序数组的数据进行处理后，所有的数据都在temp数组中，我们还需要将其拷贝回原始的数组。这里我们需要注意的是：比昂不是每次都要拷贝所有！！！ 即每进行一次分治操作，就拷贝一次数据。\n从左到右，依次拷贝temp数组中的元素。\n1 2 3 4 5 6 7  t = 0; int tempLeft = left; while (tempLeft \u003c= right) { arr[tempLeft] = temp[t]; t++; tempLeft++; }   ⑤完整版代码 我们对于每一步进行可拆分说明，更有助于理解。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  /** * 合并的方法 * * @param arr 待排序的原始数组 * @param left 左边有序序列的初始索引 * @param right 右边有序序列的初始索引 * @param mid 中间索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int right, int mid, int[] temp) { int i = left;// 初始化i，左边有序序列的初始索引  int j = mid + 1;// 初始化j，右边有序序列的初始索引  int t = 0;// 指向temp数组的当前索引  /* （一） 先把左右两边（有序）的数据按照规则填充到temp数组 直到左右两边的有序序列，有一边处理完毕为止。 */ while (i \u003c= mid \u0026\u0026 j \u003c= right) { // 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素  // 即 将左边的当前元素，填充到temp数组  // 然后 t++ i++ 后移  if (arr[i] \u003c arr[j]) { temp[t] = arr[i]; t++; i++; } else {// 反之，将右边有序序列的当前元素，填充到temp数组  temp[t] = arr[j]; t++; j++; } } /* （二） 把有剩余数据的一边的数据依次全部填充到temp */ while (i \u003c= mid) {// 处理左边有序序列的剩余数据  temp[t] = arr[i]; t++; i++; } while (j \u003c= right) {// 处理右边有序序列的剩余数据  temp[t] = arr[j]; t++; j++; } /* （三） 将temp数组的元素拷贝到arr 注意：并不是每次都要拷贝所有！！！ */ t = 0; int tempLeft = left; while (tempLeft \u003c= right) { arr[tempLeft] = temp[t]; t++; tempLeft++; } }   2、分+合的方法 在编写完合并的方法之后，我们在此基础上进行分合操作。同样需要传入一些所需的相关变量如下：int[] arr 待排序的原始数组； int rigth 左边有序序列的初始索引； int right 右边有序序列的初始索引；int[] temp 做中转的数组；以上是我们需要通过方法体传入的变量。\n然后利用递归进行执行，执行的条件为left \u003c right 。分别向左右两个方向拆分，之后调用合并方法。需要注意的是每次拆分的左右指针的位置要选取正确。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 分+合的方法  public static void mergeSort(int[] arr, int left, int right, int[] temp) { if (left \u003c right) { int mid = (left + right) / 2;// 中间索引  // 向左递归进行分解  mergeSort(arr, left, mid, temp); // 向右递归进行分解  mergeSort(arr, mid + 1, right, temp); // 合并  merge(arr, left, right, mid, temp); } }    三、结束语 源码 ——\u003e 归并排序\n","description":"","tags":null,"title":"排序——归并排序","uri":"/tech/mergesort/"},{"categories":null,"content":"致RIOT悠悠球协会全体成员的一封信、 社团名以及LOGO的由来 时间返回到一年前，也大约在这个时候，我可以确信我们的悠悠球社团能够成立，也大约在这个时候，想好了社团的名字，以及设计出社团的LOGO。还是想说说名字的来历吧，主要来源于我比较喜欢的一颗悠悠球 “start the riot” ；还有就是RIOT可以简单分成两部分来看：“RI” 其中R的词根的有再一次的意思，而”OT“呢？？这个可不是打游戏里面的OT，而是圈子里面提倡的一个概念”Original Throw“。因为大多数人，或多或少再小时候都接触过悠悠球，所以我希望的是当再一次接触到悠悠球，请不要再放下她。（ 还好学校里面的领导没文化，不知道riot其实是暴动、暴乱的意思，要不然说不定给我ban了，哈哈哈哈 ）\n至于社团的LOGO呢？？更偏向于街头涂鸦的那种感觉，给人的整体感觉也是比较青春有活力的。与传统的圆形或者中规中矩的方形所不同，甚至可以感觉到一点叛逆的味道在里面。。。\n为何创立？？ 为何创立社团？？以及有没有必要创立一个悠悠球社团？？ 其实这两个问题困惑了我许久。先谈谈第一个：悠悠球作为小众运动，对于绝大多数人而言，甚至还停留在儿时的玩具，只能够普普通通一上一下的简单操作，对于电视上出现的各种操作，更以为是特效。。。。。这个原因也是能说是其中的一点。想打破大家对于悠悠球的认识也是创立的一个主要原因。在刚上大学的时候，我就开始尝试着让更多人了解悠悠球，或者说入坑悠悠球，但是悠悠球相比于其他的玩物，上手难度比较大，因为是小众，文化基础不是很好。再加上需要付出时间和精力去练习等等诸多因素，从而导致更多的人都只是愿意看看。但是正是由于她的小众以及上手难度，这也是使得悠悠球更显得与众不同。在当时尝试推广之下，已经有了一定的群众基础，刚好赶上要举办元旦晚会，因此便和几位小伙伴上台表演了一番，虽然玩得都是基础招，对于许多没有真正了解过的人来说，这已经amazing了！！！是的，表演效果还是可以的。这也让我有了创办的信心。在2019年三月份，华东高校悠悠球联赛正式举办，当时因为一些原因，并没有去现场学习。但通过直播，仍然可以看见有许许多多的大学生对于悠悠球的热爱与执着，特别看见新手组的时候，对我而言感觉是最多的。在五一假期的时候，来到上海，参加了上海悠悠球聚会，起初我以为我是最差的，，但是看见很多意想不到的，有小朋友也有大叔，都是因为对于悠悠球的喜欢与热爱，我们得以相聚。玩悠悠球，玩得开心不就可以了，为什么想那么多呢？、如果创立社团可以让这份快乐延续和传播下去，岂不是更好？？从那时起，我就在心中埋下一颗种子，并尽力让其生根发芽。\n有必要吗？？或许正确的答案是没必要吧。创立社团对我自己而言更多的是徒增了许多烦恼（在实际的过程中也是如此）。但既然能够成立一个社团，又何必去管它有没有必要呢、、 干就完了！！\n为期一年？？ 实际上，在协会会长这个职位上，并没有满一年就下来了。。。\n起初，在刚成立的时候，还在幻想着，纳新能招多少多少人，以后举办什么什么活动之类的，理想总是美好的，实际证明这一切的幻想都是基于我自己对于悠悠球的喜欢，对于一个不冷不热的路人来说，我们更应该思考的是如何让他们对此感兴趣。。 所以说，不管是纳新还是举办活动，都比我预想的要差的很多，甚至在有一段时间，我就在想，社团还有必要继续运营下去吗？？这时，我想起《曾国藩》中的一句话：\n 打破牙和血吞！！！\n 哈哈哈，现在回头看来也没有那么严重，只不过是与心里的预期相差太多，有点接受不了，所以难免有点颓废。颓废过去，社团还是要经营的，最重要的每周的训练是必不可少的，只有在保证训练量的基础上，部员才能有所成长。就这样，新的一年即将到来，随之而来的还有元旦晚会，这也算是社团的一个隐藏起点吧。但是身份却发生了改变，相比较一年前，想在舞台上秀操作，那时更多的是想让协会的部员能够上台展示自己，这是社团的收获，也是你们的收获。和当时不变的还是，舞台肯定要炸，玩悠悠球不蹦迪，那不是在土嗨嘛？？（ 开个玩笑 ） 就这样，经过为期三个月的努力，社团可以呈现一个完整的舞台，足够了，是的。这既是对于社团部员的考核，也是对于我自己的一次检验，还好，不算太差。\n到了2020年，因为疫情原因，没能及时返校，部员的训练量也就落下了。回校之后，就在想，要不就这样吧？？反正接力棒就要交到下一届，到时候就与我无关了了了了、、、 内心还是挺纠结的。最后想了想，活动还是要办的，毕竟要为留下来的部员最大化的谋取福利，顺便可以培养下一届会长的办事能力。也算是对自己交个差吧。\n以上大概差不多就是这一年来经营社团方面的心态变化。接下来简单说一下个人的经验：\n 做好牺牲自己（时间和金钱），当选择成立一个社团或者留任的时候，那就代表着你要担负起属于自己的那一份责任； 要有适当的计划，可以是长远性的，也可以是目前的，比如说在纳新结束后，可以根据部员的时间合理安排每周的训练，再具体点就是每周训练的内容； 调动部员的积极性，相比较参与社团活动，可能大部分部员都会选择做自己的事情，因为在他们看来参与社团活动是为了社团的发展之类的，而往往牺牲的是他们自己的时间，长而久之，就慢慢会退出社团活动，这时作为会长就要结合实际情况，调动部员的积极性； 在比较活跃或者说表现比较积极的部员，要培养他们的归属感，从而可以他们有参与社团活动、留在社团之类的想法，产生良性循环； 认真重视自己的社团，比如在每次训练的时候，可以逐一私给部员私发信息，让部员意识到其重要性，如果作为会长自己都不重视，凭什么要求部员积极呢？？  谈谈收获。。 好像读到现在，整体给人的感觉是有点不太乐观的、甚至还是比较颓废的。但事情都是有两面性的。\n给我收获最大的莫过于看见部员的成长。从什么都不会，到可以玩出点东西；从内向腼腆，到敢于上台表演；从遭受别人的冷眼嘲笑，到慢慢有了掌声……\n记得当时纳新结束，有一个小部员，来找我练球，教他的时候，问他什么都不说，发球手还抖的噼里啪啦的，整个人就是特别内向，更别说在人群面前展示自己了，但是逐渐慢慢的，有了变化，在元旦晚会的时候，上台表演，听见来自台下观众的掌声，也可以肯定自己。这一切的变化，不能说都是来自于悠悠球，但是悠悠球在其中有不可或缺的因素。还有的部员说，我从小就双手不协调，不可能玩好的。但是我想说，只要你相信自己，并且听我的愿意花时间去练习，没有什么做不到的。是的， 只要坚持，结果总不会太差 。\n再说说我自己吧，因为把自己大部分时间都放在社团上，也就没了过多的时间抄招想招，每周都在想着教什么基础招，想必圈子里面很多的老前辈都知道基础招的重要性，从而就有了我现在的手感，这与教授部员基础招有着密不可分的关系。还有就是，心态被磨平了，做事情可以从更多的方面去思考问题，这些也全都是收获。\n 那么现在再想有必要创立社团嘛？？我的回答是：有的。我把社团的定位是传播悠悠球的正确玩法，而不是培养比赛型选手，如果可以向圈子里面输送新人也是更好。但就说传播悠悠球的玩法，我想我尽我自己的能力，做的还行吧。\n如果说社团最大的难题在哪？？莫过于 传承 。\n 我的故事到此为止\n没做好的 你来帮我完成\n永远保持热爱\n ","description":"","tags":null,"title":"关于RIOT悠悠球协会","uri":"/life/%E5%85%B3%E4%BA%8Eriot%E6%82%A0%E6%82%A0%E7%90%83%E5%8D%8F%E4%BC%9A/"},{"categories":null,"content":"快速排序 一、前言 1、基本介绍 见名知意，就是一种很快的排序方法。快速排序是基于冒泡排序的升级，那是因为它们都属于交换排序类。即它也是通过不断比较和移动交换次数来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减少了总的比较次数和移动交换次数。\n 基本思想： 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，整个排序过程可以递归进行，以达到整个序列有序的目的。\n 2、排序例图  二、算法实现 1、定义基本变量 首先，我们需要的有：传入待排序的数组int[] arr、左索引int left、右索引int right。\n在方法体内，我们需要有左下标：int l = left; 右下标：int r = right; 中轴值：int pivot = arr[(left + right) / 2]; （这里我们默认中轴值的基准为位于数组中间的元素） 最后还有一个临时变量int temp = 0; 用于交换。\n2、初步分组 这里我们利用while循环来说完成分组的规则，即把数组根据所选基准pivot的大小分成两个部分。while循环的条件为：左下标小于右小标 即l \u003c r。\n①遍历左部分 我们需要在pivot的左边部分一直寻找，直到找到一个元素的数值大于等于pivot值，才退出。\n1 2 3  while(arr[l] \u003c pivot) { l += 1; }   左下标的起始位置为：数组的第一个元素，所以每遍历一个元素需要后移一位。\n②遍历右部分 这时，需要在pivot的右边部分一直寻找，直到找到一个元素的数值小于等于pivot值，才退出。\n1 2 3  while(arr[r] \u003e pivot) { r -= 1; }   右下标的起始位置为：数组的最后一个元素，即arr.length - 1 ，所以每遍历一个元素需要前移一位。\n③结束循环 如果 l \u003e= r 说明pivot左边的值，已经全部是小于等于pivot值，右边全部是大于等于pivot值，这时需要结束循环。\n1 2 3  if(l \u003e= r) { break; }   ④交换 当完成②③的遍历的时候，分别在pivot左右两个部分找到了符合要求的元素，则可以开始执行交换，从而使得每个元素归位于所适合的位置。\n1 2 3 4  // 交换  temp = arr[l]; arr[l] = arr[r]; arr[r] = temp;   3、防止溢出 当我们完成交换的规则之后，接下来就需要保证防止出现栈溢出的情况，这一步也是为了在后面步骤进行左右递归做好前提条件，是必不可少的一步。\n1 2 3 4 5  // 如果 l == r ， 必须l++、r--，否则会出现栈溢出  if (l == r) { l += 1; r -= 1; }   4、递归 在完成上述所有的操作之后，下一步就是进行递归操作。这里需要注意的就是进行左右递归的条件以及起始位置是不同的。\n1 2 3 4 5 6 7 8  // 向左递归  if (left \u003c r) { quickSort(arr, left, r); } // 向右递归  if (right \u003e l) { quickSort(arr, l, right); }   5、完整版代码 因为整个快速排序流程较为复杂，所以对于方法体中的代码进行了拆分讲解，以下是快速排序方法体中的完整代码：\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  // 快速排序  public static void quickSort(int[] arr, int left, int right) { int l = left;// 左下标  int r = right;// 右下标  int pivot = arr[(left + right) / 2];// 中轴值  int temp = 0;// 临时变量  // while循环的目的是让比pivot值小放到左边，比pivot值大放到右边  while (l \u003c r) { // 在pivot的左边一直找，找到大于等于pivot值，才退出  while (arr[l] \u003c pivot) { l += 1; } // 在pivot的右边一直找，找到小于等于pivot值，才退出  while (arr[r] \u003e pivot) { r -= 1; } // 如果 l \u003e= r 说明pivot左边的值，已经全部是小于等于pivot值，右边全部是大于等于pivot值  if (l \u003e= r) { break; } // 交换  temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; // 如果交换完后，发现 arr[l] == pivot值相等，r-- 前移  if (arr[l] == pivot) { r -= 1; } // 如果交换完后，发现arr[r] == pivot值相等，l++ 后移  if (arr[r] == pivot) { l += 1; } } // 如果 l == r ， 必须l++、r--，否则会出现栈溢出  if (l == r) { l += 1; r -= 1; } // 向左递归  if (left \u003c r) { quickSort(arr, left, r); } // 向右递归  if (right \u003e l) { quickSort(arr, l, right); } }    三、结束语 源码 ——\u003e 快速排序\n","description":"","tags":null,"title":"排序——快速排序","uri":"/tech/quicksort/"},{"categories":null,"content":"希尔排序 一、前言 1、简单插入排序存在的问题 我们看简单的插入排序可能存在的问题，如下：\n数组 int[] arr = {2,3,4,1} 这时需要插入的数1（最小），这样的过程是：\n{2,3,4,4} ——\u003e {2,3,3,4} ——\u003e {2,2,3,4} ——\u003e {1,2,3,4}\n所以我们可以得出如下结论：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。\n2、基本介绍 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n^2）的第一批算法之一。\n 基本思想： 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n 简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。\n我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。\n3、举栗子  二、算法实现 希尔排序的实质是对于直接插入排序进行改进，所以我们分为交换法和移位法两种。\n1、交换法 希尔排序的精髓，也是其关键点就是 对于增量的选择。我们这里使用当前数组的一半 当作增量。for(int gap = arr.length / 2; gap \u003e 0l; gap /= 2) 这样就对待排序的数组按照增量大小进行了分类。\n 将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。\n 选择好增量之后，需要做的就是对分好组之后的数组进行排序。交换法在这里进出处理使用的是双层for循环，外层循环用于遍历数组。内层循环根据增量大小，逐一对数组中的元素进行比较，从而进行排序。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 希尔排序，对有序序列在插入时直接使用交换法  public static void shellSort01(int[] arr) { int temp = 0;// 用于交换  // 第一层循环，将待排序数组进行分组  for (int gap = arr.length / 2; gap \u003e 0; gap /= 2) { // 第二层排序，从第gap个元素，逐个对其所在组进行直接插入排序操作  for (int i = gap; i \u003c arr.length; i++) { // 第三层循环，遍历各组中所有的元素（共gap组），步长为gap  for (int j = i - gap; j \u003e= 0; j -= gap) { // 如果当前元素大于加上步长后的那个元素，说明交换  if (arr[j] \u003e arr[j + gap]) { temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; } } } } }   通过阅读代码，我们不难发现，利用交换法实现希尔排序中使用了三层for循环，那是因为我们每发现一组增量就进行交换，这样下来，自然而然执行效率就低咯。针对出现的问题，做出优化，也就是接下来的移位法。（效率大幅度提升！！！）\n2、移位法 移位法的第一步也还是得首先确立增量，这也就是为什么说增量是希尔排序的精髓所在的原因。然后执行的操作就是直接插入排序的操作。\n注意：与之前提到的直接插入排序不同的在于，其移动的位置是根据增量大小而移动的，也就是gap。当退出while循环后，也就给待插入的元素找到指定位置，插入即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 对交换式的希尔排序进行优化 ——\u003e 移位法  public static void shellSort02(int[] arr) { // 增量gap，并逐步的缩小增量  for (int gap = arr.length / 2; gap \u003e 0; gap /= 2) { // 从第gap的个元素，逐个对其所在的组进行直接插入排序  for (int i = gap; i \u003c arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] \u003c arr[j - gap]) { while (j - gap \u003e= 0 \u0026\u0026 temp \u003c arr[j - gap]) { // 移动  arr[j] = arr[j - gap]; j -= gap; } // 当退出while后，就给temp找到插入的位置  arr[j] = temp; } } } }    3、结束语 源码 ——\u003e 希尔排序\n","description":"","tags":null,"title":"排序——希尔排序","uri":"/tech/shellsort/"},{"categories":null,"content":"直接插入排序 一、前言 1、基本介绍 想必我们大家都玩过或者了解过斗地主，最基本的扑克玩法都是一边摸牌，一边理牌的。我们可以思考一下，理牌的顺序，是不是把大的牌直接插入在小的牌后面的呢？？例如有以下几张牌（不考虑花色）：6、4、5、3 。将4和5移动到6的左侧，再将3移动到最左侧，顺序就算是整理好了。这里我们所使用到的理牌方法就是直接插入排序。\n 直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。\n 插入排序的基本思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中含有 n - 1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序吗进行比较，将它插入到有序表中的适当的位置，使之成为新的有序表。\n2、举栗子 下面以数列{101,34,119,1}为例，\n排序流程：\n第1轮：i=0。交换34和101的位置， 34,101,119,1；\n第2轮：i=1。因为119比101数值大，所以该趟不做任何处理；\n第3轮：i=3。1依次与有序表中的数进行比较，直到找到合适的位置为止，也就是最终的顺序，1,34,101,119；\n 二、算法实现 因为我们使用一个有序表和一个无序表进行排序，所以默认数组的第一个元素为有序表，也就是for循环 的其实位置，for(int i = 1; i \u003c arr.length; i++) 所有的排序过程都需要在当前这个for循环中完成。此外，我们还需要定义int insertVal = arr[i]; 表示为待插入的数；int insertIndex = i - 1; 即待插入数的前面的这个数值的下标。\n接下来，我们使用while循环 给insertVal找到插入的位置。在执行循环的过程中，既要保证给insertVal找插入位置时，不越界 ；insertVal \u003e 0又要确保找到合适的插入位置 insertVal \u003c arr[insertIndex] 。然后将arr[insertVal] 后移，因为已将待插入的数arr[i] 保存到临时变量insertVal中，所以后移过程中不会覆盖，比如将举栗子的数列进行第一轮后移变成：{101,101,119,1}。然后再将insertIndex--; 如此可以保证有效地执行while循环。\n当退出while循环时，说明插入的位置找到，即 insertIndex + 1。然后需要做出判断是否需要赋值，即这个位置是否等于待插入数的下标，使用if选择语句即可完成。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 直接插入排序  public static void insertSort(int[] arr) { for (int i = 1; i \u003c arr.length; i++) { int insertVal = arr[i];// 定义待插入的数  int insertIndex = i - 1;// 即arr[i]的前面的这个数的下标  /* 给insertVal找到插入的位置 说明： 1、insertIndex \u003e= 0 保证在给insertVal找插入位置，不越界 2、insertVal \u003c arr[insertIndex] 待插入的数，还没有找到插入位置 3、需要将arr[insertIndex] 后移 */ while (insertIndex \u003e= 0 \u0026\u0026 insertVal \u003c arr[insertIndex]) { arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; } //当退出while循环时，说明插入的位置找到，insertIndex + 1  //判断是否需要赋值  if (insertIndex + 1 != i) { arr[insertIndex + 1] = insertVal; } } }    三、结束语 直接插入排序时间复杂度：直接插入排序的时间复杂度是O(n^2)。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(n)，需要遍历多少次呢？N-1！因此，直接插入排序的时间复杂度是O(n^2)。\n直接插入排序稳定性:直接插入排序是稳定的算法，它满足稳定算法的定义。算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！\n源码 ——\u003e 直接插入排序\n","description":"","tags":null,"title":"排序——直接插入排序","uri":"/tech/insertsort/"},{"categories":null,"content":"选择排序 一、前言 1、基本介绍 选择排序（Selection sort）是一种简单直观的排序算法。它的基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n2、举栗子 下面以数列{20,40,30,10,60,50}为例，\n排序流程：\n第1轮：i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化：20,40,30,10,60,50 -- \u003e 10,40,30,20,60,50；\n第2轮：i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化：10,40,30,20,60,50 -- \u003e 10,20,30,40,60,50；\n第3轮：i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理；\n第4轮：i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理；\n第5轮：i=4。交换a[4]和a[5]的数据。 数列变化：10,20,30,40,60,50 -- \u003e 10,20,30,40,50,60\n3、说明  选择排序一共有 数组大小 - 1 轮排序 每一轮排序，又是一个循环，循环的规则：  先假定当前这个数是最小数 然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标 当遍历到数组的最后时，就得到本轮最小数和下标     二、算法实现 选择排序和冒泡排序一样，使用双重for循环进行实现。\n外层循环 for(int i = 0; i \u003c arr.length; i++) 用于确定排序的轮数，同时确定相关变量 minIndex = i; 最小值的下标，以及 最小值 min = arr[i]; 。然后定义内层循环 for(int j = i + 1; j \u003c arr.length; j++) 注意内层循环的起始位置是从i + 1 开始的（每执行完一轮排序，就确立一个最小值）。这时，在内层循环要筛选出最小值。当执行完内层循环之后，需要判断当前最小值的位置，是否在已排序数列的最后的位置。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public static void selectSort(int[] arr) { for (int i = 0; i \u003c arr.length; i++) { int minIndex = i; int min = arr[i]; for (int j = i + 1; j \u003c arr.length; j++) { if (min \u003e arr[j]) {// 说明假定的最小值不是最小  min = arr[j];// 重置min  minIndex = j;// 重置minIndex  } } // 将最小值，放在arr[i]，即交换  if (minIndex != i) { arr[minIndex] = arr[i]; arr[i] = min; } } }    三、结束语 从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况。其比较次数都是一样的多，第i趟排序需要进行 n - i 次关键字的比较，此时需要比较 n * (n - 1) / 2 次。而对于交换次数而言，当最好的时候，交换次数为0次，当最差的时候，也就初始降序的时候，交换次数为 n - 1 次，基于最终的排序时间是比较与交换次数的总和，因此，总的时间复杂度依然为O(n^2)。\n应该说，尽管与冒泡排序同为O(n^2) ，但简单选择排序的性能是要略优于冒泡排序。\n源码 ——\u003e 选择排序\n","description":"","tags":null,"title":"排序——选择排序","uri":"/tech/selectsort/"},{"categories":null,"content":"冒泡排序 一、前言 回想起来，当时一开始接触编程的时候，在学完循环和数组之后，老师便给我们讲解了冒泡排序 ，老师还开玩笑说这种排序的算法最简单，相对而言也最容易理解。但对于当时的我们来说听得还是云里雾里的。\n 冒泡排序（Bubble Sort） 一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。\n 因为排序的过程（如果相邻的元素逆序就交换）就像是水中的气泡一样往上冒，因此得名叫做冒泡排序。下面举一个简单的栗子：\n原始数组：3，9，-1，10，20\n 第一趟排序：  1）3，9，-1，10，20 // 3和9比较，3比9小，位置不变\n2）3，-1，9，10，20 // 9和-1比较，发现逆序，交换位置\n3）3，-1，9，10，20 // 9和10比较，位置不变\n4）3，-1，9，10，20 // 10和20比较，从而确定第一趟排序下来最大的数20\n 第二趟排序：  1）-1，3，9，10，20 // 3和-1比较，发现逆序，交换位置\n2）-1，3，9，10，20 // 3和9比较，位置不变\n3）-1，3，9，10，20 // 9和10比较，从而确定第二趟排序下来最大的数10\n 第三趟排序：  1）-1，3，9，10，20 // -1和3比较，位置不变\n2）-1，3，9，10，20 // 3和9比较，从而确定第三趟排序下来最大的数9\n 第四趟排序：  1）-1，3，9，10，20 // -1和3比较，从而确定第四趟排序下来最大的数3\n小结：\n 一共进行 数组的大小 - 1 次 大的循环； 每一趟排序的次数在逐渐的减少。   二、算法实现 1、排序 冒泡排序的算法实现，并不难理解，我们使用双重for循环遍历即可。只不过需要注意的是每一次循环时候的条件。外层循环 for(int i = 0; i \u003c arr.length - 1; i++) 表示的是每一趟循环，所需要的次数就是数组大小-1 。而内层循环 for(int j = 0; j \u003c arr.length - i - 1; j++) 表示的是每一趟需要排序的元素的的个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 冒泡排序方法  public static void bubbleSort(int[] arr) { int temp = 0;// 临时变量  for (int i = 0; i \u003c arr.length - 1; i++) { for (int j = 0; j \u003c arr.length - i - 1; j++) { if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } }   2、优化 在使用冒泡排序的时候，我们不难发现，如果一串数字中有部分两两相邻的元素是顺序的，但是仍然执行 swap函数 的操作，这样一来极大程度上降低了排序的效率。针对以上出现的情况，我们做出如下的优化：\n增加一个布尔类型的变量flag 作为标识符，用于判断，当前的两两相邻的元素是否是按照顺序的，如果是就跳出，继续排查下一个元素，依次类推。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 冒泡排序方法  public static void bubbleSort(int[] arr) { boolean flag = false;// 标识符  int temp = 0;// 临时变量  for (int i = 0; i \u003c arr.length - 1; i++) { for (int j = 0; j \u003c arr.length - i - 1; j++) { if (arr[j] \u003e arr[j + 1]) { flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } if (!flag) {// 在一趟排序中，一次交换都没有发生过  break; } else { flag = false;// 重置flag进行下次判断  } } }    三、结束语 以上便是关于冒泡排序的基本内容了。如果还有描述不清或者是无法理解的，可以适当画图结合debug进行调试，细心点，坚持下去，总会有结果的。\n分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以判断出就是 n - 1 次的比较。没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表示逆序的情况，此时需要比较 n*(n - 1) / 2 次，并作等数量级的记录移动。因此，总的时间复杂度为O(n^2)。\n源码 ——\u003e BubbleSort\n","description":"","tags":null,"title":"排序——冒泡排序","uri":"/tech/bubblesort/"},{"categories":null,"content":"说起 《三体》 ，想必大家并不陌生，大约从初中就听说过这套书，但很遗憾的是，当时的我并不喜欢读书，直到现在，也就是大二的时候才读完。但庆幸的是，有些书幸好没有那么早的草草地过一遍，要不书中想表达的含义，在当时的经历与心境来说是无法理解和体会的。\n 地球生命真的是宇宙中偶然里的偶然，宇宙是个空荡荡的大宫殿，人类是这宫殿中唯一的一只小蚂蚁。这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命真珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉人就老了……\n 这是《三体1》当中叶文洁，对伪主人公汪淼所说的一段话，也是全书中我比较喜欢的一段话。读完书之后，在翻阅之前做的笔记的时候，看到这段。不得不佩服大刘的思维，在读第一本的时候，可能会觉得这只是叶文洁的感叹。但通读全书之后，何尝又不是每个读者心里发出的一声叹息呢。。从宏观的角度来看，与浩渺的宇宙相比，人类确实只是一粒尘埃。但同时，人类是幸运的，生活在地球上。可悲的是，人类本身却不知道爱惜这块土地。\n反观叶文洁，为何要给三体人发信息呢？？甚至不惜犯了反人类罪。当从汪淼的视角，第一次看见叶文洁的时候，不免觉得这样一位老太太有点可怜，失去了自己的女儿，看着她那照看小区里邻居家小孩的样子，哪能想得到是ETO的统帅。。 但结合叶文洁的遭遇，也不难发现，她之所以决定把三体人引来都是有原因的，甚至不惜牺牲丈夫的生命，是人类一次又一次的做出违反道德底线的事情，在文革那个特殊时期，国将不国，人成非人。从而给叶文洁的心中埋下不相信人类的种子，当来到红岸基地之后，凭借自己的技术和手段，在收到三体人的警告：“不要回答！不要回答！不要回答！” 但她还是毫不犹豫地发送信息，暴露出地球的坐标，也就有了三体以后的故事。\n全书中，我最喜欢的角色是：章北海 ；最欣赏的应该是： 维德 。一个是要多想，一个是前进，不择手段的前进！之前，在还没读《三体》之前，隐隐约约看了点书评之类的，知道章北海是一个坚定的失败主义者，那时候就在想，既然是一个失败主义者，为何还有那么多人粉他呢？？不是应该被批评的嘛？？所以一开始对于章北海并没有什么太好的印象，甚至还有点反感。。。。在读到的《黑暗森林》的时候，面对三体人的来临，几乎所有人都慌张失措的时候，联合国更因此，制定了反人类的面壁计划。在这个条件下，反观章北海，没有面壁者的权利有义务，却成为了一个合格的民间面壁者。当大刘写到他问自己的父亲，下一步该怎么做的时候，父亲告诉他：“北海，我只能告诉你那以前要多想”。设想一下，如果我们自己在当时的环境下，我们该如何去做？？更多的可能是崩溃，但他没有。知道人类的特性都明白，逃亡主义是不可能实现的，但面对敌我实力的悬殊，也唯有逃亡，才能为人类文明的延续留下火种，尽管流浪在宇宙中的新人类，已经成为非人。但是毫无疑问，他是成功的，也完成了自己的任务。再来看看看维德，第一反应是这个人未免有点太讨厌了，喜欢欣赏人绝望的时候，就凭这一点就很恶心，是不是。。但是慢慢读下去，发现他是一个彻底的功利主义者，更说出了很多金句，比如： 失去人性，失去很多，失去兽性，失去一切 。但是欣赏归欣赏，要是在现实生活中，要这么一个人，肯定是不愿意和他做朋友的，太危险了，得绕的远远的，哈哈哈~\n简单的说一下阅读感受，在读第一部的时候，能感觉到这本书的格局之大，也被大刘的一些科幻创意点子所惊呆，尤其是在说冯诺依曼用大量的士兵给秦始皇展示计算机模型的时候，绝对的是一大亮点，还有就是从工具人汪淼的视角，来揭开三体人，让人感觉不太像是科幻小说，更有点的侦探悬疑的感觉。再看第二部，主人公罗辑从一个混日子的大学教授，被指定为面壁者，从而慢慢经历在书的末尾与三体人正面对决，可谓惊叹，对于罗辑的心路历程，再看看年少时候到我们。反观第三部，程心被喷圣母biao，但是她做错了什么嘛、是人类选择了程心，在那个时代的人类，可怜更可笑，盲目地自大，所以选择程心是理所当然。在读到书的结尾的时候，被大刘一个接着一个抛出的科幻点子所惊艳，有一种喘不过气的感觉。但又有点急急促促的感觉。\n读科幻小说给我的最大感受，就是每次读的时候都把自己的思想扩展到宏观层面，感觉眼前的所有烦心事，在整个人类文明面前都是不值一提的，可以把问题思考的更深入点，就想到既然文明可以一直延续下去，那么该如何让自己更有意义，成为文明的一部分呢？？我得出的答案是，那就是做些有意义的事情，什么事情是有意义的呢？？放下小了说，就是活好当下。。。\n","description":"","tags":null,"title":"读后感——《三体》","uri":"/life/threebody/"},{"categories":null,"content":"八皇后问题 一、前言 1、问题描述 八皇后问题（英文：Eight queens），是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出的问题，是递归回溯的典型案例。\n 问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以编程解决此问题。\n 2、思路分析 我们的主要思路是通过一行一行的放置皇后，来使得每一行都有一个皇后。当然，这些皇后在放置时都必须要满足规定的要求才行。\n因此就会出先如下情况:  放置时不符合规则，继续检索同一行的下一列位置是否合理 如果符合规则就将其放置，然后进行下一行的尝试（递归） 如果有某一行没有可行的解，则退回上一行，消除上一行摆放的皇后，检索剩余的列，看是否有合理的位置，然后继续进行。(回溯) 直到所有的行都被放置为止。  具体操作： 1)第一个皇后先放第一行第一列;\n2)第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适；\n3)继续第三个皇后，还是第一列、第二列......直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解；\n4)当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到；\n5)然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤。\n注意条件： 需要注意的是，我们在放置皇后时需要检测其防止和理性的判断条件为:\n 同一列的上方所有行中是否有皇后 左上方对角线上是否有皇后 右上方对角线上是否有皇后  说明： 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题.arr[8]={0,4,7,5,2,6,1,3}//对应arr下标表示第几行，即第几个皇后，arr[i]=val,val表示第i+1个皇后，放在第i+1行的第val+1列\n 二、算法实现 1、定义相关变量 int max = 8; 定义max变量用于表示有多少个皇后；\nint[] array = new int[max]; 定义数组array，保存皇后放置位置的结果。\n2、输出皇后位置 因为我们使用的是一维数组，所以直接遍历输出该数组即可。\n代码实现如下：\n1 2 3 4 5 6 7  // 输出皇后摆放的位置  private void print() { for (int value : array) { System.out.print(value + \" \"); } System.out.println();// 换行  }   3、检查冲突 该方法用于 查看放置第n个皇后，检测该皇后是否和前面已经摆放的皇后冲突。这里我们使用一个boolean类型 的方法用于判定。如果不冲突就返回true ，否则返回false 。这里我们传入一个n表示是第几个皇后，如果n = 1，就表示是第一个皇后，需要检查的冲突也就是其本身；如果n = 2，表示是第二个皇后，需要检查的冲突是和第一个皇后的冲突，以此类推……所以可以使用for循环遍历，从第一个皇后开始，直到遍历到其本身为止。for(int i = 0; i \u003c n; i++)\n那么判断是否冲突需要遵守的规则是：同一行、列以及对角线不能有皇后。由于我们是使用一维数组来存储皇后摆放的位置，所以就不用判断放置的两个皇后是否在同一行的情况咯。array[i] == array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一列；Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * @param n 表示第n个皇后 * @return 如果不冲突返回true，否则返回false */ private boolean judge(int n) { for (int i = 0; i \u003c n; i++) { /* 说明： 1、array[i] == array[n] 示判断第n个皇后是否和前面的n-1个皇后在同一列 2、Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线 */ if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) { return false; } } return true; }   4、放置皇后 我们传入一个变量n表示放置第n个皇后，当n == max 表示8个皇后已经全部放置完毕，直接打印输出即可，并使用return; 语句跳出方法体。\n然后我们利用for循环依次放入皇后for(int i = 0; i \u003c max; i++)，首先把当前的这个皇后n放入到第1列，然后判断是否冲突，如果不冲突执行check(n + 1); 也就是开始放置下一个皇后；如果冲突，则就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 方法：放置第n个皇后  // 特别注意：check是每一次递归时，进入到check中都有for(int i = 0; i \u003c max; i++)，因此会有回溯  private void check(int n) { if (n == max) {// n = 8 时，表示8个皇后已经全部安放好  print(); return; } // 依次放入皇后，并判断是否冲突  for (int i = 0; i \u003c max; i++) { // 先把当前和这做个皇后n，放到该行的第1列  array[n] = i; // 判断当放置第n个皇后到i列时，是否冲突  if (judge(n)) {// 不冲突  check(n + 1); } //如果冲突，就继续执行array[n] = i;即将第n个皇后放置在本行的后移的一个位置  } }    三、结束语 以上便是关于八皇后问题的简单描述，理解起来可能有些许困难，比如为什么使用一维数组存放数据，如何检查冲突以及整个放置过程中的回溯都是值得动脑筋思考的。\n源码 ——\u003eQueue8\n","description":"","tags":null,"title":"递归应用——八皇后","uri":"/tech/8queen/"},{"categories":null,"content":"今天想说说 关于知足 、 大家经常说“知足常乐”，但对于知足却没有一个明确的定义。\n 语出《道德经》。认为“祸莫大于不知足”，不知满足，进而追求，定招灾祸。知其足，不追求，安于所得，无为无德，反而常常满足。知足才能避免灾祸，才能全生保身。\n 今天我为数不多的一位朋友，遇到了点烦心事，和我唠嗑。然后我对她说“知足就好。” 她说：“ 我太喜欢这个词了，知足常乐”\n但怎么说呢、知足是个好词，每个人都渴望知足，但是从我的角度来说：其实我想要的是比知足多一丢丢，这样才能因为知不足，而保持学习。 知足确实是挺好的，但是人在成长的过程中，往往会由于自己的贪婪或者说是欲望，而不断提高对于自己的要求。当自己的要求更高、更严，从而可以在一定程度上促使自己变得更好、站得更高，那么在那个时候的自己，可能就会变得不那么知足，甚至有点贪得无厌。其实我感觉这些都是人之常情，如果所有人都安于泛泛而谈的知足，那么又有谁来推动社会的进步呢？？\n其实这种想法也是不对的，把贪婪说成知足，把知足说成安逸。我所理解的知足，是一种享受状态，是在于知道自己想得到什么之后，不用多想其他的什么，是完成目标之后的，有点小小的满足，甚至是骄傲的感觉，似乎整个世界都没有烦心事了，又好似整个世界的事情都与自己无关，可以安安稳稳地去做自己想做的事情，没有为了目标而去努力的劳累感。就这样，一切都安静了。。\n事实证明，知足状态下的我，可能会变得一塌糊涂，如果再这种状态下去，甚至会变得一无是处。在暑期，当忙完了所有要紧的事情的时候，当时的我已经精力交瘁，也有一种“知足”的感觉。因为感觉所有的事情都结束了，似乎可以让自己好好休息一段时间咯。当时理想的状态就是：每天写写代码，看看书，练练球，再学点额外的技能之类的。但是这几样，几乎没有一件事情是完成了的。这就是因为人的惰性，人只会着急与眼前的事情，很难去保证或者说坚持一些有意义的事情，让自己可以变得更优秀。\n等等，写到这里，我不由得想到，前面所说的我想要的是比知足多一丢丢 。这似乎就进入了一个死循环当中，每当处理完一些事情（￥%#\u0026噼里啪啦、乱七八糟之类的事），就会进入短暂的休息期，这个期间的自己是不想做任何事的，或者说不想做任何要动脑、动体力的事情，在这个状态下去，就会想是不是因为自己最近的不努力、懈怠，从而导致自己没有进步，与别人的差距又拉开了？？然后就感觉自己不再知足…… 长此以往下去，似乎会让自己变得更累，总感觉自己没有丝毫喘气的机会。。。\n那么问题来了？？究竟什么样的状态才是知足呢？？就如同五月天在歌词中写到：\n 天上的星星笑地上的人，总是不能懂不能觉得足够。\n ","description":"","tags":null,"title":"谈谈知足","uri":"/life/%E7%9F%A5%E8%B6%B3/"},{"categories":null,"content":"迷宫问题 一、前言 在上一篇博客中，我们了解了关于递归的一些基本知识，这次我们讲一下递归的应用——走迷宫。\n我们利用二维数组构建一个迷宫，其中1表示墙，0表示可以的走的路，2表示走过的路。 可以在迷宫中设置挡板，也用1表示。然后利用递归给小球找路。在走迷宫时，我们需要确定一个策略，不能盲目地瞎走，要不然岂不是在里面绕圈圈，哈哈哈哈。策略如下：下-\u003e右-\u003e上-\u003e左，如果该点走不通，再回溯。下面我们开始代码实现一把。\n 二、算法实现 1、创建迷宫 我们先定义一个二维数组map 表示地图。然后再分别将四周（上下左右）设置为墙。再在需要的位置设置挡板，增加出迷宫的难度。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 先创建一个二维数组，模拟迷宫  int[][] map = new int[8][7]; // 使用1表示墙  // 将上下全部置为1  for (int i = 0; i \u003c 7; i++) { map[0][i] = 1; map[7][i] = 1; } // 将左右全部置为1  for (int i = 0; i \u003c 8; i++) { map[i][0] = 1; map[i][6] = 1; } // 设置挡板  map[3][1] = 1; map[3][2] = 1;   2、递归找路 这里我们使用递归setWay(int[][] map, int i, intj)方法，来寻找路线。map 表示地图、传入的i, j 表示小球的起始位置；将终点设置为map[6][5] （除去墙在地图中所占的位置）。如果小球你找到通路，就返回true ，否则返回false 。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true，否则返回false */ public static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) {// 如果当前这点还没有走过  // 按照策略 下 -\u003e 右 -\u003e 上 -\u003e 左 走  map[i][j] = 2;// 假定该点可以走通  if (setWay(map, i + 1, j)) {// 向下走  return true; } else if (setWay(map, i, j + 1)) {// 向右走  return true; } else if (setWay(map, i - 1, j)) {// 向上走  return true; } else if (setWay(map, i, j - 1)) {// 向左走  return true; } else { // 说明该点是走不通，是死路  map[i][j] = 3; return false; } } else {// 如果map[i][j] != 0 可能是1、2、3  return false; } } }    三、结束语 对于迷宫的问题的描述就到这里，总体而言是比较简单的。具体的递归过程可以进行debug一下，更有助于理解。\n源码 ——\u003eMiGong\n","description":"","tags":null,"title":"递归——解决迷宫问题","uri":"/tech/migong/"},{"categories":null,"content":"TwoSum 一、题目概述  给定一个整数数组 nums 和一个目标值 target ，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n 示例：\n给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]  二、解法分析 对于这个题目想必大家并不陌生，可以说是绝大多数人的开始刷题之路的敲门砖。如果是一开始起初接触刷题的朋友，看到这题，可能没有思路，也可能是暴力解法 ，对于我自己就是使用双重for循环遍历暴力解，：）\n下面将使用双重for循环和HashMap两种解法供大家参考：\n1、暴力解法 我们首先来简单的分析一下题目：需要从nums数组中寻找两个数，使这两个数的和等于目标值target，并且数组中同一元素不能使用两次。所以我们可以使用for循环来寻找，外层循环的条件是for(int i = 0; i \u003c nums.length; i++) 即从数组的第一个下标开始遍历，直到遍历到数组结束；内层循环的条件是for(int j = i + 1; j \u003c nums.length; j++) 注意内层循环开始的条件不是从数组的第一个下标开始的，而是从nums[i] 的下一个位置开始遍历，结束条件相同。\n就这样，咱们使用双重for循环如此暴力的遍历，直到遇见了符合nums[i] + nums[j] == target  条件时，返回数组对应的下标即可；如果遍历结束之后，仍然没有在该数组中找到需要的数，则抛出异常。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 使用for循环遍历 暴力解题  public int[] twoSum02(int[] nums, int target) { for (int i = 0; i \u003c nums.length; i++) { for (int j = i + 1; j \u003c nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } throw new IllegalArgumentException(\"Two Sum No Solution\"); }   2、HashMap解法 对于哈希表这种数据结构，这里就不做具体的说明，想要了解的小伙伴可以自己查阅一下相关文档。\n我们先定义一个数组res[] 用于存放最后返回的结果。然后再创建一个哈希表，HashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); 然后对于这个数组进行遍历，每次遍历的时候取出一个数，然后再map 中查询，是否能找到一个合适的数，使两者之和等于目标值target ，如果找到直接返回即可；否则，将该数加入map 。依次进行遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 使用HashMap来解决该问题  public int[] twoSum01(int[] nums, int target) { int[] res = new int[2];// 存放返回的结果  if (nums == null || nums.length \u003c= 1) {// 判断传入的数组是否符合条件  return res; } HashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e();// 创建哈希表  for (int i = 0; i \u003c nums.length; i++) { int num = nums[i]; int val = target - num; if (map.containsKey(val)) {// 在map中寻找  res[0] = map.get(val); res[1] = i; return res; } else { map.put(num, i); } } return res; }    3、结束语 这个也算是开的一个新坑吧，虽然数据结构篇还没有完结。。。。刷题，几乎是一个程序猿的必经之路。大家一起加油！！！\n源码地址 —\u003e TwoSum\n","description":"","tags":null,"title":"TwoSum","uri":"/leetcode/twosum/"},{"categories":null,"content":"关于递归 一、前言 说起递归，可能有些同学会问，什么是递归啊？？ 我们举个简单的栗子：如果你站在镜子前面，这时你会在镜子中看见自己的像，称这个镜子为A；那么有没有试一下在手里也拿一面镜子，把手里的镜子称为镜子B，然后将A、B两面镜子互相面对面放着，你再往中间那么一站，神奇的情况发生了，将会发现两面镜子中都有你的“化身”。为什么会出现这种现象呢？？原来，A镜子里有B镜子的像，B镜子里也有A镜子的像，这样反反复复，就会产生一连串的“像中像”。这其实就是一种递归现象。\n说简单点，就是递归就是方法自己调用自己，每次调用时传入不同的变量。（递归有助于开发者解决复杂的问题，同时可以让代码变得更简洁）\n 二、递归规则 递归需要遵守的重要规则：\n1）执行一个方法时，就创建一个新的受保护的独立空间（栈空间）；\n2）方法的局部变量是独立的，不会相互影响，比如n变量；\n3）如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据；\n4）递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了 : ) ；\n5）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时方法执行完毕或者返回时，该方法也就执行完毕了。\n 三、斐波那契数列 1、概要 **斐波那契数列（Fibonacci）**是一个典型的递归例子，说如果兔子在出生两个月之后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有的兔子都不死。那么，一年以后可以繁殖多少对兔子？？\n我们拿新出生的一对小兔子来分析一下：第一个月的小兔子是没有繁殖能力的，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月后，老兔子又生下一对，因为上个月出生的小兔子还没有繁殖能力，所以还是一共还是三对……依次类推，可以列出下表：\n   所经过的月数 1 2 3 4 5 6 7 8 9 10 11 12     兔子对数 1 1 2 3 5 8 13 21 34 55 89 144    表中数字1,1,2,3,5,8,13……构成一个序列。这个数列有个明显的特点就是：前面相邻两项之和，构成了后一项。\n2、常规解法 先思考一下，如果我们要实现斐波那契数列用常规的迭代方法应该如何实现？\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int[] a = new int[13]; a[0] = 0; a[1] = 1; System.out.println(\"未使用递归计算：\"); System.out.println(\"a[0] = \" + a[0]); System.out.println(\"a[1] = \" + a[1]); for (int i = 2; i \u003c a.length; i++) { a[i] = a[i - 1] + a[i - 2]; System.out.printf(\"第%d个月兔子总数为：%d\", i, a[i]); System.out.println(); }   我们来简单看一遍这段代码，数组a[]表示从第0月到第12月，其中第0个月没有任何兔子，第一个月有一对兔子，然后我们利用for循环，从第2个月开始计算，即下一个月的兔子数为前两个月兔子数相加。\n代码很简单，几乎不用怎么解释，都可以理解，但其实，我们如果使用递归来实现，代码将会更加整洁。\n3、递归解法 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 使用递归计算  System.out.println(\"使用递归计算如下：\"); for (int i = 0; i \u003c a.length; i++) { System.out.printf(\"第%d个月兔子总数为：%d\", i, Fbi(i)); System.out.println(); } // 使用递归的方法处理  public static int Fbi(int i) { if (i \u003c 2) { return i == 0 ? 0 : 1; } else { return Fbi(i - 1) + Fbi(i - 2); } }   虽然代码整体而言要简洁许多，但却并不是那么好理解。函数怎么可以自己调用自己？？听起来确实有些难以理解，不过我们可以不把一个递归函数中调用自己的函数看作是在调用自己，而就当它是在调用另一个函数。只不过，这个函数和自己长得一样而已。\n我们来模拟代码中的Fbi(i)函数当i = 5的执行过程。Fbi(5) = Fbi(4) + Fbi(3) = Fbi(3) + Fbi(2) + Fbi(2) + Fbi(1) = Fbi(2) + Fbi(1) + 1 + 1 + 1 = 1 + 1 + 1 + 1 + 1 = 5\n三、结束语 我们来对比一下这两种实现斐波那契的代码。迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归可以使程序的结构更清晰、更简洁、更容易让人理解。从而有效地减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同的情况选择不同的代码实现方式。\n斐波那契数列源码地址 ——\u003e Fibonacci\n 《大话数据结构》 ——程杰\n ","description":"","tags":null,"title":"数据结构——递归","uri":"/tech/recursion/"},{"categories":null,"content":"后缀表达式——代码讲解 一、前言 在上一篇博客中我们介绍了有关后缀表达式的有关知识，关于如何将中缀表达式转换为后缀表达式，以及后缀表达式的运算规则，做了详细的介绍。因此这篇博客将会用代码来实现一个完整的后缀表达式。\n 二、算法描述 1、将后缀表达式的数据和运算符放入到ArrayList中 我们会获取到一个String类型的后缀表达式，因为对于字符串类型是无法正常完成计算的，因此需要先将后缀表达式里面的数据和运算符按照空格\" \"分割开，然后存放到ArrayList中。\n这里会用到foreach遍历字符串，每遍历一个元素，再利用 list.add() 方法加入到List中，然后返回List即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 依次将一个逆波兰表达式的数据和运算符放入到ArrayList中  public static List\u003cString\u003e getListString(String suffixExpression) { // 将suffixExpression按照空格“ ”分开  String[] split = suffixExpression.split(\" \"); List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (String ele : split) { list.add(ele); } return list; }   2、后缀表达式的运算 关于运算规则，在上一篇博客中已经做过说明，所以这里就不做过多的赘述。我们通过栈来存放扫描到的数字（这里使用正则表达式来判断是否是多位数）。扫描表达式的时候如果遇见运算符，则分别取出栈顶元素和次顶元素，进行计算，并把运算结果再重新入栈。最后留在栈中的数就是该表达式最后的运算结果。需要注意的是：在进行减、除运算的时候，需要注意栈顶元素和次顶元素的位置。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public static int calculate(List\u003cString\u003e ls) { // 创建一个栈（在这里只需要一个栈即可）  Stack\u003cString\u003e stack = new Stack\u003cString\u003e(); // 遍历ls  for (String item : ls) { // 使用正则表达式来取出数  if (item.matches(\"\\\\d+\")) {// 匹配的是多位数  // 入栈  stack.push(item); } else { // pop出两个数，并运算，再入栈  int num1 = Integer.parseInt(stack.pop()); int num2 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\")) { res = num2 + num1; } else if (item.equals(\"-\")) { res = num2 - num1; } else if (item.equals(\"*\")) { res = num2 * num1; } else if (item.equals(\"/\")) { res = num2 / num1; } else { throw new RuntimeException(\"输入的运算符有误！！！\"); } // 把res入栈  stack.push(\"\" + res);// 加上双引号即可转换为字符串形式  } } // 最后留在stack中的数据就是运算结果  return Integer.parseInt(stack.pop()); }    通过上述两种方法，可以实现对于后缀表达式的直接运算。但后缀表达式是计算机容易理解，而相对于人而言，其转换过程是比较头疼的，所以接下来我们实现关于中缀表达式转换后缀表达式的方法。\n 3、将中缀表达式转换成对应的List 对于一个字符串，我们是无法进行操作的，所以首先要做的就是先把中缀表达式转成对应的List。\n需要的变量有： ls(List) 用于存放扫描得到的元素； i(int) 当作指针，用于扫描中缀表达式； str(String) 用于多位数的拼接； c(char) 每遍历一个字符，就放入到c。\n这里我们使用do……while循环来进行遍历，循环的条件是i \u003c s.length();扫描遇到的如果是操作符，直接加入即可；如果是数字，则每次添加的时候先将str置空，然后利用str += c拼接多位数。每次扫描到一个元素之后，指针i需要进行后移，可以利用ASCII码来判断数字的范围，然后进行相关操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 将中缀表达式转换成对应的List  public static List\u003cString\u003e toInfixExpressionList(String s) { // 定义一个List，存放在中缀表达式中对应的内容  List\u003cString\u003e ls = new ArrayList\u003c\u003e(); int i = 0;// 这是一个指针，用于遍历中缀表达式字符串  String str;// 用于多位数的拼接  char c;// 每遍历一个字符，就放入到c  do { // 如果是一个非数字，就需要加入到ls  if ((c = s.charAt(i)) \u003c 48 || (c = s.charAt(i)) \u003e 57) { ls.add(\"\" + c); i++;// i需要后移  } else {// 如果是一个数，需要考虑多位数的情况  str = \"\";// 先将str置空“ ”  while (i \u003c s.length() \u0026\u0026 (c = s.charAt(i)) \u003e= 48 \u0026\u0026 (c = s.charAt(i)) \u003c= 57) { str += c; i++; } ls.add(str); } } while (i \u003c s.length()); return ls;// 返回  }   4、将中缀表达式对应的List转换成后缀表达式 关于中缀表达式转换的规则，在之前也进行过相关的阐述，这里也就不再细说了，不过需要注意的是转换之后的后缀表达式对应的也是List。对于运算符符号操作的时候，我们需要比较运算符的优先级，所以定义一个类，用于返回运算符的优先级。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 编写一个类Operation class Operation { private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; // 编写一个方法，返回对应的优先级数字  public static int getValue(String operation) { int result = 0; switch (operation) { case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; default: System.out.println(\"不存在该运算符\" + operation); break; } return result; } }   具体操作代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 将得到的中缀表达式对应的List转换成后缀表达式对应的List  public static List\u003cString\u003e parseSuffixExpressionList(List\u003cString\u003e ls) { // 定义一个栈，用于存放扫描所得到的符号  Stack\u003cString\u003e s1 = new Stack\u003c\u003e();// 符号栈  // 定义一个ArrayList用于存储中间的结果  List\u003cString\u003e s2 = new ArrayList\u003c\u003e(); // 遍历  for (String item : ls) { // 如果是一个数，加入s2  if (item.matches(\"\\\\d+\")) { s2.add(item); } else if (item.equals(\"(\")) { s1.push(item); } else if (item.equals(\")\")) { // 如果是右括号\")\"，则依次pop出s1栈顶的运算符，并加入s2，直到遇见左括号为止，此时将这一对括号丢弃  while (!s1.peek().equals(\"(\")) { s2.add(s1.pop()); } s1.pop();// 将 ( 弹出s1栈，消除小括号  } else { // 当item的优先级小于或等于s1栈顶运算符，将s1栈顶的运算符弹出，并加入到s2中然后再与s1中新的栈顶运算符相比较  while (s1.size() != 0 \u0026\u0026 Operation.getValue(s1.peek()) \u003e= Operation.getValue(item)) { s2.add(s1.pop()); } s1.push(item); } } // 将s1中剩余的运算符依次弹出并加入到s2  while (s1.size() != 0) { s2.add(s1.pop()); } return s2;// 注意：因为是存放到List，因此按顺序输出就是对应后的后缀表达式对应的List  }    三、结束语 对于栈的应用，使用了中缀表达式和后缀表达式来进行说明，由此可见，想把数据结构学好还是得下一定功夫的，世界上没有随随便便的成功，一步一步踏踏实实地向前走。\n源码 —— \u003e PolandNotation\n","description":"","tags":null,"title":"栈的应用——后缀表达式02","uri":"/tech/polandnotation02/"},{"categories":null,"content":"后缀表达式——预备知识 一、前言 在上一篇博客中，我们介绍了中缀表达式的相关操作过程，虽然中缀表达式比较符合我们的日常使用习惯，但是对于计算机却不那么容易去理解，因此有了我们今天要介绍的——后缀表达式。\n例如：( 3 +4 ) * 5 - 6 对应的后缀表达式就是3 4 + 5 * 6 -，那么这个操作过程是怎么实现的呢？？以及后缀表达式该如何进行运算呢？？在下面的内容，我们来一探究竟。\n 二、中缀表达式转后缀表达式 1、规则： 1）初始化一个运算符栈s1和一个用云储存中间结果的List s2；\n2）从左到右扫描中缀表达式；\n3）如果遇到操作数，直接加入到s2；\n4）如果遇到运算符，则比较其与s1栈顶元素的优先级：\n4.1）如果s1为空，或栈顶运算符为左括号\"(\"，则直接将此运算符入栈；\n4.2）若当前运算符比栈顶运算符的优先级高，也将此运算符入栈；\n4.3）否则，将s1栈顶的运算符弹出并加入到s2中，然后再回到4.1）与s1中新的栈顶运算符相比较；\n5）遇到括号时：\n5.1）如果是左括号\"(\"，则直接压入s1；\n5.2）如果是右括号\")\"，则依次弹出s1栈顶的运算符，并加入s2，直到遇见左括号为止，此时将这一对括号丢弃；\n6）重复上述步骤 2）至 5），直到表达式的最右边；\n7）再将s1中剩余的运算符依次加入到s2；\n8）依次输出s2中的元素，输出结果就是相对应的后缀表达式。\n2、举例说明 将中缀表达式\"1+((2+3)*4)-5\"转换为后缀表达式的过程如下：\n   扫描到的元素 s2（表头—\u003e表尾） s1（栈底—\u003e栈顶） 说明     1 1 空 数字，直接加入到s2   + 1 + s1为空，运算符直接入栈   ( 1 + ( 左括号直接入栈   ( 1 + ( ( 左括号直接入栈   2 1 2 + ( ( 数字，直接加入到s2   + 1 2 + ( ( + s1栈顶为左括号，运算符直接入栈   3 1 2 3 + ( ( + 数字，直接加入到s2   ) 1 2 3 + + ( 右括号，弹出s1中的运算符，直至遇到左括号   * 1 2 3 + + ( * s1栈顶元素为左括号，运算符直接入栈   4 1 2 3 + 4 + ( * 数字，直接加入到s2   ) 1 2 3 + 4 * + 右括号，弹出s1中的运算符，直至遇到左括号   - 1 2 3 + 4 * + - -与＋优先级相同，因此弹出+，再压入-   5 1 2 3 + 4 * + 5 - 数字，直接加入到s2   到达最右端 1 2 3 + 4 * + 5 - 空 s1中剩余的运算符     三、后缀表达式运算 后缀表达式的运算还是利用栈这种数据结构，这里我们利用\"3 4 + 5 * 6 -\"这个后缀表达式来进行说明：\n1、规则：  从左到右遍历表达式的每个数字和字符，遇到是数字就进栈，遇到是运算符，就将处于栈顶两个数字（栈顶元素和次顶元素）出栈，进行运算，运算结果进栈，一直到最终获得结果。\n 2、具体操作： 1）从左至右扫描，将3和4压入栈；\n2）遇到+运算符，依次弹出4和3（4为栈顶元素，3为次顶元素），并计算4 + 3的结果，得7，再将7入栈；\n3）将5入栈；\n4）接下来是*运算符，依次弹出5和7，计算出7 * 5 = 35，将35入栈；\n5）将6入栈；\n6）最后是-运算符，计算出35-6的值，即29，由此得出最终结果。\n 三、结束语 因为后缀表达式相对而言是比较复杂的，所以我们分两篇博客进行讲解，这里先介绍的是如何将中缀表达式转换为后缀表达式以及后缀表达式的运算。在下一篇博客中，将进行具体的代码说明。\n","description":"","tags":null,"title":"栈的应用——后缀表达式01","uri":"/tech/polandnotation01/"},{"categories":null,"content":"中缀表达式 一、前言 栈的现实应用有很多，这次我们重点来说一下，关于如何使用栈来求数学表达式的值，这里我们描述的为中缀表达式，也就是我们在日常生活中经常使用的四则运算式的形式。\n大家是否还记得，当我们在上小学的时候，老师们时常强调的“先乘除后加减，从左往右算”之类的话呢？？这其实就是四则运算的规则，那么在我们学习编程之后，该如何使用程序来解决这个问题呢？？\n二、算法描述 我们需要一个栈来存放数据（数栈numStack）和另一个栈来存放运算符（符号栈operStack）。那么在此之前，我们需要定义一个类来表示栈。\n1、定义一个类表示栈 在这个类中，我们需要完成的方法有：判断栈满栈空、入栈、出栈、查看栈顶元素、判断是否是运算符、比较运算符的优先级以及运算方法。\n在这里有些方法以及变量的说明，在数组模拟栈已经做出相关说明，这里就直接使用，不做过多的解释。\n①定义相关变量及赋值 代码实现如下：\n1 2 3 4 5 6 7 8 9  private int[] stack;// 数组，用于模拟栈，数据就存放在该数组  private int maxSize;// 栈的大小  private int top = -1;// 表示栈顶，初始化为-1  // 构造器  public ArrayStack2(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; }   ②判断栈满 栈空 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 栈满  public boolean isFull() { return top == maxSize - 1; } // 栈空  public boolean isEmpty() { return top == -1; }   ③入栈 —— push 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 入栈 —— push  public void push(int value) { if (isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; }   ④出栈 —— pop 代码实现如下：\n1 2 3 4 5 6 7 8 9  // 出栈 —— pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据~~~\"); } int value = stack[top]; top--; return value; }   ⑤查看栈顶元素 在这里增加一个方法，用于返回当前栈顶的值，但不是真正的top。那么有些小伙伴可能会问，为什么会在这里增加一个查看栈顶元素的方法呢？？其实我们在存放运算符入符号栈的时候，需要先判断入栈元素与栈顶元素的优先级。这里增加查看栈顶元素的方法，就不用再取出栈顶元素咯，更加有利于我们进行比较运算符的优先级。\n代码实现如下：\n1 2 3 4  // 增加一个方法，可以返回当前栈顶的值，但不是真正的top  public int peek() { return stack[top]; }   ⑥判断是否是运算符 这个方法用于判断表达式中的元素是否是运算符，如果是运算符则直接入符号栈。在这里我们只考虑\"+\"、\"-\"、\"*\"、\"/\"四种运算符。\n代码实现如下：\n1 2 3 4  // 判断是否是运算符  public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; }   ⑦比较运算符的优先级 因为进行四则运算需要遵循”先乘除后加减“的规则，所以需要规定运算符的优先级。我们在这里规定：优先级越高，则返回的数字越大。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 返回运算符的优先级，优先级是由程序猿来确定的，使用数字表示  // 这里规定：优先级越高，返回的数字越大  public int priority(char oper) { if (oper == '*' || oper == '/') { return 1; } else if (oper == '+' || oper == '-') { return 0; } else { return -1;// 假定目前表达式的运算符只有+、-、*、/  } }   ⑧计算方法 具体的计算流程如下：分别从数栈pop出两个数：num1和num2，以及从符号栈pop出一个符号：oper，然后根据pop出的符号进行相关运算。\n在这里我们需要注意的是：因为num1是先取出的，num2是后取出的，所以在进行减除运算的时候，需要注意一下顺序。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 计算方法  public int cal(int num1, int num2, char oper) { int res = 0;// res用于存放计算的结果  switch (oper) { case '+': res = num1 + num2; break; case '-': res = num2 - num1; break; case '*': res = num2 * num1; break; case '/': res = num2 / num1; break; default: break; } return res; }    2、具体运算操作 ①相关变量的定义 我们前文提到了，需要一个数栈numStack，用于存放从表达式中扫描得到的数字；再定义一个符号栈operStack，用于存放扫描得到的运算符；定义一个index用于扫描表达式；num1、num2、oper分别表示取出的数字和运算符。再定义一个字符类型的变量ch，用于存放每次扫描所得到的运算符；定义res用于存放经过计算之后的数；在对于数字进行扫描到时候，如果是多位数，不能发现是一个数就入栈，需要往后面再看一位，如果是数字就继续扫描，否则push入栈，因此需要定义一个变量keepNum用于拼接多位数。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  String expression = \"7*21*2-5+1-5+3-4+2/1\"; //创建两个栈，一个数栈，一个符号栈  ArrayStack2 numStack = new ArrayStack2(100); ArrayStack2 operStack = new ArrayStack2(100); //定义需要的相关变量  int index = 0;//用于扫描  int num1 = 0; int num2 = 0; char oper = 0; int res = 0; char ch = ' ';//将每次扫面得到的运算符保存到ch  String keepNum = \"\";//用于拼接,处理扫描到的数字是多位数   ②扫描表达式 这一步是程序的核心内容，也是运算实现的关键步骤。我们可以使用while循环来操作。\n首先，利用index索引进行扫描表达式，依次得到表达式的每一个字符，可以使用substring()来操作，即ch = expression.substring(index,index+1).charAt(0); 在得到表达式的各个字符之后，然后判断ch是什么符号。\n先假设扫描得到的ch是运算符。如果此时符号栈operStack中已经有运算符，则需要比较当前运算符和栈顶元素的运算符的优先级，如果当前的操作运算符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的运算符入符号栈。（注意：别忘了把当前的运算符push入符号栈）；如果当前的运算符的优先级大于栈中的运算符，则直接入符号栈。另外注意，我们到现在为止，所描述的都是符号栈内有操作符的情况，如果符号栈为空，直接push当前运算符入栈即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  if (operStack.isOper(ch)) {//如果是运算符  //判断当前的符号栈是否为空  if (!operStack.isEmpty()) { //如果符号栈有操作符，就进行比较，如果当前的操作运算符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数  //再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的运算符入符号栈  if (operStack.priority(ch) \u003c= operStack.priority((char) operStack.peek())) { num1 = numStack.pop(); num2 = numStack.pop(); oper = (char) operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果入数栈  numStack.push(res); //然后将当前的操作符入符号栈  operStack.push(ch); } else { //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈  operStack.push(ch); } } else { //如果为空直接入符号栈  operStack.push(ch); } }   现在我们来假设如果扫描得到的是数字，将会如何操作呢？？因为扫描得到的数字，其实是字符型，所以需要转化为整型，这里使用的是Integer。还有需要注意的就是，该如何处理多位数的问题。\n分析思路： * 1、当处理多位数时，不能发现是一个数就立即入栈，因为它有可能是多位数 * 2、在处理数时，需要向expression的表达式的index 后再看一位，如果是数就进行扫描，如果是符号才入栈 * 3、因此需要定义一个变量 字符串，用于拼接 在定义变量的时候我们提到了keepNum，可以使用它来拼接多位数，即keepNum += ch; 但是如果扫描得到的数字是最后一个数字，直接push入栈即可；如果不是最后一位，就需要往后看一位，若后面一位还是数字，则需要继续扫描，直到不是数字为止，同样可以利用substring来实现。每次扫描完成之后需要将拼接符keepNum清空，这一步是千万不能少！！！\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  else {//如果是数，则直接入数栈  //处理多位数  keepNum += ch; //如果ch已经是expression的最后一位，就直接入栈  if (index == expression.length() - 1) { numStack.push(Integer.parseInt(keepNum));//Integer将字符串转化为整型  } else { //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈  //注意是最后一位，不是index++  if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) { //如果后一位是运算符，则入栈 keepNum = \"1\" 或者 ”123“  numStack.push(Integer.parseInt(keepNum)); //重要！！！！！，keepNum清空  keepNum = \"\"; } } }   在完成上述操作之后，需要将index后移，直到index的比表达式长度的值大时，退出循环。\n代码实现如下：\n1 2 3 4 5  //让index + 1，并判断是否扫描到expr最后  index++; if (index \u003e= expression.length()) { break; }   ③完成计算 在完成扫描之后，就顺序从数栈和符号栈中pop出相应的数字和符号完成计算。\n同样可以利用while循环来完成。将最后的计算结果res入数栈。别忘了把数栈中最后的数取出，这个数就是表达式的计算结果。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行  while (true) { // 如果符号栈为空，则运算到最后的结果，数栈中只有一个数字【结果】  if (operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = (char) operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res);//入栈  } //将数栈的最后数，pop出，就是结果  int res2 = numStack.pop(); System.out.printf(\"表达式%s = %d\\n\",expression,res2); }    三、结束语 关于使用栈实现中缀表达式的描述，真的太吃力了，能明显感觉到需要描述不清晰的地方，如果小伙伴们有较好的阐述方法或者建议，都可以提交pr或者issue。\n源码——\u003e Calculator\n","description":"","tags":null,"title":"栈的应用——中缀表达式","uri":"/tech/calculator/"},{"categories":null,"content":"单链表模拟栈 一、前言 在上一篇博客中，我们开启了对于栈的数据结构的相关讲解，使用的是数组模拟栈，在这篇博客中，我们将介绍一下如何利用链表来模拟栈。\n之前对于栈这种数据结构的相关定义以及应用场景已经做了简单的说明，在此就不做过多的赘述，下面我们开始了解一下算法的实现过程吧。\n 二、算法实现 1、创建结点类 在使用链表模拟栈之前，我们需要先创建一个结点类，存放信息，以及相关的使用方法。\n该类中所包含的信息有：创建data域用于存放结点信息，next域用于指向下一个结点的指针；利用构造器传入给结点赋值的信息；以及利用toString方法显示结点信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 定义一个类表示结点 class StackNode { public int data;// data域用于存储数据  public StackNode next;// next域用于链接下一个结点  // 构造器  public StackNode(int data) { this.data = data; this.next = null; } @Override public String toString() { return \"StackNode{\" + \"data=\" + data + '}'; } }   2、创建一个类用于管理结点 ①定义相关变量以及赋值 我们可以定义一个头结点top，用来表示栈顶，再定义一个size用于表示栈的大小，并且用于记录入栈和出栈的元素。\n代码实现如下：\n1 2 3 4 5 6 7 8  private StackNode top = null;// 定义一个头结点，表示栈顶  private int size; // 初始化  public LinkedListStack() { top = null; size = 0; }   ②判断链栈是否为空 定义的头结点top是可以存放数据的，所以当top没有存放任何数据的时候，链栈为空。\n代码实现如下：\n1 2 3 4  // 判断链栈是否为空  public boolean isEmpty() { return top == null; }   ③获取有效结点的个数 在定义变量size的时候，提到size可以用来记录链栈的数据入栈和出栈情况，所以我们可以使用getSize()方法，返回的值就是当前链栈的有效结点。\n代码实现如下：\n1 2 3 4  // 获取size的大小  public int getSize() { return size;   ④入栈 —— push 链栈的入栈操作总体上来说还是比较简单的，传入一个需要添加的结点stackNode。与单链表添加结点不同的是，单链表添加的结点在链表的最后，而链栈需要保证的是所添加的结点需要在栈顶。\n因此，我们需要先将新的结点后继结点指向当前链栈的栈顶元素，即stackNode.next = top; （这时原来栈顶的位置就变成了先添加结点的后继结点的位置），然后再将新添加的结点设置为栈顶元素，即top = stackNode; （这时新添加的结点就是栈顶元素）。最后别忘记，每添加一个结点，size需要+1。\n代码实现如下：\n1 2 3 4 5 6 7  // 入栈 —— push  public void push(StackNode stackNode) { stackNode.next = top; top = stackNode; size++; }   ⑤出栈 —— pop 在出栈之前，我们需要先判断链栈是否为空，如果为空则给出相应的提示（这里我们通过抛出异常的方式来进行处理）。至于链栈的出栈操作，具体实现如下：\n先将栈顶元素临时赋值给临时变量temp保存，然后将栈顶元素toptemp的下一个结点。这时栈顶元素的信息已经保存在temp当中。紧接着，再定义一个临时变量retValue，用于存储栈顶元素的data域。在完成上述操作之后，我们还需要将 temp置空，别忘了**size--**和返回retValue。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 出栈 —— pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"链栈为空~~\"); } StackNode temp = top;// 辅助变量  top = temp.next; int retValue = temp.data;// 定义一个临时变量，用于保存栈顶元素  temp = null;// 将temp置空  size--; return retValue; }   ④显示链栈信息 显示链栈信息的方法，与单链表显示方法一样，所以我们直接上代码，哈哈哈哈哈\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示栈中信息  public void show() { if (isEmpty()) { System.out.println(\"链栈为空~~\"); return; } StackNode temp = top; while (temp != null) { System.out.println(temp); temp = temp.next; } }    三、结束语 到这里，我们完成了对于栈的两种实现方式，相对于使用链表实现，数组更容易让我们接受一点。在编写入栈和出栈方法的时候，一开始直接参照单链表的相关实现方法，因此走了不少弯路，所以在学习过程中我们需要学会比较着来学，这样可以帮助我们更好地巩固所学的知识。\n其实关于出栈操作的方法，我总觉得不够好，似乎缺少了点什么。关于临时变量temp，如果不定义temp，而是对栈顶元素直接操作，会发生些什么呢？？小伙伴们可以自己尝试一下，如果有更好的实现方法，也欢迎提出issue噢！\n源码 ——\u003e [数据结构]\n","description":"","tags":null,"title":"数据结构——链表模拟栈","uri":"/tech/linkedliststackdemo/"},{"categories":null,"content":"数组模拟栈 一、基本介绍 1、相关定义  栈是一个先入后出的有序列表； 栈是限制线性表中元素的插入和删除只能在线性表的同一段进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top）,另一端为固定的一端，称为栈底（Bottom）； 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先删除的元素最后删除。  2、应用场景  子程序的调用：在跳往子程序前，会先将下个指令的地址存放到堆中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数、区域变量等数据存入到堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。 二叉树的遍历。 图形的深度优先（depth - first）搜索法。   二、算法实现 需要构建一个ArrayStack类，用于表示栈。\n1、定义相关变量以及赋值 需要定义的相关变量有：定义一个数组模拟栈int[] stack、栈的大小maxSize以及栈顶元素top。（在这里我们把栈顶元素top的初始值为-1，有利于后期存入和删除数据）。\n定义完相关变量之后，我们可以利用构造器对maxSize和stack数组进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  private int maxSize;// 栈的大小  private int[] stack;// 数组，数组模拟栈，数据就在该数组  private int top = -1;// top表示栈顶，初始化为-1  // 构造器  public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; }   2、判断栈是否为满 因为数组的下标是从0开始的，所以当栈满时，栈顶元素的下标为stack[top] = maxSize - 1;所以当 top == maxSize - 1时，栈满。\n代码实现如下：\n1 2 3 4  // 栈满  public boolean isFull() { return top == maxSize - 1; }   3、判断栈是否为空 之前在定义相关变量的时候，我们提到top的初始值为-1，即当 top == -1时，栈中没有存入任何数据，为空。\n代码实现如下：\n1 2 3 4  // 栈空  public boolean isEmpty() { return top == -1; }   4、入栈——push 方法 在入栈之前，我们首先需要判断栈是否已满，如果栈满则给出提示，并结束程序。否则执行以下操作：由于top的初始值为-1，即数组第一个元素的前一个位置，因此需要先移动top到指定位置，然后给其赋值即可。（先后移再赋值）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 入栈——push  public void push(int value) { // 先判断栈是否未满  if (isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; }   5、出栈——pop 方法 在进行出栈操作之前，我们首先需要判断栈是否为空，如果为空，则给出相关提示（这里我们是用抛出异常的方式来进行处理）；否则，执行以下操作：先定义一个临时变量value来存储栈顶元素，然后栈顶元素top--，往前移动，最后返回临时变量即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 出栈——pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据~~~\"); } int value = stack[top]; top--; return value; }   6、打印输出栈的信息 如果栈为空，则没有任何数据可以显示，所以在输出栈的信息之前，我们需要先判断栈是否为空。在遍历的时候，我们需要从栈顶开始显示数据。可以通过for循环l来实现。\n因为是从栈顶开始显示数据，所以循环的起始位置应该为栈顶top，循环结束的条件应该为i \u003c 0，每执行一次循环，则需要i--。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 遍历栈，遍历时，需要从栈顶开始显示数据  public void show() { if (isEmpty()) { System.out.println(\"栈空，没事有数据~~~\"); return; } // 需要从栈顶开始显示数据  for (int i = top; i \u003e= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } }    三、结束语 这里我们使用的是数组模拟栈的操作，所以说对应的也可以利用链表来模拟栈，小伙伴们可以自己先尝试一下噢。\n在写代码的时候，因为是利用数组模拟栈的相关操作，不由的想起之前写过的数组模拟单向队列，两者可以进行比较的学习，可以思考一下，同样是没有取模的操作，为什么单向队列不能够进行复用，而栈却可以呢？？\n源码地址——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——数组模拟栈","uri":"/tech/arraystackdemo/"},{"categories":null,"content":"两年前的这个时候，高考也已经告一段落。一直以来，都太强调学习，满脑子里想的都是”知识改变命运“这种空而大的口号。其实这一点，直到今天，还依然未变。要不看了这么多年的书，岂不是白看了嘛？？哈哈哈哈哈……\n在高三的时候，总想着，只要再努力一点，再多背一个单词，多做一道题目，就离考了大学更进一步，但其实不然。当拿到报考指南的那一刻，还是傻眼了。似乎有一种无力感，高考查完分之后的那种兴奋再也找不到了，就在想：当时熬的夜，还值得吗？？都说付出就会有回报，但结果呢？？这大概就是灰色而幽默的现实，当头一棒，给我敲醒。我只是个蝼蚁，还有很长的路要走！！\n在大一的时候，大部分的同学的共同语言，还是关于“高三”。似乎，之前的所有经历和高三相比都不值一提，还是当时眼界太低，能看见的只有高考呢？？上了大学，懵懵懂懂，总想着，摆脱了高中的条条框框的拘束，也有个平台可以展示自己了。其实现在反过来，想想当时自己为什么要加哪些组织、社团呢？？是真的喜欢吗？？还是单纯的为了学分呢？？还是利益相关呢？？大一刚入学的时候，感觉那些当着学生组织负责人的学长学姐好了不起，如果自己到了那个时候，会变得和他们一样优秀吗？？大一，也许在悔恨高中为什么不努力好好学习，也许是刚刚告别高三，还把看书、刷题当做一种习惯，但慢慢的，随着时间的推移，当时的屠龙少年，现在也变成了一条恶龙。（前段时间在整理书柜的时候，发现了大一时候学高数，演算的稿纸，还真的挺佩服那时候的自己）\n到了大二，渐渐的在学校里有了自己的圈子，创立了自己的社团，原以为会变成自己想要的样子，迎来的却是各种毒打，其实也算不上毒打，准确来说是劝退。当热情被慢慢消磨殆尽，坚持下来的可能就是责任了吧。那如果连责任心都没了呢？？我还有什么坚持下去的理由呢？？\n到现在，回过头来，看看高三时候的自己，可能会对他说：把一切都看淡一点，没什么大不了的。是的，没什么大不了的。说句鸡汤的话：只要你努力，总不会变得太差劲。\n 其实这篇文章，在好久之前就想写，但一直找不到带入点，也不知该如何去说起。可能是最近的烦心事多了，又变得消极了点，心里有情绪，总归要抒发出来的嘛。\n","description":"","tags":null,"title":"写个两年前的自己","uri":"/life/%E5%86%99%E4%B8%AA%E4%B8%A4%E5%B9%B4%E5%89%8D%E7%9A%84%E8%87%AA%E5%B7%B1/"},{"categories":null,"content":"环形链表  一、基本介绍 1、问题来历 据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。\n2、问题简化 在了解了约瑟夫环的来历之后，我们对该问题进行以下简化。其实我们联系一下，将会发现约瑟夫环是不是和我们小时候玩的丢手帕有些类似呢？\n那么我们首先假设有五个小孩围城一个圈，然后从第一个小孩开始报数，每次数到2，则这个小孩出圈，以此类推，通过简单地推理我们可以得出，出队列的顺序是：2—\u003e4—\u003e1—\u003e5—\u003e3.\n在了解了有关约瑟夫环的介绍之后，我们可以使用单向环形链表来对它进行相关操作。这里我们使用的是没有头结点的链表。\n 二、算法描述 1、定义结点 定义一个结点，存放小孩的编号。在之前介绍链表的时候，我们定义变量的属性都是共有的，这里我们尝试一下私有的，因此需要使用到get和set方法，来进行赋值和获取相关变量。同时，还需要一个构造器，分别用于传入结点的编号。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 创建一个Boy类，表示一个结点 class Boy { private int no;// 编号  private Boy next;// 指向下一个结点，默认为null  // 构造器  public Boy(int no) { this.no = no; } public int getNo() { return no; } public Boy getNext() { return next; } public void setNo(int no) { this.no = no; } public void setNext(Boy next) { this.next = next; } }   2、定义一个类用于管理结点 首先需要创建一个first结点，不存放任何数据，也就是当前没有编号的结点。\n代码实现如下：\n1 2  // 创建一个first结点，当前没有编号  private Boy first = null;   ①添加结点入链表 首先传入一个nums表示需要添加结点的个数。在进行添加之前，还需要判断传入的nums是否符合要求。然后定义一个curBoy辅助指针，帮助构建环形链表。\n我们通过for循环创建结点，先创建第一个结点，让first结点指向该结点，然后first的next域指向自己，构成一个环，最后再让辅助指针curBoy指向first，即完成第一个结点的添加操作；添加其它结点的方法如下：先让curBoy的下一个结点指向需要添加的结点（通过setNext方法），然后再让该结点的next域指向first结点，形成环，最后使curBoy指向当前添加的结点（为了方便下一次添加结点），从而完成添加结点的相关操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 添加小孩结点，构建一个环形的链表，nums表示需要添加结点的个数  public void addBoy(int nums) { if (nums \u003c 1) {//检验  System.out.println(\"nums的值不正确\"); return; } Boy curBoy = null;// 辅助指针，帮助构建环形链表  // 使用for循环俩创建环形链表  for (int i = 1; i \u003c= nums; i++) { // 根据编号，创建小孩结点  Boy boy = new Boy(i); // 如果是第一个小孩  if (i == 1) { first = boy; first.setNext(first);// 构成环  curBoy = first; } else { curBoy.setNext(boy); boy.setNext(first); curBoy = boy; } } }   ②遍历输出环形链表 首先判断链表是否为空，即if(first == null)，如果为空则给出提示；不为空则执行以下操作：因为first结点不能动，因此需要一个辅助变量用于完成遍历，即 Boy curBoy = first，然后我们使用while来进行循环遍历。通过getNext方法实现后移，如果curBoy的下一个结点为first则遍历结束，退出循环。完成链表的遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 遍历当前的环形链表  public void showBoy() { // 判断链表是否为空  if (first == null) { System.out.println(\"该环形链表为空~\"); return; } // 因为first不能动，因此需要一个辅助指针完成遍历  Boy curBoy = first; while (true) { System.out.printf(\"小孩的编号%d\\n\", curBoy.getNo()); if (curBoy.getNext() == first) {// 说明已经遍历完毕  break; } curBoy = curBoy.getNext();// curBoy后移  } }   ③完成结点出链表 我们需要传入几个参数，startNo表设从第几个结点开始报数，countNum表示需要数几下，nums表示圈中有多少个小孩。\n首先需要对数据进行一个校验，即判断环形链表是否为空，开始报数的位置不能低于1，也不能大于圈中的结点。\n代码实现如下：\n1 2 3 4  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; }   然后需要创建一个辅助指针helper，帮助完成小孩出圈。接下来我们需要将helper先指向链表的最后这个结点，即helper的下一个结点就是first结点。紧接着通过while循环，我们再将first和helper指针同时移动countNum - 1次，到达需要出圈结点的位置。\n最后也是最关键的一步，完成小孩结点出圈。先让first结点指向它的下一个结点，即first = first.getNext();，然后再将helper的下一个结点设置为当前first所指向的结点，即helper = helper.setNext(first);，这样first原来所指向的结点没有任何引用，就会被回收。\n如果helper == first,则说明圈中只有一个结点。输出这个结点的信息，就完成了出圈的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /** * 根据用户的输入，计算出小孩出圈的顺序 * * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少个小孩在圈中 */ public void countNum(int startNo, int countNum, int nums) { // 先对数据进行校验  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; } // 创建一个辅助指针，帮组完成小孩出圈  Boy helper = first; //需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这结点  while (true) { if (helper.getNext() == first) {// 说明helper指向最后小孩结点  break; } helper = helper.getNext(); } // 当小孩报数前，先让first和helper指针同时移动 startNo - 1 次，到达需要报数的位置  for (int j = 0; j \u003c startNo - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 当小孩报数时，让first和helper指针同时移动countNum - 1次，然后出圈  // 这里使用循环操作，直到圈中只有一个结点  while (true) { if (helper == first) {// 说明圈中只有一个结点  break; } // 让first和helper指针同时移动countNum - 1次  for (int j = 0; j \u003c countNum - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 这时first指向的结点，就是要出圈的小孩结点  System.out.printf(\"小孩%d出圈\\n\",first.getNo()); first = first.getNext(); helper.setNext(first); } System.out.printf(\"最后留在圈中的小孩编号%d\\n\",first.getNo()); }    三、结束语 在此，更新了环形链表，关于链表的所有基础知识也就要告一段落咯。谈谈我一开始学习链表的感觉吧，从一个小白，刚开始接触数据结构，就被其中各种复杂的结构所惊讶到。特别在学习到链表的时候，更加感觉到举步维艰，似乎很玄学，说不懂，但其实还是有一点点明白大概的结构。但是距离能够独立写出一个链表的结构还有很长一段路要走。因此我查阅了一些相关博客，只看代码和文字描述，总感觉少了点什么，写得再好的代码和文字，倒不如一张图来得实在，所以在学习的时候，我建议可以结合画图来实际操作，这样更方便理解，还有利于记忆。\n环形链表源码—\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——约瑟夫环","uri":"/tech/circlelinkedlistdemo/"},{"categories":null,"content":"关于我？ 叫我二夕就好，可能看到这里，你会好奇，为啥起一个这么怪的名字呢？？\n当时在想昵称的时候一直找不到合适的，打算叫“无名”，但总感觉有点落了俗套。还好，中文是比较有意思的，把“无”和“名”下面的部分拿了，不就是“二夕”了嘛。。。。。哈哈哈哈哈哈\n 玩什么？？ 常常会感慨自己是个老年人了，过了打游戏的年龄。在大学生活中，不打游戏，时间就多了起来。无聊的时候，总想找些东西打发时间。慢慢的，找到新的伙伴——悠悠球。停停停！！！我知道你想说：刚刚还感慨自己是老年人，现在又玩起小孩子的东西。\n大多数人对于悠悠球的印象可能还停留在儿时的玩具，是的，重新开始接触的时候，我也是那么认为的。但随着技术的提升，认识的玩家越来越多，会发现一个全新的世界。你会发现，有很多人都在为之而共同努力。只想把悠悠球，一种玩具，小众文化，推向大众。想得到大众的认可。\n 除了玩？？ 除了玩，那肯定就是吃和睡咯……呸呸呸，这不是我！！！\n学的专业是软件工程，所以平时最多打交道的就是代码，哪还有时间吃吃睡睡的，捋了捋自己的头发。作为一个日常摸鱼的当代大学生，平时无非就是看看书，写写代码，听听歌。就这？？\n","description":"","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"双向链表  一、基本介绍 在上一篇博客中，我们提到了单链表，它只有一个next指针，指向下一个结点，所以我们要查找下一个结点是很容易做到的，但是要想查找上一个结点就复杂的多了。因此有了双向链表。\n双向链表有两个指针域，除了有next域指向下一个结点之外，还有pre域指向上一个结点。这样使得双链表可以双向遍历。节省了时间成本，但相比于单链表插入数据和删除数据就相对复杂一些。下面我们对双链表进行简单学习一下吧。\n 二、算法实现 双链表和单链表一样，需要创建一个类用于存放结点信息，再创建一个类用于管理结点，对双链表进行相关的操作。\n1、定义节点类 我们需要在HeroNode2类中实现相关变量的定义、赋值以及显示信息的方法。\n①相关变量 这里我们使用双链表存储水浒英雄，和单链表相同，还得增加一个pre指针，指向前一个结点。\n代码实现如下：\n1 2 3 4 5  public int no; public String name; public String nickname; public HeroNode2 pre;// 指向下一个结点，默认为null  public HeroNode2 next;// 指向前一个结点，默认为null   ②构造器 利用构造器，对相关变量进行赋值。\n代码实现如下：\n1 2 3 4 5  public HeroNode2(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 这里利用toString方法，返回链表的信息。\n1 2 3 4 5 6 7 8 9  // 为了显示方法，重写toString  @Override public String toString() { return \"HeroNode2{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }    2、定义一个DoubleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，同样需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  // 先初始化一个结点，头结点不要动，不存放具体的数据  private HeroNode2 head = new HeroNode2(0, \"\", \"\");   ①添加数据到队列尾 与单链表相同，需要先定义一个辅助变量temp，利用while循环遍历到链表的最后。当退出while循环时，即temp指向了链表的最后。这时我们需要将temp的next域指向需要添加的结点，然后再将需要添加的结点的pre域指向temp，完成添加。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 添加一个结点到双向链表的最后  public void add(HeroNode2 heroNode2) { // 因为head结点不能动，因此我们需要添加一个辅助变量temp  HeroNode2 temp = head; // 遍历链表，知=找到链表的最后  while (true) { if (temp.next == null) {// 遍历到链表的最后  break; } // 如果没有找到将temp后移  temp = temp.next;// 后移  } // 当退出while循环时，temp就指向了链表的最后  // 形成了一个双向链表  temp.next = heroNode2; heroNode2.pre = temp; }   ②根据编号顺序添加结点 与单链表相同，需要先找到需要添加结点(heroNode2)的前一个结点（temp），这里不做过多赘述。当找到需要添加的结点的前一个结点之后，需要进行如下操作：\n需要先将heroNode2完成拼接，即先将heroNode2的next域指向temp.next;（新插入节点的前一个结点指向它的下一个结点），再将heroNode的pre域指向temp（将新插入的结点指向它的前一个结点），这时heroNode的pre域和next域已经分别指向了heroNode的前驱结点和后继结点；剩余需要做的就是让heroNode的前驱结点的next域和后继结点的pre域指向heroNode，但需要注意的是：如果添加的位置刚好是最后一个结点，则heroNode没有后继结点，也就是不用执行temp.next.pre = heroNode2。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 根据编号顺序添加结点  public void addByOrder(HeroNode2 heroNode2) { HeroNode2 temp = head; boolean flag = false; while (true) { if (temp.next == null) { break; } if (temp.next.no \u003e heroNode2.no) { break; } else if (temp.next.no == heroNode2.no) { flag = true; break; } temp = temp.next; } if (flag) { System.out.printf(\"需要插入的英雄编号%d已存在，添加失败\\n\", heroNode2.no); } else { heroNode2.next = temp.next;// 将新插入的结点指向它的下一个结点  heroNode2.pre = temp;// 将新插入的结点指向它的前一个结点  // 注：如果不是最后一个结点，则不需要执行下面这块代码，否则会出现空指针  if (temp.next != null) { temp.next.pre = heroNode2; } temp.next = heroNode2; } }   ③修改结点信息 修改结点信息的方法和单链表如出一辙，通过遍历找到需要修改结点所在的位置即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 修改结点信息（可以看待双向链表的结点内容修改和单向链表一样）  public void update(HeroNode2 newHeroNode2) { // 判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 找到需要修改的结点，根据no编号  HeroNode2 temp = head.next;// 定义一个辅助变量  boolean flag = false; while (true) { if (temp == null) { break; } if (temp.no == newHeroNode2.no) {// 找到  flag = true; break; } temp = temp.next; } //根据flag判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode2.name; temp.nickname = newHeroNode2.nickname; } else {//没有找到  System.out.printf(\"没有找到 编号%d的节点，不能修改\", newHeroNode2.no); } }   ④删除结点 从双向链表中删除一个结点，我们只需直接找到需要删除的结点，找到后，双链表可以实现自我删除。\n具体操作如下：定义一个辅助变量temp = head.next;这里我们直接找到该结点所在的位置，所以temp直接等于head.next;还需要一个flag标记是否找到待删除结点。通过遍历找到链表的最后，然后让temp的前驱结点的next域直接指向temp的下一个结点，即temp.pre.next = temp.next;如果待删除结点不是最后的结点，则还需要执行下列操作：让temp的下一个结点的pre指向temp的前一个结点，即temp.next.pre = temp.pre;完成上述操作之后，待删除结点的前后指针都指向null，也就完成了删除。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public void del(int no) { // 判断当前链表是否为空  if (head.next == null) {// 空链表  System.out.println(\"链表为空，无法删除~\"); return; } HeroNode2 temp = head.next; // 辅助变量(指针)  boolean flag = false; // 标志是否找到待删除节点的  while (true) { if (temp == null) { // 已经到链表的最后  break; } if (temp.no == no) { // 找到的待删除节点的前一个节点temp  flag = true; break; } temp = temp.next; // temp后移，遍历  } // 判断flag  if (flag) { // 找到  // 可以删除  temp.pre.next = temp.next; // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针  if (temp.next != null) { temp.next.pre = temp.pre; } } else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } }   ⑤输出链表信息 和单链表操作相同。。。。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 遍历打印输出链表信息  public void show() { // 先判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 因为头结点不能动，定义一个辅助变量用于遍历  HeroNode2 temp = head.next; while (true) { // 判断是否到链表最后  if (temp == null) { break; } // 输出结点信息  System.out.println(temp); temp = temp.next;// 将temp后移！！！  } }    三、结束语 到这里，我们完成了对于双链表的相关操作。双向链表相对于单链表来说，要更复杂一些，毕竟它多了pre指针，进行删除和操作的时候需要格外小心。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点操作带来了方便，可以有效提高算法的时间性能。说白了，就是用空间换时间。\n源代码——\u003e数据结构\n 《大话数据结构》 ——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构——双向链表","uri":"/tech/doublelinkedlist/"},{"categories":null,"content":"单链表的应用举例 一、前言 在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操作：\n 获取单链表的有效结点 查找单链表中的倒数第k个结点 逆序打印单链表（从尾到头打印） 反转单链表   二、算法介绍 1、获取单链表的有效结点 作为使用的第一个方法难度不是很大。因为需要求出单链表中有效结点的个数，所以我们可分为带头结点和不带头结点两种情况。\n我们这边考虑的是不带头结点的单链表，（如果是带头结点的链表需要再加上头结点即可）。需要的变量有length(统计链表的长度)和cur(辅助变量，用于遍历)，可以通过传入一个头结点，然后依次遍历该链表，当链表遍历到最后的时候，即cur.next == null，每一次遍历链表的长度加一，即length++。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // head链表的头结点，返回的就是有效结点的个数  public static int getLength(HeroNode head) { if (head.next == null) {// 链表为空  return 0; } int length = 0; HeroNode cur = head.next;// 定义一个辅助变量  while (cur != null) { length++; cur = cur.next; } return length; }   2、查找单链表中的倒数第k个结点 因为单链表是单向的，只能从头到尾开始遍历，而无法从后往前遍历，所以我们需要传入一个头结点head（遍历的起始位置）和index(倒数第k个结点)。\n定义一个size表示链表的长度，也就是链表有效结点的个数，可以通过方法一来获取。即size = getLength(head)，然后需要定义一个辅助变量用于遍历。然后通过for循环定位到倒数的index，即size - index的位置，也就是需要查找的倒数第k个结点。最后返回当前的辅助变量，完成查找。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static HeroNode findLastIndexNode(HeroNode head, int index) { // 判断链表是否为空，如果是则返回null  if (head.next == null) { return null;// 没有找到  } // 第一次遍历得到链表对的长度（结点个数）  int size = getLength(head); // 先做一个index校验  if (index \u003c 0 || index \u003e size) { return null; } // 定义一个辅助变量，for循环定位到倒数的index  HeroNode cur = head.next; // 第二次遍历 size - index位置，就是倒数的第k个结点  for (int i = 0; i \u003c size - index; i++) { cur = cur.next; } return cur; }   3、逆序打印单链表 在不改变链表结构的情况下，进行逆序打印，我们可以利用栈这个数据结构来实现。栈的特点就是先进后出。先把链表push压入栈中，再pop出栈即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public static void reversePrint(HeroNode head) { if (head.next == null) { return;// 空链表，不能打印  } // 创建一个栈，将各个结点压入栈  Stack\u003cHeroNode\u003e stack = new Stack\u003c\u003e(); HeroNode cur = head.next; // 将链表的所有结点压入到栈  while (cur != null) { stack.push(cur); cur = cur.next; } // 将栈中的结点进行打印，pop出栈  while (stack.size() \u003e 0) { System.out.println(stack.pop());// stack的特点就是先进后出  } }   4、反转单链表（有点难度） 对单链表进行反转，表示的意思是：将最后的结点变成最前端的结点，以此类推。所以我们需要分为两种情况：\n 当前链表为空，或者当前链表只有一个结点，无需反转，直接返回即可。 有多个结点时：  需要的变量有：cur(用于遍历原来的链表)，nextNode(指向当前结点[cur]的下一个结点)，reverseHead(结点，新链表的最前端)。\n具体操作过程如下：先将nexNodet指向cur的下一个结点，用于保存当前结点的下一个结点，然后将cur的下一个结点指向新链表的最前端，即cur.next = reverseHead.next,然后再将cur连接到新的链表上，这样才能形成一个完成的链表（一个回路）。然后后移，遍历下一个结点，即cur = nextNode;在进行上述操作之后，我们已经将链表的所有结点取出，并存放在新的链表下，这时我们需要将head.next 指向 reverseHead.next，实现单链表的反转，即 head.next = reverseHead.next; 完成单链表的反转。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void reverseList(HeroNode head) { // 如果当前链表为空，或者只有一个结点，无需反转，直接返回  if (head.next == null || head.next.next == null) { return; } HeroNode cur = head.next;// 定义一个辅助变量，帮助遍历原来的链表  HeroNode nextNode = null;// 指向当前结点[cur]的下一个结点  HeroNode reverseHead = new HeroNode(0, \"\", \"\"); // 遍历原来的链表，每遍历一个结点，将其取出，并放在新的链表reverseHead的最前端  while (cur != null) { nextNode = cur.next;// 先暂时保存当前结点的下一个结点，  cur.next = reverseHead.next;;// 将cur的下一个结点指向新的链表的最前端  reverseHead.next = cur;// 将cur连接到新的链表上  cur = nextNode;// 让cur后移  } // 将 head.next 指向 reverseHead.next，实现单链表的反转  head.next = reverseHead.next; }    三、结束语 其实我们不难发现，数组也好，链表也罢，都只是存储信息的不同方式，最重要的还是对其的理解和使用，只有这样才能更好的掌握。对于一个刚接触数据结构的小白来说，学到这里的时候，信息量已经远远超过之前所学的知识，但并不应该气馁，数据结构多而且难，所以更需要我们耐下性子，去慢慢琢磨、回顾，愿成长路上，与君共勉！\n源码地址——\u003e数据结构\n","description":"","tags":null,"title":"单链表的使用","uri":"/tech/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"单向链表 一、基本介绍 1、相关定义 链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的，且链表的长度不是固定的。链表的每个元素称为一个结点，每个结点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑关系，以便构成“一个结点链着一个结点”的链式存储结构，为了保持每个结点之间的链接，所以链表除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个结点都包含两个部分，第一部分用于存储元素本身的数据信息，称为数据域，它不局限于一个成员数据，也可是多个成员数据；第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的结点信息，这里用next表示，next的值实际上就是下一个结点的地址，当前结点为末结点时，next的值设为空指针，即为null。链表在使用过程中，可以根据实际需求来判断是否需要添加头结点。\n2、链表与数组比较 数组（包括结构体数组）的实质是一种线性表的顺序表示方式，它的优点是使用直观，便于快速、随机地存取线性表中的任一元素，但缺点是对其进行插入和删除操作时需要移动大量的数组元素，同时由于数组属于静态内存分配，定义数组时必须指定数组的长度，程序一旦运行，其长度就不能再改变，实际使用个数不能超过数组元素最大长度的限制，否则就会发生下标越界的错误，低于最大长度时又会造成系统资源的浪费，因此空间效率差。\n 二、算法实现 我们需要定义一个类用来存放结点信息，同时也还需要定义一个类用于管理结点，实现单链表的增删改查。\n1、定义一个HeroNode类表示结点 我们需要在HeroNode类中实现相关变量的定义、赋值以及显示信息的方法。\n① 相关变量 这里我们使用单链表来存储水浒英雄，需要存储的信息有：编号、姓名和昵称。还需要定义一个next域用于指向下一个结点。\n代码实现如下：\n1 2 3 4  public int no;// 编号  public String name;// 姓名  public String nickname;// 昵称  public HeroNode next;// next域，指向下一个节点   ②构造器 可以利用构造器对相关变量进行赋值。\n代买实现如下：\n1 2 3 4 5  public HeroNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 我们可以使用toString方法来显示链表的信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 利用toString显示信息  @Override public String toString() { return \"HeroNode{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }   2、定义一个SingleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  //先初始化一个头节点，头节点不要动，不存放具体的数据  private HeroNode head = new HeroNode(0, \"\", \"\");   ①直接添加数据到单链表 直接添加数据到队列尾，即不考虑编号按照添加顺序，入链表。因为头结点不能动，所以需要定义一个临时变量temp用于遍历。通过后移temp实现遍历，temp = temp.next 。遍历的目的在于，找到当前链表最后的结点，然后将最后这个结点的next指向新的结点，便完成了添加的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public void add(HeroNode heroNode) { //因为head节点不能动，因此我们需要一个辅助变量temp  HeroNode temp = head; //遍历链表，找到最后  while (true) { //找到链表的最后  if (temp.next == null) { break; } //如果没有找到最后，将temp后移  temp = temp.next; } //当退出while循环时，temp指向了链表的最后  //将最后这个节点的next指向新的节点  temp.next = heroNode; }   ②根据编号添加结点 这次我们使用按照编号顺序添加结点，如果该编号已经存在，则添加失败，并给出提示。按照编号添加结点，使用的方法是通过 后移temp 遍历，找到该编号的前一个结点，然后让需要添加的结点先指向前一个结点的下一个结点，然后再让前一个结点指向需要添加的结点。所以需要一个flag变量来标记是否找到当前结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public void addByOrder(HeroNode heroNode) { //因为头节点不能动，因此仍然需要通过一个辅助指针（变量）来帮助找到添加的位置  //因此我们找的temp是位于添加位置的前一个节点，否则插入不了  HeroNode temp = head; boolean flag = false;//标志添加的编号是否存在，默认为false  while (true) { if (temp.next == null) {//说明temp已经在链表的最后  break; } if (temp.next.no \u003e= heroNode.no) {//位置找到，就在temp的后面插入  break; } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode编号已经存在  flag = true;//说明编号存在  break; } temp = temp.next;//后移，遍历当前链表  } //判断flag的值  if (flag) {//不能添加，说明编号已经存在  System.out.printf(\"准备插入的英雄编号%d已经存在，添加失败\\n\", heroNode.no); } else { //插入到链表中，temp的后面  heroNode.next = temp.next; temp.next = heroNode; } }   ③修改结点信息 这里我们通过根据编号来修改结点信息，即编号不能改。同时需要传入一个新的结点 newHeroNode ，用于存储修改结点的信息。在进行修改之前，需要先判断单链表是否为空，head.next == null 链表为空。然后定义一个辅助变量temp和flag分别用于遍历和标记是否找到当前结点。如果 temp.no == newHeroNode.no 表示找到当前需要修改的结点。赋予新的name和nickname完成修改结点的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //1、根据newHeroNode的no来修改即可  public void update(HeroNode newHeroNode) { //判断是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //2、找到需要修改的节点，根据num编号修改  HeroNode temp = head.next;//定义一个辅助变量  boolean flag = false;//表示是否找到该节点  while (true) { if (temp == null) { break;//已经遍历结束  } if (temp.no == newHeroNode.no) {//找到  flag = true; break; } temp = temp.next; } //3、根据flag，判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; } else {//没有找到  System.out.printf(\"没有找到编号%d的节点，不能修改\\n\", newHeroNode.no); } }   ④删除结点 在进行删除结点的操作的时候，我们仍然根据编号来进行寻找需要删除的结点。找到需要删除结点的前一个结点，让前一个结点的next跨过需要删除的结点，直接指向下一个结点，即 temp.netx = temp.next.next ，完成删除。在进行删除之前仍然需要定义temp和flag用于遍历和标记是否找到需要删除结点的前一个结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public void del(int no) { HeroNode temp = head; boolean flag = false;//标志是否找到待删除节点  while (true) { if (temp.next == null) { break;//已经到链表的最后  } if (temp.next.no == no) {//找到待删除节点的前一个节点temp  flag = true; break; } temp = temp.next;//temp后移，遍历  } //判断flag  if (flag) {//找到  //可以删除  temp.next = temp.next.next; } else { System.out.printf(\"需要删除的%d节点不存在\\n\", no); } }   ⑤显示链表信息 在显示链表信息之前，需要先判断链表是否为空，并给出相关信息。通过后移临时变量temp完成遍历。先输出结点信息，每当输出一个结点信息，就需要后移一次。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //显示链表，遍历  public void show() { //判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //因为头节点不能动，因此我们需要一个辅助变量来遍历  HeroNode temp = head.next; while (temp != null) {// 判断是否到链表最后  //输出节点的信息  System.out.println(temp); //将temp后移  temp = temp.next; } }    三、结束语 到此，我们了解了有关单链表的相关操作。在算法实现过程中，可能不少小朋友会发现一些问题，比如为什么有时候临时变量 temp = head.next ， 而有时却变成了temp = head 了呢？？其实仔细阅读一遍代码，我们不难发现，当进行增删操作的时候，temp = head ，那是因为需要增删的结点刚好是直接添加到头结点之后的，如果变成了 head.next ， 则会造成覆盖结点的情况；而在进行修改和遍历的时候，临时变量 temp = head.next ，那是因为我们这里定义头结点为空，不存放任何数据，所以修改和遍历的时候，需要从真正的有效结点开始。\n源码已经push到 ——\u003e数据结构\n","description":"","tags":null,"title":"数据结构--单向链表","uri":"/tech/singlelinkedlist/"},{"categories":null,"content":"数组模拟环形队列  一、前言 在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。\n 二、算法实现 1、初始化相关变量 需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对front和rear做以下调整：front由原来指向队列的前一个位置，改变为队列的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；rear从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为maxSize - 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  private int maxSize;// 表示数组的最大容量  private int front;// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素  private int rear;// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0  private int[] arr;// 该数组用于存放数据，模拟队列  // 构造器  public CircleArray(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = 0; rear = 0; }   2、判断队列是否为满 我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针下一个位置是头指针的时候，表示队列满。（在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 (rear + 1) % maxSize == front 。( 这里取模的目的就是为了整合rear和front大小为一个问题 )\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return (rear + 1) % maxSize == front; }   3、判断队列是否为空 因为front和rear的初始值相同，所以判断队列空的方法与之前一样。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return rear == front; }   4、求出当前队列的有效数据个数 这个方法与之前相比是新添加的，其目的是为了判断遍历队列的长度。队列的有效数据的个数 = 尾队列 - 头队列，但有时front比rear大，有时front比rear小，所以可以通过取模的方式来实现。\n代码实现如下：\n1 2 3 4  // 求出当前队列的有效数据的个数  public int size() { return (rear + maxSize - front) % maxSize; }   5、入队列 添加数据入队的操作和之前相类似，只不过该队列front指向队列的第一个元素的位置，所以需要进行先赋值，然后再后移。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 添加数据入队列  public void addQueue(int n) { if (isFull()) { System.out.println(\"该队列已满，，无法添加任何数据~\"); return; } arr[rear] = n;// 直接将数据加入  rear = (rear + 1) % maxSize;// 将rear后移，这里必须考虑取模  }   6、出队列 之前由于头指针指向队列的前一个位置，所以先后移，到达需要取出数据的位置，从而返回即可 。但此时头指针所在的位置就是需要取出的位置，如果直接返回则无法进行后移，如果先后移，则取出的数据就是下一个位置的数据。我们可以做一下处理，从而达到想要的效果：\n 先把front对应的值保留到一个临时变量； 将front后移，考虑取模 将临时保存的变量返回  代码实现如下：\n1 2 3 4 5 6 7 8 9  // 从队列中取出数据  public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无任何数据可以取出~\"); } int val = arr[front]; front = (front + 1) % maxSize; return val; }   7、显示队列的所有数据 在遍历的时候，我们需要注意到因为是环形队列，需要从front开始遍历，遍历到什么位置结束呢？？ 在之前我们已经求出了有效数据的个数，所以遍历元素为 front + size()。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 显示队列的所有数据  public void show() { if (isEmpty()) { System.out.println(\"该队列为空，无任何数据可以显示~\"); return; } // 遍历时，从front开始遍历，遍历元素为 front+有效数据的个数  for (int i = front; i \u003c front + size(); i++) { System.out.printf(\"arr[%d]=%d\\n\", i % maxSize, arr[i % maxSize]); } }   8、显示队列的头数据 因为front指向的队列的一个元素的位置，所以直接返回即可。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示队列的头数据  public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无头数据可显示~\"); } return arr[front]; }    三、结束语 到此，我们了解了关于数组模拟循环队列的相关操作，在判断队列是为满的时候，可以尝试画图理解，（记住要队列要空出一个位置，留作约定哦！）还有一个难点，求出有效数据个数。其余方法，根据数组模拟队列做出相应的调整即可（由于front和rear指向的位置不同而做出的改变）。\n源码地址 ——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构--数组模拟环形队列","uri":"/tech/circlearrayqueue/"},{"categories":null,"content":"数组模拟队列  一、基本介绍 1、队列介绍：   队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用数组或是链表来实现。\n  遵循先入先出的原则，允许插入的一端称为队尾，允许删除的一端称队头。\n  2、举例说明： 队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是先入先出的原则。\n二、算法实现 1、所需元素及其方法 在实现数组模拟队列的时候，我们需要先定义一个ArrayQueue类来存放所需的元素以及相关方法，所需元素有：数组arr[]：用于存放数据，模拟队列；数组的最大容量maxSize；队列头front；以及队列尾rear。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。\n代码实现如下：\n1 2 3 4  private int maxSize;// 表示数组的最大容量  private int front;// 队列头  private int rear;// 队列尾  private int[] arr;// 该数组用于存放数据，模拟队列   2、初始化相关变量 在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量maxSize，这时数组可以存放maxSize的数据，但数组下标的范围为arr[0]--arr[maxSize - 1]。为front和rear赋值为-1，即队列的前一个位置。\n代码实现如下：\n1 2 3 4 5 6 7  // 创建队列的构造器  public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1;// 指向队列头部，front是指向队列头的前一个位置  rear = -1;// 指向队列的尾部，rear是队列最后一个数据  }   3、判断队列是否为满 ​\t在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在不断变大。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即rear == arr[maxSize - 1]。\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return rear == maxSize - 1; }   4、判断队列是否为空 ​\t在初始状态下，front和rear均指向下标为-1的同一个位置，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向同一个下标的时候，表示所有数据已经全部出队列。所以当rear == front时，队列空。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return front == rear; }   5、添加数据到队列 在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 添加数据到队列  public void addQueue(int n) { // 首先判断队列是否为满  if (isFull()) { System.out.println(\"该队列已满，无法添加任何数据~\"); return; } rear++;// 让rear后移  arr[rear] = n; }   6、取出队列的数据 在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 获取队列的数据，出队列  public int getQueue() { // 首先判断队列是否为空  if (isEmpty()) {// 这里可以通过抛出异常处理  throw new RuntimeException(\"该队列为空，无法取出任何数据\"); } front++;// 让front后移  return arr[front]; }   7、显示队列所有数据 我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。注意在执行出队列的操作之后，front的值也随之后移，而且front指向的位置为队列的前一个位置，所以遍历的起始位置应该为front + 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示队列所有数据  public void showQueue() { // 先判断是否为空  if (isEmpty()) { System.out.println(\"该队列为空，无数据可显示~\"); return; } // 遍历  for (int i = front + 1; i \u003c arr.length; i++) { System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); } }   8、显示队列头的信息 需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要front + 1。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示头队列的信息，注意不是取出数据  public int headQueue() { // 先判断是否为空  if (isEmpty()) { throw new RuntimeException(\"队列为空，无数据可显示\"); } return arr[front + 1]; }   三、结束语 至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——\u003e 数据结构。\n 《大话数据结构》——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构--数组模拟队列","uri":"/tech/arrayqueue/"},{"categories":null,"content":"稀疏数组  一、基本介绍 1、实际需求 假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：\n0 0 0 2 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用稀疏数组来保存该数组。\n2、相关概念 基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：\n   行 列 值     A B C   E F G     A：表示总行数 B：表示总列数 C：表示真正有效数值的个数（除0外的数值） E：表示该元素所在的行 F：表示该元素所在的列 G：表示该元素的数值  所以上述原始的二维数组转化成稀疏数组，应该如下：\n   row col value     10 10 4   0 3 2   1 3 1   1 4 2   2 2 1    ​\n 二、算法实现 1、创建并输出原始二维数组 ①创建原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  // 0表示没有棋子，1表示黑子，2表示白子  int chessArr1[][] = new int[10][10];// 创建一个原始的二维数组 10*10  chessArr1[1][3] = 1; chessArr1[1][4] = 2; chessArr1[2][3] = 1; chessArr1[0][3] = 2;\t  ②打印输出原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr1) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); }   2、将二维数组转换成稀疏数组 ①先遍历二维数组，记录非0数值的个数 ​\t遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8  int sum = 0;// 用于记录非0数值的个数  for (int i = 0; i \u003c chessArr1.length; i++) { for (int j = 0; j \u003c chessArr1.length; j++) { if (chessArr1[i][j] != 0) { sum++; } } }   ②创建对应的二维数组 ​\t在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。\n代码实现如下：\n1 2 3 4 5  int sparseArr[][] = new int[sum + 1][3]; // 给稀疏数组赋值  sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = sum;   ③遍历二维数组，将非0的值存放到 sparseArr 中 ​\t在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int count = 0;// count用于记录是第几个非0数据  for (int i = 0; i \u003c sparseArr.length; i++) { for (int j = 0; j \u003c sparseArr.length; j++) { if (chessArr1[i][j] != 0) { count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } } }   ④打印输出稀疏数组 代码实现如下：\n1 2 3  for (int i = 0; i \u003c sparseArr.length; i++) { System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); }   3、将稀疏数组恢复成原始的二维数组 ①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 ​\t将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小\n代码实现如下：\n1  int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];   ②再读取稀疏数组后后几行的数据 （从第二行开始！！！） ​\t因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i = 1; 读取所有非0数据即可，其余的位置，默认值为0。\n代码实现如下：\n1 2 3  for (int i = 1; i \u003c sparseArr.length; i++) { chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; }   ③输出恢复后的二维数组 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr2) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); }    三、结束语： ​\t第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！\n​\t源码我已push到我的Github仓库，数据结构，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！\n","description":"","tags":null,"title":"数据结构--稀疏数组","uri":"/tech/sparsearray/"},{"categories":null,"content":"前言 大政的Blog就这样稀里糊涂的开通了。\n 有时候闲着无聊，总想着写点什么，可能是乱七八糟的想法，可能是一段书评，也有可能是一段歌词。因为相对于话语的直白，文字能表达的情感是更加细腻的，它也可以将有些事情一直保存下去。\n也有可能是我天生就有点内向，甚至比较丧，不太喜欢说话。\n 当时之所以想开通Blog最主要是想督促自己保持学习的习惯，并且可以在这里记录一些关于学习的笔记。也有一部分原因是在这段时间接触了许多之前没有接触过的人和事，总想着这些美好的事和可爱的人更应该被文字所记录，而不是埋藏在我的心里。\n所以博客的内容可能是一串代码，一行文字，一条书评，一段歌词，或许是一句心里话。\n我既做不上神明，那当个野兽也好。\n","description":"","tags":null,"title":"Hello World ! Hello Blog !","uri":"/life/hello/"}]
