[{"categories":null,"content":"数组模拟栈 一、基本介绍 1、相关定义  栈是一个==先入后出==的有序列表； 栈是限制线性表中元素的插入和删除只能在线性表的同一段进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top）,另一端为固定的一端，称为栈底（Bottom）； 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先删除的元素最后删除。  2、应用场景  子程序的调用：在跳往子程序前，会先将下个指令的地址存放到堆中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数、区域变量等数据存入到堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。 二叉树的遍历。 图形的深度优先（depth - first）搜索法。   二、算法实现 需要构建一个ArrayStack类，用于表示栈。\n1、定义相关变量以及赋值 需要定义的相关变量有：定义一个数组模拟栈int[] stack、栈的大小maxSize以及栈顶元素top。（在这里我们把栈顶元素top的初始值为-1，有利于后期存入和删除数据）。\n定义完相关变量之后，我们可以利用构造器对maxSize和stack数组进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  private int maxSize;// 栈的大小  private int[] stack;// 数组，数组模拟栈，数据就在该数组  private int top = -1;// top表示栈顶，初始化为-1  // 构造器  public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; }   2、判断栈是否为满 因为数组的下标是从0开始的，所以当栈满时，栈顶元素的下标为stack[top] = maxSize - 1;所以当 top == maxSize - 1时，栈满。\n代码实现如下：\n1 2 3 4  // 栈满  public boolean isFull() { return top == maxSize - 1; }   3、判断栈是否为空 之前在定义相关变量的时候，我们提到top的初始值为-1，即当 top == -1时，栈中没有存入任何数据，为空。\n代码实现如下：\n1 2 3 4  // 栈空  public boolean isEmpty() { return top == -1; }   4、入栈——push 方法 在入栈之前，我们首先需要判断栈是否已满，如果栈满则给出提示，并结束程序。否则执行以下操作：由于top的初始值为-1，即数组第一个元素的前一个位置，因此需要先移动top到指定位置，然后给其赋值即可。（先后移再赋值）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 入栈——push  public void push(int value) { // 先判断栈是否未满  if (isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; }   5、出栈——pop 方法 在进行出栈操作之前，我们首先需要判断栈是否为空，如果为空，则给出相关提示（这里我们是用抛出异常的方式来进行处理）；否则，执行以下操作：先定义一个临时变量value来存储栈顶元素，然后栈顶元素top--，往前移动，最后返回临时变量即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 出栈——pop  public int pop() { if (isEmpty()) { throw new RuntimeException(\"栈空，没有数据~~~\"); } int value = stack[top]; top--; return value; }   6、打印输出栈的信息 如果栈为空，则没有任何数据可以显示，所以在输出栈的信息之前，我们需要先判断栈是否为空。在遍历的时候，我们需要从栈顶开始显示数据。可以通过for循环l来实现。\n因为是从栈顶开始显示数据，所以循环的起始位置应该为栈顶top，循环结束的条件应该为i \u003c 0，每执行一次循环，则需要i--。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 遍历栈，遍历时，需要从栈顶开始显示数据  public void show() { if (isEmpty()) { System.out.println(\"栈空，没事有数据~~~\"); return; } // 需要从栈顶开始显示数据  for (int i = top; i \u003e= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } }    三、结束语 这里我们使用的是数组模拟栈的操作，所以说对应的也可以利用链表来模拟栈，小伙伴们可以自己先尝试一下噢。\n在写代码的时候，因为是利用数组模拟栈的相关操作，不由的想起之前写过的数组模拟单向队列，两者可以进行比较的学习，可以思考一下，同样是没有取模的操作，为什么单向队列不能够进行复用，而栈却可以呢？？\n源码地址——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——数组模拟栈","uri":"/tech/arraystackdemo/"},{"categories":null,"content":"两年前的这个时候，高考也已经告一段落。一直以来，都太强调学习，满脑子里想的都是”知识改变命运“这种空而大的口号。其实这一点，直到今天，还依然未变。要不看了这么多年的书，岂不是白看了嘛？？哈哈哈哈哈……\n在高三的时候，总想着，只要再努力一点，再多背一个单词，多做一道题目，就离考了大学更进一步，但其实不然。当拿到报考指南的那一刻，还是傻眼了。似乎有一种无力感，高考查完分之后的那种兴奋再也找不到了，就在想：当时熬的夜，还值得吗？？都说付出就会有回报，但结果呢？？这大概就是灰色而幽默的现实，当头一棒，给我敲醒。我只是个蝼蚁，还有很长的路要走！！\n在大一的时候，大部分的同学的共同语言，还是关于“高三”。似乎，之前的所有经历和高三相比都不值一提，还是当时眼界太低，能看见的只有高考呢？？上了大学，懵懵懂懂，总想着，摆脱了高中的条条框框的拘束，也有个平台可以展示自己了。其实现在反过来，想想当时自己为什么要加哪些组织、社团呢？？是真的喜欢吗？？还是单纯的为了学分呢？？还是利益相关呢？？大一刚入学的时候，感觉那些当着学生组织负责人的学长学姐好了不起，如果自己到了那个时候，会变得和他们一样优秀吗？？大一，也许在悔恨高中为什么不努力好好学习，也许是刚刚告别高三，还把看书、刷题当做一种习惯，但慢慢的，随着时间的推移，当时的屠龙少年，现在也变成了一条恶龙。（前段时间在整理书柜的时候，发现了大一时候学高数，演算的稿纸，还真的挺佩服那时候的自己）\n到了大二，渐渐的在学校里有了自己的圈子，创立了自己的社团，原以为会变成自己想要的样子，迎来的却是各种毒打，其实也算不上毒打，准确来说是劝退。当热情被慢慢消磨殆尽，坚持下来的可能就是责任了吧。那如果连责任心都没了呢？？我还有什么坚持下去的理由呢？？\n到现在，回过头来，看看高三时候的自己，可能会对他说：把一切都看淡一点，没什么大不了的。是的，没什么大不了的。说句鸡汤的话：只要你努力，总不会变得太差劲。\n 其实这篇文章，在好久之前就想写，但一直找不到带入点，也不知该如何去说起。可能是最近的烦心事多了，又变得消极了点，心里有情绪，总归要抒发出来的嘛。\n","description":"","tags":null,"title":"写个两年前的自己","uri":"/life/%E5%86%99%E4%B8%AA%E4%B8%A4%E5%B9%B4%E5%89%8D%E7%9A%84%E8%87%AA%E5%B7%B1/"},{"categories":null,"content":"环形链表  一、基本介绍 1、问题来历 据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。\n2、问题简化 在了解了约瑟夫环的来历之后，我们对该问题进行以下简化。其实我们联系一下，将会发现约瑟夫环是不是和我们小时候玩的丢手帕有些类似呢？\n那么我们首先假设有五个小孩围城一个圈，然后从第一个小孩开始报数，每次数到2，则这个小孩出圈，以此类推，通过简单地推理我们可以得出，出队列的顺序是：2—\u003e4—\u003e1—\u003e5—\u003e3.\n在了解了有关约瑟夫环的介绍之后，我们可以使用单向环形链表来对它进行相关操作。这里我们使用的是没有头结点的链表。\n 二、算法描述 1、定义结点 定义一个结点，存放小孩的编号。在之前介绍链表的时候，我们定义变量的属性都是共有的，这里我们尝试一下私有的，因此需要使用到get和set方法，来进行赋值和获取相关变量。同时，还需要一个构造器，分别用于传入结点的编号。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 创建一个Boy类，表示一个结点 class Boy { private int no;// 编号  private Boy next;// 指向下一个结点，默认为null  // 构造器  public Boy(int no) { this.no = no; } public int getNo() { return no; } public Boy getNext() { return next; } public void setNo(int no) { this.no = no; } public void setNext(Boy next) { this.next = next; } }   2、定义一个类用于管理结点 首先需要创建一个first结点，不存放任何数据，也就是当前没有编号的结点。\n代码实现如下：\n1 2  // 创建一个first结点，当前没有编号  private Boy first = null;   ①添加结点入链表 首先传入一个nums表示需要添加结点的个数。在进行添加之前，还需要判断传入的nums是否符合要求。然后定义一个curBoy辅助指针，帮助构建环形链表。\n我们通过for循环创建结点，先创建第一个结点，让first结点指向该结点，然后first的next域指向自己，构成一个环，最后再让辅助指针curBoy指向first，即完成第一个结点的添加操作；添加其它结点的方法如下：先让curBoy的下一个结点指向需要添加的结点（通过setNext方法），然后再让该结点的next域指向first结点，形成环，最后使curBoy指向当前添加的结点（为了方便下一次添加结点），从而完成添加结点的相关操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 添加小孩结点，构建一个环形的链表，nums表示需要添加结点的个数  public void addBoy(int nums) { if (nums \u003c 1) {//检验  System.out.println(\"nums的值不正确\"); return; } Boy curBoy = null;// 辅助指针，帮助构建环形链表  // 使用for循环俩创建环形链表  for (int i = 1; i \u003c= nums; i++) { // 根据编号，创建小孩结点  Boy boy = new Boy(i); // 如果是第一个小孩  if (i == 1) { first = boy; first.setNext(first);// 构成环  curBoy = first; } else { curBoy.setNext(boy); boy.setNext(first); curBoy = boy; } } }   ②遍历输出环形链表 首先判断链表是否为空，即if(first == null)，如果为空则给出提示；不为空则执行以下操作：因为first结点不能动，因此需要一个辅助变量用于完成遍历，即 Boy curBoy = first，然后我们使用while来进行循环遍历。通过getNext方法实现后移，如果curBoy的下一个结点为first则遍历结束，退出循环。完成链表的遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 遍历当前的环形链表  public void showBoy() { // 判断链表是否为空  if (first == null) { System.out.println(\"该环形链表为空~\"); return; } // 因为first不能动，因此需要一个辅助指针完成遍历  Boy curBoy = first; while (true) { System.out.printf(\"小孩的编号%d\\n\", curBoy.getNo()); if (curBoy.getNext() == first) {// 说明已经遍历完毕  break; } curBoy = curBoy.getNext();// curBoy后移  } }   ③完成结点出链表 我们需要传入几个参数，startNo表设从第几个结点开始报数，countNum表示需要数几下，nums表示圈中有多少个小孩。\n首先需要对数据进行一个校验，即判断环形链表是否为空，开始报数的位置不能低于1，也不能大于圈中的结点。\n代码实现如下：\n1 2 3 4  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; }   然后需要创建一个辅助指针helper，帮助完成小孩出圈。接下来我们需要将helper先指向链表的最后这个结点，即helper的下一个结点就是first结点。紧接着通过while循环，我们再将first和helper指针同时移动countNum - 1次，到达需要出圈结点的位置。\n最后也是最关键的一步，完成小孩结点出圈。先让first结点指向它的下一个结点，即first = first.getNext();，然后再将helper的下一个结点设置为当前first所指向的结点，即helper = helper.setNext(first);，这样first原来所指向的结点没有任何引用，就会被回收。\n如果helper == first,则说明圈中只有一个结点。输出这个结点的信息，就完成了出圈的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /** * 根据用户的输入，计算出小孩出圈的顺序 * * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少个小孩在圈中 */ public void countNum(int startNo, int countNum, int nums) { // 先对数据进行校验  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; } // 创建一个辅助指针，帮组完成小孩出圈  Boy helper = first; //需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这结点  while (true) { if (helper.getNext() == first) {// 说明helper指向最后小孩结点  break; } helper = helper.getNext(); } // 当小孩报数前，先让first和helper指针同时移动 startNo - 1 次，到达需要报数的位置  for (int j = 0; j \u003c startNo - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 当小孩报数时，让first和helper指针同时移动countNum - 1次，然后出圈  // 这里使用循环操作，直到圈中只有一个结点  while (true) { if (helper == first) {// 说明圈中只有一个结点  break; } // 让first和helper指针同时移动countNum - 1次  for (int j = 0; j \u003c countNum - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 这时first指向的结点，就是要出圈的小孩结点  System.out.printf(\"小孩%d出圈\\n\",first.getNo()); first = first.getNext(); helper.setNext(first); } System.out.printf(\"最后留在圈中的小孩编号%d\\n\",first.getNo()); }    三、结束语 在此，更新了环形链表，关于链表的所有基础知识也就要告一段落咯。谈谈我一开始学习链表的感觉吧，从一个小白，刚开始接触数据结构，就被其中各种复杂的结构所惊讶到。特别在学习到链表的时候，更加感觉到举步维艰，似乎很玄学，说不懂，但其实还是有一点点明白大概的结构。但是距离能够独立写出一个链表的结构还有很长一段路要走。因此我查阅了一些相关博客，只看代码和文字描述，总感觉少了点什么，写得再好的代码和文字，倒不如一张图来得实在，所以在学习的时候，我建议可以结合画图来实际操作，这样更方便理解，还有利于记忆。\n环形链表源码—\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——约瑟夫环","uri":"/posts/circlelinkedlistdemo/"},{"categories":null,"content":"环形链表  一、基本介绍 1、问题来历 据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。\n2、问题简化 在了解了约瑟夫环的来历之后，我们对该问题进行以下简化。其实我们联系一下，将会发现约瑟夫环是不是和我们小时候玩的丢手帕有些类似呢？\n那么我们首先假设有五个小孩围城一个圈，然后从第一个小孩开始报数，每次数到2，则这个小孩出圈，以此类推，通过简单地推理我们可以得出，出队列的顺序是：2—\u003e4—\u003e1—\u003e5—\u003e3.\n在了解了有关约瑟夫环的介绍之后，我们可以使用单向环形链表来对它进行相关操作。这里我们使用的是没有头结点的链表。\n 二、算法描述 1、定义结点 定义一个结点，存放小孩的编号。在之前介绍链表的时候，我们定义变量的属性都是共有的，这里我们尝试一下私有的，因此需要使用到get和set方法，来进行赋值和获取相关变量。同时，还需要一个构造器，分别用于传入结点的编号。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 创建一个Boy类，表示一个结点 class Boy { private int no;// 编号  private Boy next;// 指向下一个结点，默认为null  // 构造器  public Boy(int no) { this.no = no; } public int getNo() { return no; } public Boy getNext() { return next; } public void setNo(int no) { this.no = no; } public void setNext(Boy next) { this.next = next; } }   2、定义一个类用于管理结点 首先需要创建一个first结点，不存放任何数据，也就是当前没有编号的结点。\n代码实现如下：\n1 2  // 创建一个first结点，当前没有编号  private Boy first = null;   ①添加结点入链表 首先传入一个nums表示需要添加结点的个数。在进行添加之前，还需要判断传入的nums是否符合要求。然后定义一个curBoy辅助指针，帮助构建环形链表。\n我们通过for循环创建结点，先创建第一个结点，让first结点指向该结点，然后first的next域指向自己，构成一个环，最后再让辅助指针curBoy指向first，即完成第一个结点的添加操作；添加其它结点的方法如下：先让curBoy的下一个结点指向需要添加的结点（通过setNext方法），然后再让该结点的next域指向first结点，形成环，最后使curBoy指向当前添加的结点（为了方便下一次添加结点），从而完成添加结点的相关操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 添加小孩结点，构建一个环形的链表，nums表示需要添加结点的个数  public void addBoy(int nums) { if (nums \u003c 1) {//检验  System.out.println(\"nums的值不正确\"); return; } Boy curBoy = null;// 辅助指针，帮助构建环形链表  // 使用for循环俩创建环形链表  for (int i = 1; i \u003c= nums; i++) { // 根据编号，创建小孩结点  Boy boy = new Boy(i); // 如果是第一个小孩  if (i == 1) { first = boy; first.setNext(first);// 构成环  curBoy = first; } else { curBoy.setNext(boy); boy.setNext(first); curBoy = boy; } } }   ②遍历输出环形链表 首先判断链表是否为空，即if(first == null)，如果为空则给出提示；不为空则执行以下操作：因为first结点不能动，因此需要一个辅助变量用于完成遍历，即 Boy curBoy = first，然后我们使用while来进行循环遍历。通过getNext方法实现后移，如果curBoy的下一个结点为first则遍历结束，退出循环。完成链表的遍历。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 遍历当前的环形链表  public void showBoy() { // 判断链表是否为空  if (first == null) { System.out.println(\"该环形链表为空~\"); return; } // 因为first不能动，因此需要一个辅助指针完成遍历  Boy curBoy = first; while (true) { System.out.printf(\"小孩的编号%d\\n\", curBoy.getNo()); if (curBoy.getNext() == first) {// 说明已经遍历完毕  break; } curBoy = curBoy.getNext();// curBoy后移  } }   ③完成结点出链表 我们需要传入几个参数，startNo表设从第几个结点开始报数，countNum表示需要数几下，nums表示圈中有多少个小孩。\n首先需要对数据进行一个校验，即判断环形链表是否为空，开始报数的位置不能低于1，也不能大于圈中的结点。\n代码实现如下：\n1 2 3 4  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; }   然后需要创建一个辅助指针helper，帮助完成小孩出圈。接下来我们需要将helper先指向链表的最后这个结点，即helper的下一个结点就是first结点。紧接着通过while循环，我们再将first和helper指针同时移动countNum - 1次，到达需要出圈结点的位置。\n最后也是最关键的一步，完成小孩结点出圈。先让first结点指向它的下一个结点，即first = first.getNext();，然后再将helper的下一个结点设置为当前first所指向的结点，即helper = helper.setNext(first);，这样first原来所指向的结点没有任何引用，就会被回收。\n如果helper == first,则说明圈中只有一个结点。输出这个结点的信息，就完成了出圈的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /** * 根据用户的输入，计算出小孩出圈的顺序 * * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少个小孩在圈中 */ public void countNum(int startNo, int countNum, int nums) { // 先对数据进行校验  if (first == null || startNo \u003c 1 || startNo \u003e nums) { System.out.println(\"参数输入有误，请重新输入~\"); return; } // 创建一个辅助指针，帮组完成小孩出圈  Boy helper = first; //需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这结点  while (true) { if (helper.getNext() == first) {// 说明helper指向最后小孩结点  break; } helper = helper.getNext(); } // 当小孩报数前，先让first和helper指针同时移动 startNo - 1 次，到达需要报数的位置  for (int j = 0; j \u003c startNo - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 当小孩报数时，让first和helper指针同时移动countNum - 1次，然后出圈  // 这里使用循环操作，直到圈中只有一个结点  while (true) { if (helper == first) {// 说明圈中只有一个结点  break; } // 让first和helper指针同时移动countNum - 1次  for (int j = 0; j \u003c countNum - 1; j++) { first = first.getNext(); helper = helper.getNext(); } // 这时first指向的结点，就是要出圈的小孩结点  System.out.printf(\"小孩%d出圈\\n\",first.getNo()); first = first.getNext(); helper.setNext(first); } System.out.printf(\"最后留在圈中的小孩编号%d\\n\",first.getNo()); }    三、结束语 在此，更新了环形链表，关于链表的所有基础知识也就要告一段落咯。谈谈我一开始学习链表的感觉吧，从一个小白，刚开始接触数据结构，就被其中各种复杂的结构所惊讶到。特别在学习到链表的时候，更加感觉到举步维艰，似乎很玄学，说不懂，但其实还是有一点点明白大概的结构。但是距离能够独立写出一个链表的结构还有很长一段路要走。因此我查阅了一些相关博客，只看代码和文字描述，总感觉少了点什么，写得再好的代码和文字，倒不如一张图来得实在，所以在学习的时候，我建议可以结合画图来实际操作，这样更方便理解，还有利于记忆。\n环形链表源码—\u003e 数据结构\n","description":"","tags":null,"title":"数据结构——约瑟夫环","uri":"/tech/circlelinkedlistdemo/"},{"categories":null,"content":"关于我？ 叫我二夕就好，可能看到这里，你会好奇，为啥起一个这么怪的名字呢？？\n当时在想昵称的时候一直找不到合适的，打算叫“无名”，但总感觉有点落了俗套。还好，中文是比较有意思的，把“无”和“名”下面的部分拿了，不就是“二夕”了嘛。。。。。哈哈哈哈哈哈\n 玩什么？？ 常常会感慨自己是个老年人了，过了打游戏的年龄。在大学生活中，不打游戏，时间就多了起来。无聊的时候，总想找些东西打发时间。慢慢的，找到新的伙伴——悠悠球。停停停！！！我知道你想说：刚刚还感慨自己是老年人，现在又玩起小孩子的东西。\n大多数人对于悠悠球的印象可能还停留在儿时的玩具，是的，重新开始接触的时候，我也是那么认为的。但随着技术的提升，认识的玩家越来越多，会发现一个全新的世界。你会发现，有很多人都在为之而共同努力。只想把悠悠球，一种玩具，小众文化，推向大众。想得到大众的认可。\n 除了玩？？ 除了玩，那肯定就是吃和睡咯……呸呸呸，这不是我！！！\n学的专业是软件工程，所以平时最多打交道的就是代码，哪还有时间吃吃睡睡的，捋了捋自己的头发。作为一个日常摸鱼的当代大学生，平时无非就是看看书，写写代码，听听歌。就这？？\n","description":"","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"双向链表  一、基本介绍 在上一篇博客中，我们提到了单链表，它只有一个next指针，指向下一个结点，所以我们要查找下一个结点是很容易做到的，但是要想查找上一个结点就复杂的多了。因此有了双向链表。\n双向链表有两个指针域，除了有next域指向下一个结点之外，还有pre域指向上一个结点。这样使得双链表可以双向遍历。节省了时间成本，但相比于单链表插入数据和删除数据就相对复杂一些。下面我们对双链表进行简单学习一下吧。\n 二、算法实现 双链表和单链表一样，需要创建一个类用于存放结点信息，再创建一个类用于管理结点，对双链表进行相关的操作。\n1、定义节点类 我们需要在HeroNode2类中实现相关变量的定义、赋值以及显示信息的方法。\n①相关变量 这里我们使用双链表存储水浒英雄，和单链表相同，还得增加一个pre指针，指向前一个结点。\n代码实现如下：\n1 2 3 4 5  public int no; public String name; public String nickname; public HeroNode2 pre;// 指向下一个结点，默认为null  public HeroNode2 next;// 指向前一个结点，默认为null   ②构造器 利用构造器，对相关变量进行赋值。\n代码实现如下：\n1 2 3 4 5  public HeroNode2(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 这里利用toString方法，返回链表的信息。\n1 2 3 4 5 6 7 8 9  // 为了显示方法，重写toString  @Override public String toString() { return \"HeroNode2{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }    2、定义一个DoubleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，同样需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  // 先初始化一个结点，头结点不要动，不存放具体的数据  private HeroNode2 head = new HeroNode2(0, \"\", \"\");   ①添加数据到队列尾 与单链表相同，需要先定义一个辅助变量temp，利用while循环遍历到链表的最后。当退出while循环时，即temp指向了链表的最后。这时我们需要将temp的next域指向需要添加的结点，然后再将需要添加的结点的pre域指向temp，完成添加。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 添加一个结点到双向链表的最后  public void add(HeroNode2 heroNode2) { // 因为head结点不能动，因此我们需要添加一个辅助变量temp  HeroNode2 temp = head; // 遍历链表，知=找到链表的最后  while (true) { if (temp.next == null) {// 遍历到链表的最后  break; } // 如果没有找到将temp后移  temp = temp.next;// 后移  } // 当退出while循环时，temp就指向了链表的最后  // 形成了一个双向链表  temp.next = heroNode2; heroNode2.pre = temp; }   ②根据编号顺序添加结点 与单链表相同，需要先找到需要添加结点(heroNode2)的前一个结点（temp），这里不做过多赘述。当找到需要添加的结点的前一个结点之后，需要进行如下操作：\n需要先将heroNode2完成拼接，即先将heroNode2的next域指向temp.next;（新插入节点的前一个结点指向它的下一个结点），再将heroNode的pre域指向temp（将新插入的结点指向它的前一个结点），这时heroNode的pre域和next域已经分别指向了heroNode的前驱结点和后继结点；剩余需要做的就是让heroNode的前驱结点的next域和后继结点的pre域指向heroNode，但需要注意的是：如果添加的位置刚好是最后一个结点，则heroNode没有后继结点，也就是不用执行temp.next.pre = heroNode2。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 根据编号顺序添加结点  public void addByOrder(HeroNode2 heroNode2) { HeroNode2 temp = head; boolean flag = false; while (true) { if (temp.next == null) { break; } if (temp.next.no \u003e heroNode2.no) { break; } else if (temp.next.no == heroNode2.no) { flag = true; break; } temp = temp.next; } if (flag) { System.out.printf(\"需要插入的英雄编号%d已存在，添加失败\\n\", heroNode2.no); } else { heroNode2.next = temp.next;// 将新插入的结点指向它的下一个结点  heroNode2.pre = temp;// 将新插入的结点指向它的前一个结点  // 注：如果不是最后一个结点，则不需要执行下面这块代码，否则会出现空指针  if (temp.next != null) { temp.next.pre = heroNode2; } temp.next = heroNode2; } }   ③修改结点信息 修改结点信息的方法和单链表如出一辙，通过遍历找到需要修改结点所在的位置即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 修改结点信息（可以看待双向链表的结点内容修改和单向链表一样）  public void update(HeroNode2 newHeroNode2) { // 判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 找到需要修改的结点，根据no编号  HeroNode2 temp = head.next;// 定义一个辅助变量  boolean flag = false; while (true) { if (temp == null) { break; } if (temp.no == newHeroNode2.no) {// 找到  flag = true; break; } temp = temp.next; } //根据flag判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode2.name; temp.nickname = newHeroNode2.nickname; } else {//没有找到  System.out.printf(\"没有找到 编号%d的节点，不能修改\", newHeroNode2.no); } }   ④删除结点 从双向链表中删除一个结点，我们只需直接找到需要删除的结点，找到后，双链表可以实现自我删除。\n具体操作如下：定义一个辅助变量temp = head.next;这里我们直接找到该结点所在的位置，所以temp直接等于head.next;还需要一个flag标记是否找到待删除结点。通过遍历找到链表的最后，然后让temp的前驱结点的next域直接指向temp的下一个结点，即temp.pre.next = temp.next;如果待删除结点不是最后的结点，则还需要执行下列操作：让temp的下一个结点的pre指向temp的前一个结点，即temp.next.pre = temp.pre;完成上述操作之后，待删除结点的前后指针都指向null，也就完成了删除。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public void del(int no) { // 判断当前链表是否为空  if (head.next == null) {// 空链表  System.out.println(\"链表为空，无法删除~\"); return; } HeroNode2 temp = head.next; // 辅助变量(指针)  boolean flag = false; // 标志是否找到待删除节点的  while (true) { if (temp == null) { // 已经到链表的最后  break; } if (temp.no == no) { // 找到的待删除节点的前一个节点temp  flag = true; break; } temp = temp.next; // temp后移，遍历  } // 判断flag  if (flag) { // 找到  // 可以删除  temp.pre.next = temp.next; // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针  if (temp.next != null) { temp.next.pre = temp.pre; } } else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } }   ⑤输出链表信息 和单链表操作相同。。。。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 遍历打印输出链表信息  public void show() { // 先判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 因为头结点不能动，定义一个辅助变量用于遍历  HeroNode2 temp = head.next; while (true) { // 判断是否到链表最后  if (temp == null) { break; } // 输出结点信息  System.out.println(temp); temp = temp.next;// 将temp后移！！！  } }    三、结束语 到这里，我们完成了对于双链表的相关操作。双向链表相对于单链表来说，要更复杂一些，毕竟它多了pre指针，进行删除和操作的时候需要格外小心。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点操作带来了方便，可以有效提高算法的时间性能。说白了，就是用空间换时间。\n源代码——\u003e数据结构\n 《大话数据结构》 ——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构——双向链表","uri":"/posts/doublelinkedlist/"},{"categories":null,"content":"双向链表  一、基本介绍 在上一篇博客中，我们提到了单链表，它只有一个next指针，指向下一个结点，所以我们要查找下一个结点是很容易做到的，但是要想查找上一个结点就复杂的多了。因此有了双向链表。\n双向链表有两个指针域，除了有next域指向下一个结点之外，还有pre域指向上一个结点。这样使得双链表可以双向遍历。节省了时间成本，但相比于单链表插入数据和删除数据就相对复杂一些。下面我们对双链表进行简单学习一下吧。\n 二、算法实现 双链表和单链表一样，需要创建一个类用于存放结点信息，再创建一个类用于管理结点，对双链表进行相关的操作。\n1、定义节点类 我们需要在HeroNode2类中实现相关变量的定义、赋值以及显示信息的方法。\n①相关变量 这里我们使用双链表存储水浒英雄，和单链表相同，还得增加一个pre指针，指向前一个结点。\n代码实现如下：\n1 2 3 4 5  public int no; public String name; public String nickname; public HeroNode2 pre;// 指向下一个结点，默认为null  public HeroNode2 next;// 指向前一个结点，默认为null   ②构造器 利用构造器，对相关变量进行赋值。\n代码实现如下：\n1 2 3 4 5  public HeroNode2(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 这里利用toString方法，返回链表的信息。\n1 2 3 4 5 6 7 8 9  // 为了显示方法，重写toString  @Override public String toString() { return \"HeroNode2{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }    2、定义一个DoubleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，同样需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  // 先初始化一个结点，头结点不要动，不存放具体的数据  private HeroNode2 head = new HeroNode2(0, \"\", \"\");   ①添加数据到队列尾 与单链表相同，需要先定义一个辅助变量temp，利用while循环遍历到链表的最后。当退出while循环时，即temp指向了链表的最后。这时我们需要将temp的next域指向需要添加的结点，然后再将需要添加的结点的pre域指向temp，完成添加。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 添加一个结点到双向链表的最后  public void add(HeroNode2 heroNode2) { // 因为head结点不能动，因此我们需要添加一个辅助变量temp  HeroNode2 temp = head; // 遍历链表，知=找到链表的最后  while (true) { if (temp.next == null) {// 遍历到链表的最后  break; } // 如果没有找到将temp后移  temp = temp.next;// 后移  } // 当退出while循环时，temp就指向了链表的最后  // 形成了一个双向链表  temp.next = heroNode2; heroNode2.pre = temp; }   ②根据编号顺序添加结点 与单链表相同，需要先找到需要添加结点(heroNode2)的前一个结点（temp），这里不做过多赘述。当找到需要添加的结点的前一个结点之后，需要进行如下操作：\n需要先将heroNode2完成拼接，即先将heroNode2的next域指向temp.next;（新插入节点的前一个结点指向它的下一个结点），再将heroNode的pre域指向temp（将新插入的结点指向它的前一个结点），这时heroNode的pre域和next域已经分别指向了heroNode的前驱结点和后继结点；剩余需要做的就是让heroNode的前驱结点的next域和后继结点的pre域指向heroNode，但需要注意的是：如果添加的位置刚好是最后一个结点，则heroNode没有后继结点，也就是不用执行temp.next.pre = heroNode2。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 根据编号顺序添加结点  public void addByOrder(HeroNode2 heroNode2) { HeroNode2 temp = head; boolean flag = false; while (true) { if (temp.next == null) { break; } if (temp.next.no \u003e heroNode2.no) { break; } else if (temp.next.no == heroNode2.no) { flag = true; break; } temp = temp.next; } if (flag) { System.out.printf(\"需要插入的英雄编号%d已存在，添加失败\\n\", heroNode2.no); } else { heroNode2.next = temp.next;// 将新插入的结点指向它的下一个结点  heroNode2.pre = temp;// 将新插入的结点指向它的前一个结点  // 注：如果不是最后一个结点，则不需要执行下面这块代码，否则会出现空指针  if (temp.next != null) { temp.next.pre = heroNode2; } temp.next = heroNode2; } }   ③修改结点信息 修改结点信息的方法和单链表如出一辙，通过遍历找到需要修改结点所在的位置即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 修改结点信息（可以看待双向链表的结点内容修改和单向链表一样）  public void update(HeroNode2 newHeroNode2) { // 判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 找到需要修改的结点，根据no编号  HeroNode2 temp = head.next;// 定义一个辅助变量  boolean flag = false; while (true) { if (temp == null) { break; } if (temp.no == newHeroNode2.no) {// 找到  flag = true; break; } temp = temp.next; } //根据flag判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode2.name; temp.nickname = newHeroNode2.nickname; } else {//没有找到  System.out.printf(\"没有找到 编号%d的节点，不能修改\", newHeroNode2.no); } }   ④删除结点 从双向链表中删除一个结点，我们只需直接找到需要删除的结点，找到后，双链表可以实现自我删除。\n具体操作如下：定义一个辅助变量temp = head.next;这里我们直接找到该结点所在的位置，所以temp直接等于head.next;还需要一个flag标记是否找到待删除结点。通过遍历找到链表的最后，然后让temp的前驱结点的next域直接指向temp的下一个结点，即temp.pre.next = temp.next;如果待删除结点不是最后的结点，则还需要执行下列操作：让temp的下一个结点的pre指向temp的前一个结点，即temp.next.pre = temp.pre;完成上述操作之后，待删除结点的前后指针都指向null，也就完成了删除。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public void del(int no) { // 判断当前链表是否为空  if (head.next == null) {// 空链表  System.out.println(\"链表为空，无法删除~\"); return; } HeroNode2 temp = head.next; // 辅助变量(指针)  boolean flag = false; // 标志是否找到待删除节点的  while (true) { if (temp == null) { // 已经到链表的最后  break; } if (temp.no == no) { // 找到的待删除节点的前一个节点temp  flag = true; break; } temp = temp.next; // temp后移，遍历  } // 判断flag  if (flag) { // 找到  // 可以删除  temp.pre.next = temp.next; // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针  if (temp.next != null) { temp.next.pre = temp.pre; } } else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } }   ⑤输出链表信息 和单链表操作相同。。。。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 遍历打印输出链表信息  public void show() { // 先判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 因为头结点不能动，定义一个辅助变量用于遍历  HeroNode2 temp = head.next; while (true) { // 判断是否到链表最后  if (temp == null) { break; } // 输出结点信息  System.out.println(temp); temp = temp.next;// 将temp后移！！！  } }    三、结束语 到这里，我们完成了对于双链表的相关操作。双向链表相对于单链表来说，要更复杂一些，毕竟它多了pre指针，进行删除和操作的时候需要格外小心。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点操作带来了方便，可以有效提高算法的时间性能。说白了，就是用空间换时间。\n源代码——\u003e数据结构\n 《大话数据结构》 ——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构——双向链表","uri":"/tech/doublelinkedlist/"},{"categories":null,"content":"单链表的应用举例 一、前言 在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操作：\n 获取单链表的有效结点 查找单链表中的倒数第k个结点 逆序打印单链表（从尾到头打印） 反转单链表   二、算法介绍 1、获取单链表的有效结点 作为使用的第一个方法难度不是很大。因为需要求出单链表中有效结点的个数，所以我们可分为带头结点和不带头结点两种情况。\n我们这边考虑的是不带头结点的单链表，（如果是带头结点的链表需要再加上头结点即可）。需要的变量有length(统计链表的长度)和cur(辅助变量，用于遍历)，可以通过传入一个头结点，然后依次遍历该链表，当链表遍历到最后的时候，即cur.next == null，每一次遍历链表的长度加一，即length++。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // head链表的头结点，返回的就是有效结点的个数  public static int getLength(HeroNode head) { if (head.next == null) {// 链表为空  return 0; } int length = 0; HeroNode cur = head.next;// 定义一个辅助变量  while (cur != null) { length++; cur = cur.next; } return length; }   2、查找单链表中的倒数第k个结点 因为单链表是单向的，只能从头到尾开始遍历，而无法从后往前遍历，所以我们需要传入一个头结点head（遍历的起始位置）和index(倒数第k个结点)。\n定义一个size表示链表的长度，也就是链表有效结点的个数，可以通过方法一来获取。即size = getLength(head)，然后需要定义一个辅助变量用于遍历。然后通过for循环定位到倒数的index，即size - index的位置，也就是需要查找的倒数第k个结点。最后返回当前的辅助变量，完成查找。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static HeroNode findLastIndexNode(HeroNode head, int index) { // 判断链表是否为空，如果是则返回null  if (head.next == null) { return null;// 没有找到  } // 第一次遍历得到链表对的长度（结点个数）  int size = getLength(head); // 先做一个index校验  if (index \u003c 0 || index \u003e size) { return null; } // 定义一个辅助变量，for循环定位到倒数的index  HeroNode cur = head.next; // 第二次遍历 size - index位置，就是倒数的第k个结点  for (int i = 0; i \u003c size - index; i++) { cur = cur.next; } return cur; }   3、逆序打印单链表 在不改变链表结构的情况下，进行逆序打印，我们可以利用栈这个数据结构来实现。栈的特点就是先进后出。先把链表push压入栈中，再pop出栈即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public static void reversePrint(HeroNode head) { if (head.next == null) { return;// 空链表，不能打印  } // 创建一个栈，将各个结点压入栈  Stack\u003cHeroNode\u003e stack = new Stack\u003c\u003e(); HeroNode cur = head.next; // 将链表的所有结点压入到栈  while (cur != null) { stack.push(cur); cur = cur.next; } // 将栈中的结点进行打印，pop出栈  while (stack.size() \u003e 0) { System.out.println(stack.pop());// stack的特点就是先进后出  } }   4、反转单链表（有点难度） 对单链表进行反转，表示的意思是：将最后的结点变成最前端的结点，以此类推。所以我们需要分为两种情况：\n 当前链表为空，或者当前链表只有一个结点，无需反转，直接返回即可。 有多个结点时：  需要的变量有：cur(用于遍历原来的链表)，nextNode(指向当前结点[cur]的下一个结点)，reverseHead(结点，新链表的最前端)。\n具体操作过程如下：先将nexNodet指向cur的下一个结点，用于保存当前结点的下一个结点，然后将cur的下一个结点指向新链表的最前端，即cur.next = reverseHead.next,然后再将cur连接到新的链表上，这样才能形成一个完成的链表（一个回路）。然后后移，遍历下一个结点，即cur = nextNode;在进行上述操作之后，我们已经将链表的所有结点取出，并存放在新的链表下，这时我们需要将head.next 指向 reverseHead.next，实现单链表的反转，即**head.next = reverseHead,next;**完成单链表的反转。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void reverseList(HeroNode head) { // 如果当前链表为空，或者只有一个结点，无需反转，直接返回  if (head.next == null || head.next.next == null) { return; } HeroNode cur = head.next;// 定义一个辅助变量，帮助遍历原来的链表  HeroNode nextNode = null;// 指向当前结点[cur]的下一个结点  HeroNode reverseHead = new HeroNode(0, \"\", \"\"); // 遍历原来的链表，每遍历一个结点，将其取出，并放在新的链表reverseHead的最前端  while (cur != null) { nextNode = cur.next;// 先暂时保存当前结点的下一个结点，  cur.next = reverseHead.next;;// 将cur的下一个结点指向新的链表的最前端  reverseHead.next = cur;// 将cur连接到新的链表上  cur = nextNode;// 让cur后移  } // 将 head.next 指向 reverseHead.next，实现单链表的反转  head.next = reverseHead.next; }    三、结束语 其实我们不难发现，数组也好，链表也罢，都只是存储信息的不同方式，最重要的还是对其的理解和使用，只有这样才能更好的掌握。对于一个刚接触数据结构的小白来说，学到这里的时候，信息量已经远远超过之前所学的知识，但并不应该气馁，数据结构多而且难，所以更需要我们耐下性子，去慢慢琢磨、回顾，愿成长路上，与君共勉！\n源码地址——\u003e数据结构\n","description":"","tags":null,"title":"单链表的使用","uri":"/posts/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"单链表的应用举例 一、前言 在介绍完单链表的数据结构之后，我们将对原有的单链表进行如下操作：\n 获取单链表的有效结点 查找单链表中的倒数第k个结点 逆序打印单链表（从尾到头打印） 反转单链表   二、算法介绍 1、获取单链表的有效结点 作为使用的第一个方法难度不是很大。因为需要求出单链表中有效结点的个数，所以我们可分为带头结点和不带头结点两种情况。\n我们这边考虑的是不带头结点的单链表，（如果是带头结点的链表需要再加上头结点即可）。需要的变量有length(统计链表的长度)和cur(辅助变量，用于遍历)，可以通过传入一个头结点，然后依次遍历该链表，当链表遍历到最后的时候，即cur.next == null，每一次遍历链表的长度加一，即length++。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // head链表的头结点，返回的就是有效结点的个数  public static int getLength(HeroNode head) { if (head.next == null) {// 链表为空  return 0; } int length = 0; HeroNode cur = head.next;// 定义一个辅助变量  while (cur != null) { length++; cur = cur.next; } return length; }   2、查找单链表中的倒数第k个结点 因为单链表是单向的，只能从头到尾开始遍历，而无法从后往前遍历，所以我们需要传入一个头结点head（遍历的起始位置）和index(倒数第k个结点)。\n定义一个size表示链表的长度，也就是链表有效结点的个数，可以通过方法一来获取。即size = getLength(head)，然后需要定义一个辅助变量用于遍历。然后通过for循环定位到倒数的index，即size - index的位置，也就是需要查找的倒数第k个结点。最后返回当前的辅助变量，完成查找。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static HeroNode findLastIndexNode(HeroNode head, int index) { // 判断链表是否为空，如果是则返回null  if (head.next == null) { return null;// 没有找到  } // 第一次遍历得到链表对的长度（结点个数）  int size = getLength(head); // 先做一个index校验  if (index \u003c 0 || index \u003e size) { return null; } // 定义一个辅助变量，for循环定位到倒数的index  HeroNode cur = head.next; // 第二次遍历 size - index位置，就是倒数的第k个结点  for (int i = 0; i \u003c size - index; i++) { cur = cur.next; } return cur; }   3、逆序打印单链表 在不改变链表结构的情况下，进行逆序打印，我们可以利用栈这个数据结构来实现。栈的特点就是先进后出。先把链表push压入栈中，再pop出栈即可。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public static void reversePrint(HeroNode head) { if (head.next == null) { return;// 空链表，不能打印  } // 创建一个栈，将各个结点压入栈  Stack\u003cHeroNode\u003e stack = new Stack\u003c\u003e(); HeroNode cur = head.next; // 将链表的所有结点压入到栈  while (cur != null) { stack.push(cur); cur = cur.next; } // 将栈中的结点进行打印，pop出栈  while (stack.size() \u003e 0) { System.out.println(stack.pop());// stack的特点就是先进后出  } }   4、反转单链表（有点难度） 对单链表进行反转，表示的意思是：将最后的结点变成最前端的结点，以此类推。所以我们需要分为两种情况：\n 当前链表为空，或者当前链表只有一个结点，无需反转，直接返回即可。 有多个结点时：  需要的变量有：cur(用于遍历原来的链表)，nextNode(指向当前结点[cur]的下一个结点)，reverseHead(结点，新链表的最前端)。\n具体操作过程如下：先将nexNodet指向cur的下一个结点，用于保存当前结点的下一个结点，然后将cur的下一个结点指向新链表的最前端，即cur.next = reverseHead.next,然后再将cur连接到新的链表上，这样才能形成一个完成的链表（一个回路）。然后后移，遍历下一个结点，即cur = nextNode;在进行上述操作之后，我们已经将链表的所有结点取出，并存放在新的链表下，这时我们需要将head.next 指向 reverseHead.next，实现单链表的反转，即**head.next = reverseHead,next;**完成单链表的反转。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void reverseList(HeroNode head) { // 如果当前链表为空，或者只有一个结点，无需反转，直接返回  if (head.next == null || head.next.next == null) { return; } HeroNode cur = head.next;// 定义一个辅助变量，帮助遍历原来的链表  HeroNode nextNode = null;// 指向当前结点[cur]的下一个结点  HeroNode reverseHead = new HeroNode(0, \"\", \"\"); // 遍历原来的链表，每遍历一个结点，将其取出，并放在新的链表reverseHead的最前端  while (cur != null) { nextNode = cur.next;// 先暂时保存当前结点的下一个结点，  cur.next = reverseHead.next;;// 将cur的下一个结点指向新的链表的最前端  reverseHead.next = cur;// 将cur连接到新的链表上  cur = nextNode;// 让cur后移  } // 将 head.next 指向 reverseHead.next，实现单链表的反转  head.next = reverseHead.next; }    三、结束语 其实我们不难发现，数组也好，链表也罢，都只是存储信息的不同方式，最重要的还是对其的理解和使用，只有这样才能更好的掌握。对于一个刚接触数据结构的小白来说，学到这里的时候，信息量已经远远超过之前所学的知识，但并不应该气馁，数据结构多而且难，所以更需要我们耐下性子，去慢慢琢磨、回顾，愿成长路上，与君共勉！\n源码地址——\u003e数据结构\n","description":"","tags":null,"title":"单链表的使用","uri":"/tech/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"单向链表 一、基本介绍 1、相关定义 链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的，且链表的长度不是固定的。链表的每个元素称为一个结点，每个结点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑关系，以便构成“一个结点链着一个结点”的链式存储结构，为了保持每个结点之间的链接，所以链表除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个结点都包含两个部分，第一部分用于存储元素本身的数据信息，称为数据域，它不局限于一个成员数据，也可是多个成员数据；第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的节点信息，这里用next表，next的值实际上就是下一个结点的地址，当前结点为末结点时，next的值设为空指针，即为null。链表在使用过程中，可以根据实际需求来判断是否需要添加头结点。\n2、链表与数组比较 数组（包括结构体数组）的实质是一种线性表的顺序表示方式，它的优点是使用直观，便于快速、随机地存取线性表中的任一元素，但缺点是对其进行插入和删除操作时需要移动大量的数组元素，同时由于数组属于静态内存分配，定义数组时必须指定数组的长度，程序一旦运行，其长度就不能再改变，实际使用个数不能超过数组元素最大长度的限制，否则就会发生下标越界的错误，低于最大长度时又会造成系统资源的浪费，因此空间效率差。\n 二、算法实现 我们需要定义一个类用来存放结点信息，同时也还需要定义一个类用于管理结点，实现单链表的增删改查。\n1、定义一个HeroNode类表示结点 我们需要在HeroNode类中实现相关变量的定义、赋值以及显示信息的方法。\n① 相关变量 这里我们使用单链表来存储水浒英雄，需要存储的信息有：编号、姓名和昵称。还需要定义一个next域用于指向下一个结点。\n代码实现如下：\n1 2 3 4  public int no;// 编号  public String name;// 姓名  public String nickname;// 昵称  public HeroNode next;// next域，指向下一个节点   ②构造器 可以利用构造器对相关变量进行赋值。\n代买实现如下：\n1 2 3 4 5  public HeroNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 我们可以使用toString方法来显示链表的信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 利用toString显示信息  @Override public String toString() { return \"HeroNode{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }   2、定义一个SingleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  //先初始化一个头节点，头节点不要动，不存放具体的数据  private HeroNode head = new HeroNode(0, \"\", \"\");   ①直接添加数据到单链表 直接添加数据到队列尾，即不考虑编号按照添加顺序，入链表。因为头结点不能动，所以需要定义一个临时变量temp用于遍历。通过后移temp实现遍历，temp = temp.next 。遍历的目的在于，找到当前链表最后的结点，然后将最后这个结点的next指向新的结点，便完成了添加的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public void add(HeroNode heroNode) { //因为head节点不能动，因此我们需要一个辅助变量temp  HeroNode temp = head; //遍历链表，找到最后  while (true) { //找到链表的最后  if (temp.next == null) { break; } //如果没有找到最后，将temp后移  temp = temp.next; } //当退出while循环时，temp指向了链表的最后  //将最后这个节点的next指向新的节点  temp.next = heroNode; }   ②根据编号添加结点 这次我们使用按照编号顺序添加结点，如果该编号已经存在，则添加失败，并给出提示。按照编号添加结点，使用的方法是通过 后移temp 遍历，找到该编号的前一个结点，然后让需要的添加结点先指向前一个结点的下一个结点，然后再让前一个结点指向需要添加的结点。所以需要一个flag变量来标记是否找到当前结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public void addByOrder(HeroNode heroNode) { //因为头节点不能动，因此仍然需要通过一个辅助指针（变量）来帮助找到添加的位置  //因此我们找的temp是位于添加位置的前一个节点，否则插入不了  HeroNode temp = head; boolean flag = false;//标志添加的编号是否存在，默认为false  while (true) { if (temp.next == null) {//说明temp已经在链表的最后  break; } if (temp.next.no \u003e= heroNode.no) {//位置找到，就在temp的后面插入  break; } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode编号已经存在  flag = true;//说明编号存在  break; } temp = temp.next;//后移，遍历当前链表  } //判断flag的值  if (flag) {//不能添加，说明编号已经存在  System.out.printf(\"准备插入的英雄编号%d已经存在，添加失败\\n\", heroNode.no); } else { //插入到链表中，temp的后面  heroNode.next = temp.next; temp.next = heroNode; } }   ③修改结点信息 这里我们通过根据编号来修改结点信息，即编号不能改。同时需要传入一个新的结点 newHeroNode ，用于存储修改结点的信息。在进行修改之前，需要先判断单链表是否为空，head.next == null 链表为空。然后定义一个辅助变量temp和flag分别用于遍历和标记是否找到当前结点。如果 temp.no == newHeroNode.no 表示找到当前需要修改的结点。赋予新的name和nickname完成修改结点的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //1、根据newHeroNode的no来修改即可  public void update(HeroNode newHeroNode) { //判断是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //2、找到需要修改的节点，根据num编号修改  HeroNode temp = head.next;//定义一个辅助变量  boolean flag = false;//表示是否找到该节点  while (true) { if (temp == null) { break;//已经遍历结束  } if (temp.no == newHeroNode.no) {//找到  flag = true; break; } temp = temp.next; } //3、根据flag，判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; } else {//没有找到  System.out.printf(\"没有找到编号%d的节点，不能修改\\n\", newHeroNode.no); } }   ④删除结点 在进行删除结点的操作的时候，我们仍然根据编号来进行寻找需要删除的结点。找到需要删除结点的前一个结点，让前一个结点的next跨过需要删除的结点，直接指向下一个结点，即 temp.netx = temp.next.next ，完成删除。在进行删除之前仍然需要定义temp和flag用于遍历和标记是否找到需要删除结点的前一个结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public void del(int no) { HeroNode temp = head; boolean flag = false;//标志是否找到待删除节点  while (true) { if (temp.next == null) { break;//已经到链表的最后  } if (temp.next.no == no) {//找到待删除节点的前一个节点temp  flag = true; break; } temp = temp.next;//temp后移，遍历  } //判断flag  if (flag) {//找到  //可以删除  temp.next = temp.next.next; } else { System.out.printf(\"需要删除的%d节点不存在\\n\", no); } }   ⑤显示链表信息 在显示链表信息之前，需要先判断链表是否为空，并给出相关信息。通过后移临时变量temp完成遍历。先输出结点信息，每当输出一个结点信息，就需要后移一次。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //显示链表，遍历  public void show() { //判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //因为头节点不能动，因此我们需要一个辅助变量来遍历  HeroNode temp = head.next; while (temp != null) {// 判断是否到链表最后  //输出节点的信息  System.out.println(temp); //将temp后移  temp = temp.next; } }    三、结束语 到此，我们了解了有关单链表的相关操作。在算法实现过程中，可能不少小朋友会发现一些问题，比如为什么有时候临时变量 temp = head.next ， 而有时却变成了temp = head 了呢？？其实仔细阅读一遍代码，我们不难发现，当进行增删操作的时候，temp = head ，那是因为需要增删的结点刚好是直接添加到头结点之后的，如果变成了 head.next ， 则会造成覆盖结点的情况；而在进行修改和遍历的时候，临时变量 temp = head.next ，那是因为我们这里定义头结点为空，不存放任何数据，所以修改和遍历的时候，需要从真正的有效结点开始。\n源码已经push到 ——\u003e数据结构\n","description":"","tags":null,"title":"数据结构--单向链表","uri":"/posts/singlelinkedlist/"},{"categories":null,"content":"单向链表 一、基本介绍 1、相关定义 链表实际上是线性表的链式存储结构，与数组不同的是，它是用一组任意的存储单元来存储线性表中的数据，存储单元不一定是连续的，且链表的长度不是固定的。链表的每个元素称为一个结点，每个结点都可以存储在内存中的不同的位置，为了表示每个元素与后继元素的逻辑关系，以便构成“一个结点链着一个结点”的链式存储结构，为了保持每个结点之间的链接，所以链表除了存储元素本身的信息外，还要存储其直接后继信息，因此，每个结点都包含两个部分，第一部分用于存储元素本身的数据信息，称为数据域，它不局限于一个成员数据，也可是多个成员数据；第二部分是一个结构体指针，称为链表的指针域，用于存储其直接后继的节点信息，这里用next表，next的值实际上就是下一个结点的地址，当前结点为末结点时，next的值设为空指针，即为null。链表在使用过程中，可以根据实际需求来判断是否需要添加头结点。\n2、链表与数组比较 数组（包括结构体数组）的实质是一种线性表的顺序表示方式，它的优点是使用直观，便于快速、随机地存取线性表中的任一元素，但缺点是对其进行插入和删除操作时需要移动大量的数组元素，同时由于数组属于静态内存分配，定义数组时必须指定数组的长度，程序一旦运行，其长度就不能再改变，实际使用个数不能超过数组元素最大长度的限制，否则就会发生下标越界的错误，低于最大长度时又会造成系统资源的浪费，因此空间效率差。\n 二、算法实现 我们需要定义一个类用来存放结点信息，同时也还需要定义一个类用于管理结点，实现单链表的增删改查。\n1、定义一个HeroNode类表示结点 我们需要在HeroNode类中实现相关变量的定义、赋值以及显示信息的方法。\n① 相关变量 这里我们使用单链表来存储水浒英雄，需要存储的信息有：编号、姓名和昵称。还需要定义一个next域用于指向下一个结点。\n代码实现如下：\n1 2 3 4  public int no;// 编号  public String name;// 姓名  public String nickname;// 昵称  public HeroNode next;// next域，指向下一个节点   ②构造器 可以利用构造器对相关变量进行赋值。\n代买实现如下：\n1 2 3 4 5  public HeroNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; }   ③显示链表信息 我们可以使用toString方法来显示链表的信息。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 利用toString显示信息  @Override public String toString() { return \"HeroNode{\" + \"no='\" + no + '\\'' + \", name='\" + name + '\\'' + \", nickname=\" + nickname + '}'; }   2、定义一个SingleLinkedList类管理结点 我们需要在这个类中完成对于链表的增删改查。在进行相关操作之前，需要先定义一个头结点，不存放具体的数据，仅指向第一个结点。\n代码实现如下：\n1 2  //先初始化一个头节点，头节点不要动，不存放具体的数据  private HeroNode head = new HeroNode(0, \"\", \"\");   ①直接添加数据到单链表 直接添加数据到队列尾，即不考虑编号按照添加顺序，入链表。因为头结点不能动，所以需要定义一个临时变量temp用于遍历。通过后移temp实现遍历，temp = temp.next 。遍历的目的在于，找到当前链表最后的结点，然后将最后这个结点的next指向新的结点，便完成了添加的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public void add(HeroNode heroNode) { //因为head节点不能动，因此我们需要一个辅助变量temp  HeroNode temp = head; //遍历链表，找到最后  while (true) { //找到链表的最后  if (temp.next == null) { break; } //如果没有找到最后，将temp后移  temp = temp.next; } //当退出while循环时，temp指向了链表的最后  //将最后这个节点的next指向新的节点  temp.next = heroNode; }   ②根据编号添加结点 这次我们使用按照编号顺序添加结点，如果该编号已经存在，则添加失败，并给出提示。按照编号添加结点，使用的方法是通过 后移temp 遍历，找到该编号的前一个结点，然后让需要的添加结点先指向前一个结点的下一个结点，然后再让前一个结点指向需要添加的结点。所以需要一个flag变量来标记是否找到当前结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public void addByOrder(HeroNode heroNode) { //因为头节点不能动，因此仍然需要通过一个辅助指针（变量）来帮助找到添加的位置  //因此我们找的temp是位于添加位置的前一个节点，否则插入不了  HeroNode temp = head; boolean flag = false;//标志添加的编号是否存在，默认为false  while (true) { if (temp.next == null) {//说明temp已经在链表的最后  break; } if (temp.next.no \u003e= heroNode.no) {//位置找到，就在temp的后面插入  break; } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode编号已经存在  flag = true;//说明编号存在  break; } temp = temp.next;//后移，遍历当前链表  } //判断flag的值  if (flag) {//不能添加，说明编号已经存在  System.out.printf(\"准备插入的英雄编号%d已经存在，添加失败\\n\", heroNode.no); } else { //插入到链表中，temp的后面  heroNode.next = temp.next; temp.next = heroNode; } }   ③修改结点信息 这里我们通过根据编号来修改结点信息，即编号不能改。同时需要传入一个新的结点 newHeroNode ，用于存储修改结点的信息。在进行修改之前，需要先判断单链表是否为空，head.next == null 链表为空。然后定义一个辅助变量temp和flag分别用于遍历和标记是否找到当前结点。如果 temp.no == newHeroNode.no 表示找到当前需要修改的结点。赋予新的name和nickname完成修改结点的操作。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //1、根据newHeroNode的no来修改即可  public void update(HeroNode newHeroNode) { //判断是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //2、找到需要修改的节点，根据num编号修改  HeroNode temp = head.next;//定义一个辅助变量  boolean flag = false;//表示是否找到该节点  while (true) { if (temp == null) { break;//已经遍历结束  } if (temp.no == newHeroNode.no) {//找到  flag = true; break; } temp = temp.next; } //3、根据flag，判断是否找到需要修改的节点  if (flag) { temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; } else {//没有找到  System.out.printf(\"没有找到编号%d的节点，不能修改\\n\", newHeroNode.no); } }   ④删除结点 在进行删除结点的操作的时候，我们仍然根据编号来进行寻找需要删除的结点。找到需要删除结点的前一个结点，让前一个结点的next跨过需要删除的结点，直接指向下一个结点，即 temp.netx = temp.next.next ，完成删除。在进行删除之前仍然需要定义temp和flag用于遍历和标记是否找到需要删除结点的前一个结点。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public void del(int no) { HeroNode temp = head; boolean flag = false;//标志是否找到待删除节点  while (true) { if (temp.next == null) { break;//已经到链表的最后  } if (temp.next.no == no) {//找到待删除节点的前一个节点temp  flag = true; break; } temp = temp.next;//temp后移，遍历  } //判断flag  if (flag) {//找到  //可以删除  temp.next = temp.next.next; } else { System.out.printf(\"需要删除的%d节点不存在\\n\", no); } }   ⑤显示链表信息 在显示链表信息之前，需要先判断链表是否为空，并给出相关信息。通过后移临时变量temp完成遍历。先输出结点信息，每当输出一个结点信息，就需要后移一次。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //显示链表，遍历  public void show() { //判断链表是否为空  if (head.next == null) { System.out.println(\"链表为空\"); return; } //因为头节点不能动，因此我们需要一个辅助变量来遍历  HeroNode temp = head.next; while (temp != null) {// 判断是否到链表最后  //输出节点的信息  System.out.println(temp); //将temp后移  temp = temp.next; } }    三、结束语 到此，我们了解了有关单链表的相关操作。在算法实现过程中，可能不少小朋友会发现一些问题，比如为什么有时候临时变量 temp = head.next ， 而有时却变成了temp = head 了呢？？其实仔细阅读一遍代码，我们不难发现，当进行增删操作的时候，temp = head ，那是因为需要增删的结点刚好是直接添加到头结点之后的，如果变成了 head.next ， 则会造成覆盖结点的情况；而在进行修改和遍历的时候，临时变量 temp = head.next ，那是因为我们这里定义头结点为空，不存放任何数据，所以修改和遍历的时候，需要从真正的有效结点开始。\n源码已经push到 ——\u003e数据结构\n","description":"","tags":null,"title":"数据结构--单向链表","uri":"/tech/singlelinkedlist/"},{"categories":null,"content":"数组模拟环形队列  一、前言 在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。\n 二、算法实现 1、初始化相关变量 需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对front和rear做以下调整：front由原来指向队列的前一个位置，改变为队列的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；rear从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为maxSize - 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  private int maxSize;// 表示数组的最大容量  private int front;// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素  private int rear;// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0  private int[] arr;// 该数组用于存放数据，模拟队列  // 构造器  public CircleArray(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = 0; rear = 0; }   2、判断队列是否为满 我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针下一个位置是头指针的时候，表示队列满。（在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 (rear + 1) % maxSize == front 。( 这里取模的目的就是为了整合rear和front大小为一个问题 )\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return (rear + 1) % maxSize == front; }   3、判断队列是否为空 因为front和rear的初始值相同，所以判断队列空的方法与之前一样。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return rear == front; }   4、求出当前队列的有效数据个数 这个方法与之前相比是新添加的，其目的是为了判断遍历队列的长度。队列的有效数据的个数 = 尾队列 - 头队列，但有时front比rear大，有时front比rear小，所以可以通过取模的方式来实现。\n代码实现如下：\n1 2 3 4  // 求出当前队列的有效数据的个数  public int size() { return (rear + maxSize - front) % maxSize; }   5、入队列 添加数据入队的操作和之前相类似，只不过该队列front指向队列的第一个元素的位置，所以需要进行先赋值，然后再后移。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 添加数据入队列  public void addQueue(int n) { if (isFull()) { System.out.println(\"该队列已满，，无法添加任何数据~\"); return; } arr[rear] = n;// 直接将数据加入  rear = (rear + 1) % maxSize;// 将rear后移，这里必须考虑取模  }   6、出队列 之前由于头指针指向队列的前一个位置，所以先后移，到达需要取出数据的位置，从而返回即可 。但此时头指针所在的位置就是需要取出的位置，如果直接返回则无法进行后移，如果先后移，则取出的数据就是下一个位置的数据。我们可以做一下处理，从而达到想要的效果：\n 先把front对应的值保留到一个临时变量； 将front后移，考虑取模 将临时保存的变量返回  代码实现如下：\n1 2 3 4 5 6 7 8 9  // 从队列中取出数据  public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无任何数据可以取出~\"); } int val = arr[front]; front = (front + 1) % maxSize; return val; }   7、显示队列的所有数据 在遍历的时候，我们需要注意到因为是环形队列，需要从front开始遍历，遍历到什么位置结束呢？？ 在之前我们已经求出了有效数据的个数，所以遍历元素为 front + size()。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 显示队列的所有数据  public void show() { if (isEmpty()) { System.out.println(\"该队列为空，无任何数据可以显示~\"); return; } // 遍历时，从front开始遍历，遍历元素为 front+有效数据的个数  for (int i = front; i \u003c front + size(); i++) { System.out.printf(\"arr[%d]=%d\\n\", i % maxSize, arr[i % maxSize]); } }   8、显示队列的头数据 因为front指向的队列的一个元素的位置，所以直接返回即可。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示队列的头数据  public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无头数据可显示~\"); } return arr[front]; }    三、结束语 到此，我们了解了关于数组模拟循环队列的相关操作，在判断队列是为满的时候，可以尝试画图理解，（记住要队列要空出一个位置，留作约定哦！）还有一个难点，求出有效数据个数。其余方法，根据数组模拟队列做出相应的调整即可（由于front和rear指向的位置不同而做出的改变）。\n源码地址 ——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构--数组模拟环形队列","uri":"/posts/circlearrayqueue/"},{"categories":null,"content":"数组模拟环形队列  一、前言 在上一篇博客中我们介绍了如何使用数组模拟队列，但在使用的过程中会出现“假溢出”的现象。即取出数据的位置，无法再次存储数据，没有达到复用的效果。其实分析一下，我们不难发现，每次入队列的过程中，是通过后移rear来实现的，当rear移动到队列的最后的位置时，即使前面有空的位置，但添加数据，会出现指针越界的情况。针对这种情况，可以通过使用取模的方式来达到循环的效果。\n 二、算法实现 1、初始化相关变量 需要的相关变量仍然是：数组、数组的最大容量、队列头和队列尾。但这次我们对front和rear做以下调整：front由原来指向队列的前一个位置，改变为队列的第一个位置，也就是队列中第一个数据所在的位置，其初始值为0；rear从原来指向队列的最后一个数据调整为，现在的rear指向队列的最后一个数据的后一个位置，其初始值为0。这样这个队列就必须空出一个位置作为约定，实际数组可存储的数据个数为maxSize - 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  private int maxSize;// 表示数组的最大容量  private int front;// 指向队列的第一个元素，初始值是0，也就是队列的第一个元素  private int rear;// 指向队列的最后一个元素的后一个位置，空出一个位置作为约定，初始值为0  private int[] arr;// 该数组用于存放数据，模拟队列  // 构造器  public CircleArray(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = 0; rear = 0; }   2、判断队列是否为满 我们对front和rear的定义做了调整，所以判断队列满的方法也做出相应的改变，即当尾指针下一个位置是头指针的时候，表示队列满。（在前面提到rear指向队列最后一个元素的后一个位置，队列始终保持一个空的位置用于判断队列是否为满）由于是环形队列，所以rear可能比front大，也可能比front小，所以尽管它们只相差一个位置就是满的情况，但也可能是整整相差一圈。所以队列满的条件为 (rear + 1) % maxSize == front 。( 这里取模的目的就是为了整合rear和front大小为一个问题 )\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return (rear + 1) % maxSize == front; }   3、判断队列是否为空 因为front和rear的初始值相同，所以判断队列空的方法与之前一样。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return rear == front; }   4、求出当前队列的有效数据个数 这个方法与之前相比是新添加的，其目的是为了判断遍历队列的长度。队列的有效数据的个数 = 尾队列 - 头队列，但有时front比rear大，有时front比rear小，所以可以通过取模的方式来实现。\n代码实现如下：\n1 2 3 4  // 求出当前队列的有效数据的个数  public int size() { return (rear + maxSize - front) % maxSize; }   5、入队列 添加数据入队的操作和之前相类似，只不过该队列front指向队列的第一个元素的位置，所以需要进行先赋值，然后再后移。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 添加数据入队列  public void addQueue(int n) { if (isFull()) { System.out.println(\"该队列已满，，无法添加任何数据~\"); return; } arr[rear] = n;// 直接将数据加入  rear = (rear + 1) % maxSize;// 将rear后移，这里必须考虑取模  }   6、出队列 之前由于头指针指向队列的前一个位置，所以先后移，到达需要取出数据的位置，从而返回即可 。但此时头指针所在的位置就是需要取出的位置，如果直接返回则无法进行后移，如果先后移，则取出的数据就是下一个位置的数据。我们可以做一下处理，从而达到想要的效果：\n 先把front对应的值保留到一个临时变量； 将front后移，考虑取模 将临时保存的变量返回  代码实现如下：\n1 2 3 4 5 6 7 8 9  // 从队列中取出数据  public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无任何数据可以取出~\"); } int val = arr[front]; front = (front + 1) % maxSize; return val; }   7、显示队列的所有数据 在遍历的时候，我们需要注意到因为是环形队列，需要从front开始遍历，遍历到什么位置结束呢？？ 在之前我们已经求出了有效数据的个数，所以遍历元素为 front + size()。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  // 显示队列的所有数据  public void show() { if (isEmpty()) { System.out.println(\"该队列为空，无任何数据可以显示~\"); return; } // 遍历时，从front开始遍历，遍历元素为 front+有效数据的个数  for (int i = front; i \u003c front + size(); i++) { System.out.printf(\"arr[%d]=%d\\n\", i % maxSize, arr[i % maxSize]); } }   8、显示队列的头数据 因为front指向的队列的一个元素的位置，所以直接返回即可。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示队列的头数据  public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"该队列为空，无头数据可显示~\"); } return arr[front]; }    三、结束语 到此，我们了解了关于数组模拟循环队列的相关操作，在判断队列是为满的时候，可以尝试画图理解，（记住要队列要空出一个位置，留作约定哦！）还有一个难点，求出有效数据个数。其余方法，根据数组模拟队列做出相应的调整即可（由于front和rear指向的位置不同而做出的改变）。\n源码地址 ——\u003e 数据结构\n","description":"","tags":null,"title":"数据结构--数组模拟环形队列","uri":"/tech/circlearrayqueue/"},{"categories":null,"content":"数组模拟队列  一、基本介绍 1、队列介绍：   队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用数组或是链表来实现。\n  遵循先入先出的原则，允许插入的一端称为队尾，允许删除的一端称队头。\n  2、举例说明： 队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是先入先出的原则。\n二、算法实现 1、所需元素及其方法 在实现数组模拟队列的时候，我们需要先定义一个ArrayQueue类来存放所需的元素以及相关方法，所需元素有：数组arr[]：用于存放数据，模拟队列；数组的最大容量maxSize；队列头front；以及队列尾rear。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。\n代码实现如下：\n1 2 3 4  private int maxSize;// 表示数组的最大容量  private int front;// 队列头  private int rear;// 队列尾  private int[] arr;// 该数组用于存放数据，模拟队列   2、初始化相关变量 在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量maxSize，这时数组可以存放maxSize的数据，但数组下标的范围为arr[0]--arr[maxSize - 1]。为front和rear赋值为-1，即队列的前一个位置。\n代码实现如下：\n1 2 3 4 5 6 7  // 创建队列的构造器  public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1;// 指向队列头部，front是指向队列头的前一个位置  rear = -1;// 指向队列的尾部，rear是队列最后一个数据  }   3、判断队列是否为满 ​\t在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在不断变大。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即rear == arr[maxSize - 1]。\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return rear == maxSize - 1; }   4、判断队列是否为空 ​\t在初始状态下，front和rear均指向下标为-1的同一个位置，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向同一个下标的时候，表示所有数据已经全部出队列。所以当rear == front时，队列空。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return front == rear; }   5、添加数据到队列 在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 添加数据到队列  public void addQueue(int n) { // 首先判断队列是否为满  if (isFull()) { System.out.println(\"该队列已满，无法添加任何数据~\"); return; } rear++;// 让rear后移  arr[rear] = n; }   6、取出队列的数据 在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 获取队列的数据，出队列  public int getQueue() { // 首先判断队列是否为空  if (isEmpty()) {// 这里可以通过抛出异常处理  throw new RuntimeException(\"该队列为空，无法取出任何数据\"); } front++;// 让front后移  return arr[front]; }   7、显示队列所有数据 我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。注意在执行出队列的操作之后，front的值也随之后移，而且front指向的位置为队列的前一个位置，所以遍历的起始位置应该为front + 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示队列所有数据  public void showQueue() { // 先判断是否为空  if (isEmpty()) { System.out.println(\"该队列为空，无数据可显示~\"); return; } // 遍历  for (int i = front + 1; i \u003c arr.length; i++) { System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); } }   8、显示队列头的信息 需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要front + 1。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示头队列的信息，注意不是取出数据  public int headQueue() { // 先判断是否为空  if (isEmpty()) { throw new RuntimeException(\"队列为空，无数据可显示\"); } return arr[front + 1]; }   三、结束语 至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——\u003e 数据结构。\n 《大话数据结构》——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构--数组模拟队列","uri":"/posts/arrayqueue/"},{"categories":null,"content":"数组模拟队列  一、基本介绍 1、队列介绍：   队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用数组或是链表来实现。\n  遵循先入先出的原则，允许插入的一端称为队尾，允许删除的一端称队头。\n  2、举例说明： 队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是先入先出的原则。\n二、算法实现 1、所需元素及其方法 在实现数组模拟队列的时候，我们需要先定义一个ArrayQueue类来存放所需的元素以及相关方法，所需元素有：数组arr[]：用于存放数据，模拟队列；数组的最大容量maxSize；队列头front；以及队列尾rear。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。\n代码实现如下：\n1 2 3 4  private int maxSize;// 表示数组的最大容量  private int front;// 队列头  private int rear;// 队列尾  private int[] arr;// 该数组用于存放数据，模拟队列   2、初始化相关变量 在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量maxSize，这时数组可以存放maxSize的数据，但数组下标的范围为arr[0]--arr[maxSize - 1]。为front和rear赋值为-1，即队列的前一个位置。\n代码实现如下：\n1 2 3 4 5 6 7  // 创建队列的构造器  public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1;// 指向队列头部，front是指向队列头的前一个位置  rear = -1;// 指向队列的尾部，rear是队列最后一个数据  }   3、判断队列是否为满 ​\t在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在不断变大。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即rear == arr[maxSize - 1]。\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return rear == maxSize - 1; }   4、判断队列是否为空 ​\t在初始状态下，front和rear均指向下标为-1的同一个位置，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向同一个下标的时候，表示所有数据已经全部出队列。所以当rear == front时，队列空。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return front == rear; }   5、添加数据到队列 在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置）\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 添加数据到队列  public void addQueue(int n) { // 首先判断队列是否为满  if (isFull()) { System.out.println(\"该队列已满，无法添加任何数据~\"); return; } rear++;// 让rear后移  arr[rear] = n; }   6、取出队列的数据 在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 获取队列的数据，出队列  public int getQueue() { // 首先判断队列是否为空  if (isEmpty()) {// 这里可以通过抛出异常处理  throw new RuntimeException(\"该队列为空，无法取出任何数据\"); } front++;// 让front后移  return arr[front]; }   7、显示队列所有数据 我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。注意在执行出队列的操作之后，front的值也随之后移，而且front指向的位置为队列的前一个位置，所以遍历的起始位置应该为front + 1。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示队列所有数据  public void showQueue() { // 先判断是否为空  if (isEmpty()) { System.out.println(\"该队列为空，无数据可显示~\"); return; } // 遍历  for (int i = front + 1; i \u003c arr.length; i++) { System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); } }   8、显示队列头的信息 需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要front + 1。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示头队列的信息，注意不是取出数据  public int headQueue() { // 先判断是否为空  if (isEmpty()) { throw new RuntimeException(\"队列为空，无数据可显示\"); } return arr[front + 1]; }   三、结束语 至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——\u003e 数据结构。\n 《大话数据结构》——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构--数组模拟队列","uri":"/tech/arrayqueue/"},{"categories":null,"content":"稀疏数组  一、基本介绍 1、实际需求 假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：\n0 0 0 2 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用稀疏数组来保存该数组。\n2、相关概念 基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：\n   行 列 值     A B C   E F G     A：表示总行数 B：表示总列数 C：表示真正有效数值的个数（除0外的数值） E：表示该元素所在的行 F：表示该元素所在的列 G：表示该元素的数值  所以上述原始的二维数组转化成稀疏数组，应该如下：\n   row col value     10 10 4   0 3 2   1 3 1   1 4 2   2 2 1    ​\n 二、算法实现 1、创建并输出原始二维数组 ①创建原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  // 0表示没有棋子，1表示黑子，2表示白子  int chessArr1[][] = new int[10][10];// 创建一个原始的二维数组 10*10  chessArr1[1][3] = 1; chessArr1[1][4] = 2; chessArr1[2][3] = 1; chessArr1[0][3] = 2;\t  ②打印输出原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr1) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); }   2、将二维数组转换成稀疏数组 ①先遍历二维数组，记录非0数值的个数 ​\t遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8  int sum = 0;// 用于记录非0数值的个数  for (int i = 0; i \u003c chessArr1.length; i++) { for (int j = 0; j \u003c chessArr1.length; j++) { if (chessArr1[i][j] != 0) { sum++; } } }   ②创建对应的二维数组 ​\t在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。\n代码实现如下：\n1 2 3 4 5  int sparseArr[][] = new int[sum + 1][3]; // 给稀疏数组赋值  sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = sum;   ③遍历二维数组，将非0的值存放到 sparseArr 中 ​\t在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int count = 0;// count用于记录是第几个非0数据  for (int i = 0; i \u003c sparseArr.length; i++) { for (int j = 0; j \u003c sparseArr.length; j++) { if (chessArr1[i][j] != 0) { count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } } }   ④打印输出稀疏数组 代码实现如下：\n1 2 3  for (int i = 0; i \u003c sparseArr.length; i++) { System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); }   3、将稀疏数组恢复成原始的二维数组 ①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 ​\t将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小\n代码实现如下：\n1  int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];   ②再读取稀疏数组后后几行的数据 （从第二行开始！！！） ​\t因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i = 1; 读取所有非0数据即可，其余的位置，默认值为0。\n代码实现如下：\n1 2 3  for (int i = 1; i \u003c sparseArr.length; i++) { chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; }   ③输出恢复后的二维数组 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr2) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); }    三、结束语： ​\t第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！\n​\t源码我已push到我的Github仓库，数据结构，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！\n","description":"","tags":null,"title":"数据结构--稀疏数组","uri":"/posts/sparsearray/"},{"categories":null,"content":"稀疏数组  一、基本介绍 1、实际需求 假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：\n0 0 0 2 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用稀疏数组来保存该数组。\n2、相关概念 基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：\n   行 列 值     A B C   E F G     A：表示总行数 B：表示总列数 C：表示真正有效数值的个数（除0外的数值） E：表示该元素所在的行 F：表示该元素所在的列 G：表示该元素的数值  所以上述原始的二维数组转化成稀疏数组，应该如下：\n   row col value     10 10 4   0 3 2   1 3 1   1 4 2   2 2 1    ​\n 二、算法实现 1、创建并输出原始二维数组 ①创建原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  // 0表示没有棋子，1表示黑子，2表示白子  int chessArr1[][] = new int[10][10];// 创建一个原始的二维数组 10*10  chessArr1[1][3] = 1; chessArr1[1][4] = 2; chessArr1[2][3] = 1; chessArr1[0][3] = 2;\t  ②打印输出原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr1) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); }   2、将二维数组转换成稀疏数组 ①先遍历二维数组，记录非0数值的个数 ​\t遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8  int sum = 0;// 用于记录非0数值的个数  for (int i = 0; i \u003c chessArr1.length; i++) { for (int j = 0; j \u003c chessArr1.length; j++) { if (chessArr1[i][j] != 0) { sum++; } } }   ②创建对应的二维数组 ​\t在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。\n代码实现如下：\n1 2 3 4 5  int sparseArr[][] = new int[sum + 1][3]; // 给稀疏数组赋值  sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = sum;   ③遍历二维数组，将非0的值存放到 sparseArr 中 ​\t在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int count = 0;// count用于记录是第几个非0数据  for (int i = 0; i \u003c sparseArr.length; i++) { for (int j = 0; j \u003c sparseArr.length; j++) { if (chessArr1[i][j] != 0) { count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } } }   ④打印输出稀疏数组 代码实现如下：\n1 2 3  for (int i = 0; i \u003c sparseArr.length; i++) { System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); }   3、将稀疏数组恢复成原始的二维数组 ①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 ​\t将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小\n代码实现如下：\n1  int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];   ②再读取稀疏数组后后几行的数据 （从第二行开始！！！） ​\t因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i = 1; 读取所有非0数据即可，其余的位置，默认值为0。\n代码实现如下：\n1 2 3  for (int i = 1; i \u003c sparseArr.length; i++) { chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; }   ③输出恢复后的二维数组 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr2) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); }    三、结束语： ​\t第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！\n​\t源码我已push到我的Github仓库，数据结构，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！\n","description":"","tags":null,"title":"数据结构--稀疏数组","uri":"/tech/sparsearray/"},{"categories":null,"content":"前言 大政的Blog就这样稀里糊涂的开通了。\n 有时候闲着无聊，总想着写点什么，可能是乱七八糟的想法，可能是一段书评，也有可能是一段歌词。因为相对于话语的直白，文字能表达的情感是更加细腻的，它也可以将有些事情一直保存下去。\n也有可能是我天生就有点内向，甚至比较丧，不太喜欢说话。\n 当时之所以想开通Blog最主要是想督促自己保持学习的习惯，并且可以在这里记录一些关于学习的笔记。也有一部分原因是在这段时间接触了许多之前没有接触过的人和事，总想着这些美好的事和可爱的人更应该被文字所记录，而不是埋藏在我的心里。\n所以博客的内容可能是一串代码，一行文字，一条书评，一段歌词，或许是一句心里话。\n我既做不上神明，那当个野兽也好。\n","description":"","tags":null,"title":"Hello World ! Hello Blog !","uri":"/life/hello/"}]
