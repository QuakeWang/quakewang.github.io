[{"categories":null,"content":"数组模拟队列  一、基本介绍 1、队列介绍：   队列是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，可以使用数组或是链表来实现。\n  遵循先入先出的原则，允许插入的一端称为队尾，允许删除的一端称队头。\n  2、举例说明： 队列在我们的日常生活中，使用相当广泛，例如在银行排队，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，遵循的都是先入先出的原则。\n二、算法实现 1、所需元素及其方法 在实现数组模拟队列的时候，我们需要先定义一个ArrayQueue类来存放所需的元素以及相关方法，所需元素有：数组arr[]：用于存放数据，模拟队列；数组的最大容量maxSize；队列头front；以及队列尾rear。需要的相关方法有：判断队列是否为满；判断队列是否为空；入队列；出队列；显示队列；以及显示队列的头数据。\n代码实现如下：\n1 2 3 4  private int maxSize;// 表示数组的最大容量  private int front;// 队列头  private int rear;// 队列尾  private int[] arr;// 该数组用于存放数据，模拟队列   2、初始化相关变量 在初始化相关变量的时候，我们可以使用构造器，传入一个数组的最大容量maxSize，这时数组可以存放maxSize的数据，但数组下标的范围为arr[0]--arr[maxSize - 1]。为front和rear赋值为-1，即队列的前一个位置。\n代码实现如下：\n1 2 3 4 5 6 7  // 创建队列的构造器  public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1;// 指向队列头部，front是指向队列头的前一个位置  rear = -1;// 指向队列的尾部，rear是队列最后一个数据  }   3、判断队列是否为满 ​\t在添加数据时，队列头front保持不动，队列尾rear通过后移，从而实现数据入队列。所以在添加数据过程中，rear所指向的下标在不断变大。在初始化数组最大容量的时候，我们提到数组的最大下标为arr[maxSize - 1]，所以当rear指向arr[maxSize - 1]时，则队列为满。即rear == arr[maxSize - 1]。\n代码实现如下：\n1 2 3 4  // 判断队列是否为满  public boolean isFull() { return rear == maxSize - 1; }   4、判断队列是否为空 ​\t在初始状态下，front和rear均指向下标为-1的同一个位置，这时队列没有任何数据，为空；在出队列过程中，rear指针保持不变，front后移，当front和rear指向同一个下标的时候，表示所有数据已经全部出队列。所以当rear == front时，队列空。\n代码实现如下：\n1 2 3 4  // 判断队列是否为空  public boolean isEmpty() { return front == rear; }   5、添加数据到队列 在添加数据时，头指针front保持不动，每添加一个数据需要通过rear后移来实现入队列。之前在初始化的时候，我们可知rear的初始值为-1，即队列的前一个位置，所以我们需要先后移rear，让rear指向需要添加数据的位置，然后对其赋值。在添加数据之前，我们应该首先判断队列是否为满，防止出现指针越界的情况。（注：rear如果初始值为0，则需要先赋值，再后移，从而指向下一个需要添加数据的位置）入队列过程如图所示：\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10  // 添加数据到队列  public void addQueue(int n) { // 首先判断队列是否为满  if (isFull()) { System.out.println(\"该队列已满，无法添加任何数据~\"); return; } rear++;// 让rear后移  arr[rear] = n; }   6、取出队列的数据 在取出数据是，尾指针rear保持不动，每次取出一个数据，需要通过front后移来实现出队列。之前在初始化的时候，我们可知front的初始值为-1，即队列的前一个位置，所以我们需要先后移front，让front指向需要取出数据的位置，然后对其赋值。在取出数据之前，我们应该先判断队列是否为空，这里可以使用通过抛出异常的方法进行处理。取出过程如图所示：\n代码实现如下：\n1 2 3 4 5 6 7 8 9  // 获取队列的数据，出队列  public int getQueue() { // 首先判断队列是否为空  if (isEmpty()) {// 这里可以通过抛出异常处理  throw new RuntimeException(\"该队列为空，无法取出任何数据\"); } front++;// 让front后移  return arr[front]; }   7、显示队列所有数据 我们可以通过for循环遍历该数组，在遍历之前需要先判断队列是否为空。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12  // 显示队列所有数据  public void showQueue() { // 先判断是否为空  if (isEmpty()) { System.out.println(\"该队列为空，无数据可显示~\"); return; } // 遍历  for (int i = 0; i \u003c arr.length; i++) { System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); } }   8、显示队列头的信息 需要注意的是，我们这里只显示头队列的信息，而不是取出数据，因此并不需要后移任何指针。可以通过返回队列的头指针来实现。因为front是指向队列的前一个位置，所以在返回头指针的时候，需要front + 1。在显示队列头信息的时候，需要确保队列不为空，因此可以通过抛出异常来进行处理。\n代码实现如下：\n1 2 3 4 5 6 7 8  // 显示头队列的信息，注意不是取出数据  public int headQueue() { // 先判断是否为空  if (isEmpty()) { throw new RuntimeException(\"队列为空，无数据可显示\"); } return arr[front + 1]; }   三、结束语 至此，我们了解了关于数组模拟队列的相关操作，但在具体使用过程中，我们会发现其中的问题，当把数据再取出后，这个位置就不能再添加其他数据，因此我们可以考虑到使用取模的方式来实现循环使用的效果。在下一篇博客将会更新关于数组模拟环形队列的操作。本次内容源代码已经push到github ——\u003e 数据结构。\n 《大话数据结构》——程杰\n图解数据结构与算法——韩顺平\n ","description":"","tags":null,"title":"数据结构--数组模拟队列","uri":"/post/arrayqueue/"},{"categories":null,"content":"稀疏数组  一、基本介绍 1、实际需求 假设一个五子棋盘，用1表示黑子，2表示白子，0表示空白区域，那么则可以把该棋盘利用二维数组实现。如下：\n0 0 0 2 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 那么在上述这个二维数组中，除了1和2之外，其余的都是0。这些0我们并不关心，但是却占据大量的空间，因此可以使用稀疏数组来保存该数组。\n2、相关概念 基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。具体形式如下：\n   行 列 值     A B C   E F G     A：表示总行数 B：表示总列数 C：表示真正有效数值的个数（除0外的数值） E：表示该元素所在的行 F：表示该元素所在的列 G：表示该元素的数值  所以上述原始的二维数组转化成稀疏数组，应该如下：\n   row col value     10 10 4   0 3 2   1 3 1   1 4 2   2 2 1    ​\n 二、算法实现 1、创建并输出原始二维数组 ①创建原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  // 0表示没有棋子，1表示黑子，2表示白子  int chessArr1[][] = new int[10][10];// 创建一个原始的二维数组 10*10  chessArr1[1][3] = 1; chessArr1[1][4] = 2; chessArr1[2][3] = 1; chessArr1[0][3] = 2;\t  ②打印输出原始的二维数组： 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr1) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); }   2、将二维数组转换成稀疏数组 ①先遍历二维数组，记录非0数值的个数 ​\t遍历二维数组，并记录非0数据的个数，可用于创建稀疏数组时，对其第一行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8  int sum = 0;// 用于记录非0数值的个数  for (int i = 0; i \u003c chessArr1.length; i++) { for (int j = 0; j \u003c chessArr1.length; j++) { if (chessArr1[i][j] != 0) { sum++; } } }   ②创建对应的二维数组 ​\t在基本介绍中，我们可知，稀疏数组一共有三列，前两列分别存储非0数值所在的行数与列数，第三列表示非0数值所在的值；而其行数由非0数据的个数决定，行数 = 非0数据的个数 + 1（第一行），所以第一行需要单独赋值。\n代码实现如下：\n1 2 3 4 5  int sparseArr[][] = new int[sum + 1][3]; // 给稀疏数组赋值  sparseArr[0][0] = 10; sparseArr[0][1] = 10; sparseArr[0][2] = sum;   ③遍历二维数组，将非0的值存放到 sparseArr 中 ​\t在存放非0数据的时候，需要用到临时变量count用于记录。遍历的时候，可以利用双重for循环进行遍历，每当发现一个非0数据的时候，count++; 并且对其所在的位置和值进行赋值。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11  int count = 0;// count用于记录是第几个非0数据  for (int i = 0; i \u003c sparseArr.length; i++) { for (int j = 0; j \u003c sparseArr.length; j++) { if (chessArr1[i][j] != 0) { count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } } }   ④打印输出稀疏数组 代码实现如下：\n1 2 3  for (int i = 0; i \u003c sparseArr.length; i++) { System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); }   3、将稀疏数组恢复成原始的二维数组 ①先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 ​\t将稀疏数组恢复成原始的二维数组，实际上是一个逆过程。我们可以根据稀疏数组第一行的row和col来创建二维数组的大小\n代码实现如下：\n1  int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];   ②再读取稀疏数组后后几行的数据 （从第二行开始！！！） ​\t因为稀疏数组实际存储有效数据是从第二行开始的，所以在读取数据的时候，应该要从第二行开始！！！即int i = 1; 读取所有非0数据即可，其余的位置，默认值为0。\n代码实现如下：\n1 2 3  for (int i = 1; i \u003c sparseArr.length; i++) { chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; }   ③输出恢复后的二维数组 代码实现如下：\n1 2 3 4 5 6  for (int[] row : chessArr2) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); }    三、结束语： ​\t第一次写偏向于技术性的博客，关于内容排版以及问题描述可能存在许多不足之处，以后会慢慢改进。起初打算利用图解实现该过程，在实际算法实现的时候，发现该内容比较简单，所以采用了文字描述！\n​\t源码我已push到我的Github仓库，数据结构，小伙伴们，如果发现有哪些不足之处，或者需要改善的内容，可以提交pr噢！！！\n","description":"","tags":null,"title":"数据结构--稀疏数组","uri":"/post/sparsearray/"},{"categories":null,"content":"前言 大政的Blog就这样稀里糊涂的开通了。\n 有时候闲着无聊，总想着写点什么，可能是乱七八糟的想法，可能是一段书评，也有可能是一段歌词。因为相对于话语的直白，文字能表达的情感是更加细腻的，它也可以将有些事情一直保存下去。\n也有可能是我天生就有点内向，甚至比较丧，不太喜欢说话。\n 当时之所以想开通Blog最主要是想督促自己保持学习的习惯，并且可以在这里记录一些关于学习的笔记。也有一部分原因是在这段时间接触了许多之前没有接触过的人和事，总想着这些美好的事和可爱的人更应该被文字所记录，而不是埋藏在我的心里。\n所以博客的内容可能是一串代码，一行文字，一条书评，一段歌词，或许是一句心里话。\n我既做不上神明，那当个野兽也好。\n","description":"","tags":null,"title":"Hello World ! Hello Blog !","uri":"/post/hello/"}]
